src/main/java

com.vanguard.corp.ics.portal.config	
	PortalSDKConfiguration.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo.vanguard.com:8080/svn/tip/tip/via/PSI/Java/SMA/Shared/PortalService/trunk/src/main/java/com/vanguard/corp/ics/portal/config/PortalConfiguration.java $
 $LastChangedRevision: 597440 $
 $Author: uvtc $
 $LastChangedDate: 2017-09-20 14:42:44 +1000 (Wed, 20 Sep 2017) $
*/
package com.vanguard.corp.ics.portal.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
@Primary
public class PortalSDKConfiguration {

	@Value("$sma-data-transformer.webservice-{portal.products.endpoint}")
	private String portalProductEndpoint;

	@Value("$sma-data-transformer.webservice-{portal.references.endpoint}")
	private String portalReferenceEndpoint;

	@Value("$sma-data-transformer.webservice-{portal.tokenURL}")
	private String tokenURL;

	@Value("$sma-data-transformer.webservice-{portal.username}")
	private String portalUsername;

	@Value("$sma-data-transformer.webservice-{portal.password}")
	private String portalPassword;

	@Value("$sma-data-transformer.webservice-{portal.retryCount}")
	private int retryCount;

	public String getPortalProductEndpoint() {
		return portalProductEndpoint;
	}

	public void setPortalProductEndpoint(String portalProductEndpoint) {
		this.portalProductEndpoint = portalProductEndpoint;
	}

	public String getPortalReferenceEndpoint() {
		return portalReferenceEndpoint;
	}

	public void setPortalReferenceEndpoint(String portalReferenceEndpoint) {
		this.portalReferenceEndpoint = portalReferenceEndpoint;
	}

	public String getTokenURL() {
		return tokenURL;
	}

	public void setTokenURL(String tokenURL) {
		this.tokenURL = tokenURL;
	}

	public String getPortalUsername() {
		return portalUsername;
	}

	public void setPortalUsername(String portalUsername) {
		this.portalUsername = portalUsername;
	}

	public String getPortalPassword() {
		return portalPassword;
	}

	public void setPortalPassword(String portalPassword) {
		this.portalPassword = portalPassword;
	}

	public int getRetryCount() {
		return retryCount;
	}

	public void setRetryCount(int retryCount) {
		this.retryCount = retryCount;
	}

}



com.vanguard.corp.ics.sdt.dao.api.constants
	RestServiceConstants.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.constants;

public interface RestServiceConstants {

	public static final String PRODUCT_PORTAL_INCEPTION_DATE_FORMAT = "dd-MMM-yyyy";
}


com.vanguard.corp.ics.sdt.dao.api.domain.portal
	Currency.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/SDL/trunk/src/main/java/com/vanguard/corp/ics/domain/Currency.java $
 $LastChangedRevision: 589883 $
 $Author: uvtc $
 $LastChangedDate: 2017-08-16 21:20:10 -0400 (Wed, 16 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class Currency implements Serializable {

	private static final long serialVersionUID = -7830143657509915836L;

	private Long currencyId;

	private String currencyCode;

	private String currencyName;

	public Long getCurrencyId() {
		return currencyId;
	}

	public void setCurrencyId(Long currencyId) {
		this.currencyId = currencyId;
	}

	public String getCurrencyCode() {
		return currencyCode;
	}

	public void setCurrencyCode(String currencyCode) {
		this.currencyCode = currencyCode;
	}

	public String getCurrencyName() {
		return currencyName;
	}

	public void setCurrencyName(String currencyName) {
		this.currencyName = currencyName;
	}

}

	InvestmentGroup.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class InvestmentGroup implements Serializable {

	private static final long serialVersionUID = -7578991813592252231L;

	private Long investmentGroupId;
	
	private String investmentGroupCode;
	
	private String investmentGroupName;

	public Long getInvestmentGroupId() {
		return investmentGroupId;
	}

	public void setInvestmentGroupId(Long investmentGroupId) {
		this.investmentGroupId = investmentGroupId;
	}

	public String getInvestmentGroupCode() {
		return investmentGroupCode;
	}

	public void setInvestmentGroupCode(String investmentGroupCode) {
		this.investmentGroupCode = investmentGroupCode;
	}

	public String getInvestmentGroupName() {
		return investmentGroupName;
	}

	public void setInvestmentGroupName(String investmentGroupName) {
		this.investmentGroupName = investmentGroupName;
	}

}


	PortalProduct.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/SDL/trunk/src/main/java/com/vanguard/corp/ics/domain/PortalProduct.java $
 $LastChangedRevision: 587830 $
 $Author: uvtc $
 $LastChangedDate: 2017-08-08 20:25:09 -0400 (Tue, 08 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonFormat.Shape;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class PortalProduct {

	private Long productID;

	private Long productTypeID;

	private String productName;

	private String clientID;

	private String productCode;

	private String investmentStyleID;

	private String investmentObjective;
	
	private Long assetClassID;

	private Long investmentMarketID;

	private Long investmentGroupID;

	private Long baseCurrencyID;

	private Long hedgeTypeID;

	private Double hedgePercentage;

	private Long hedgeCurrencyID;

	private Long benchMarkProviderID;

	private String benchMarkName;

	private Long custodianID;

	private Long futuresClearingAgentID;

	private Double initialAUM;

	private Long initialAUMCurrencyID;

	private Long productFundingTypeID;
	
	private Long investmentManagementEntityID;
	
	private Long contactingEntityID;
	
	private Long salesTeamEntityID;
	
	private String targetLaunchDate;
	
	private String inceptionDate;
	
	private String terminationDate;
	
	private String perfInceptionDate;
	
	private String perfTerminationDate;
	
	private String targetTrackingRequiredFlag;
	
	private Long portfolioReturnCalcID;
	
	private Long cashFlowAssumpID;
	
	private Long benchMarkCalcID;
	
	private String fumBasedSplitTrackingFlag;
	
	private BigDecimal fumLimitexAnte;
	
	private BigDecimal exAnteMaxBreachIMAAbove;
	
	private BigDecimal exAnteMaxTriggernotificationAbove;
	
	private BigDecimal exAnteMaxBreachIMA;
	
	private BigDecimal exAnteMaxTriggernotification;
	
	private BigDecimal exPostMaxBreachIMA;
	
	private BigDecimal exPostMaxTriggernotification;

	private Long statusID;

	private String modifiedBy;
	
	@JsonFormat(shape = Shape.STRING, pattern = "yyyy-MM-dd")
	private LocalDate modifiedDate;
	
	private Currency currency;
	
	private InvestmentGroup investmentGroup;

	public Long getProductID() {
		return productID;
	}

	public void setProductID(Long productID) {
		this.productID = productID;
	}

	public Long getProductTypeID() {
		return productTypeID;
	}

	public void setProductTypeID(Long productTypeID) {
		this.productTypeID = productTypeID;
	}

	public String getProductName() {
		return productName;
	}

	public void setProductName(String productName) {
		this.productName = productName;
	}

	public String getClientID() {
		return clientID;
	}

	public void setClientID(String clientID) {
		this.clientID = clientID;
	}

	public String getProductCode() {
		return productCode;
	}

	public void setProductCode(String productCode) {
		this.productCode = productCode;
	}

	public String getInvestmentStyleID() {
		return investmentStyleID;
	}

	public void setInvestmentStyleID(String investmentStyleID) {
		this.investmentStyleID = investmentStyleID;
	}

	public String getInvestmentObjective() {
		return investmentObjective;
	}

	public void setInvestmentObjective(String investmentObjective) {
		this.investmentObjective = investmentObjective;
	}

	public Long getAssetClassID() {
		return assetClassID;
	}

	public void setAssetClassID(Long assetClassID) {
		this.assetClassID = assetClassID;
	}

	public Long getInvestmentMarketID() {
		return investmentMarketID;
	}

	public void setInvestmentMarketID(Long investmentMarketID) {
		this.investmentMarketID = investmentMarketID;
	}

	public Long getInvestmentGroupID() {
		return investmentGroupID;
	}

	public void setInvestmentGroupID(Long investmentGroupID) {
		this.investmentGroupID = investmentGroupID;
	}

	public Long getBaseCurrencyID() {
		return baseCurrencyID;
	}

	public void setBaseCurrencyID(Long baseCurrencyID) {
		this.baseCurrencyID = baseCurrencyID;
	}

	public Long getHedgeTypeID() {
		return hedgeTypeID;
	}

	public void setHedgeTypeID(Long hedgeTypeID) {
		this.hedgeTypeID = hedgeTypeID;
	}

	public Double getHedgePercentage() {
		return hedgePercentage;
	}

	public void setHedgePercentage(Double hedgePercentage) {
		this.hedgePercentage = hedgePercentage;
	}

	public Long getHedgeCurrencyID() {
		return hedgeCurrencyID;
	}

	public void setHedgeCurrencyID(Long hedgeCurrencyID) {
		this.hedgeCurrencyID = hedgeCurrencyID;
	}

	public Long getBenchMarkProviderID() {
		return benchMarkProviderID;
	}

	public void setBenchMarkProviderID(Long benchMarkProviderID) {
		this.benchMarkProviderID = benchMarkProviderID;
	}

	public String getBenchMarkName() {
		return benchMarkName;
	}

	public void setBenchMarkName(String benchMarkName) {
		this.benchMarkName = benchMarkName;
	}

	public Long getCustodianID() {
		return custodianID;
	}

	public void setCustodianID(Long custodianID) {
		this.custodianID = custodianID;
	}

	public Long getFuturesClearingAgentID() {
		return futuresClearingAgentID;
	}

	public void setFuturesClearingAgentID(Long futuresClearingAgentID) {
		this.futuresClearingAgentID = futuresClearingAgentID;
	}

	public Double getInitialAUM() {
		return initialAUM;
	}

	public void setInitialAUM(Double initialAUM) {
		this.initialAUM = initialAUM;
	}

	public Long getInitialAUMCurrencyID() {
		return initialAUMCurrencyID;
	}

	public void setInitialAUMCurrencyID(Long initialAUMCurrencyID) {
		this.initialAUMCurrencyID = initialAUMCurrencyID;
	}

	public Long getProductFundingTypeID() {
		return productFundingTypeID;
	}

	public void setProductFundingTypeID(Long productFundingTypeID) {
		this.productFundingTypeID = productFundingTypeID;
	}

	public Long getInvestmentManagementEntityID() {
		return investmentManagementEntityID;
	}

	public void setInvestmentManagementEntityID(Long investmentManagementEntityID) {
		this.investmentManagementEntityID = investmentManagementEntityID;
	}

	public Long getContactingEntityID() {
		return contactingEntityID;
	}

	public void setContactingEntityID(Long contactingEntityID) {
		this.contactingEntityID = contactingEntityID;
	}

	public Long getSalesTeamEntityID() {
		return salesTeamEntityID;
	}

	public void setSalesTeamEntityID(Long salesTeamEntityID) {
		this.salesTeamEntityID = salesTeamEntityID;
	}

	public String getTargetLaunchDate() {
		return targetLaunchDate;
	}

	public void setTargetLaunchDate(String targetLaunchDate) {
		this.targetLaunchDate = targetLaunchDate;
	}

	public String getInceptionDate() {
		return inceptionDate;
	}

	public void setInceptionDate(String inceptionDate) {
		this.inceptionDate = inceptionDate;
	}

	public String getTerminationDate() {
		return terminationDate;
	}

	public void setTerminationDate(String terminationDate) {
		this.terminationDate = terminationDate;
	}

	public String getPerfInceptionDate() {
		return perfInceptionDate;
	}

	public void setPerfInceptionDate(String perfInceptionDate) {
		this.perfInceptionDate = perfInceptionDate;
	}

	public String getPerfTerminationDate() {
		return perfTerminationDate;
	}

	public void setPerfTerminationDate(String perfTerminationDate) {
		this.perfTerminationDate = perfTerminationDate;
	}

	public String getTargetTrackingRequiredFlag() {
		return targetTrackingRequiredFlag;
	}

	public void setTargetTrackingRequiredFlag(String targetTrackingRequiredFlag) {
		this.targetTrackingRequiredFlag = targetTrackingRequiredFlag;
	}

	public Long getPortfolioReturnCalcID() {
		return portfolioReturnCalcID;
	}

	public void setPortfolioReturnCalcID(Long portfolioReturnCalcID) {
		this.portfolioReturnCalcID = portfolioReturnCalcID;
	}

	public Long getCashFlowAssumpID() {
		return cashFlowAssumpID;
	}

	public void setCashFlowAssumpID(Long cashFlowAssumpID) {
		this.cashFlowAssumpID = cashFlowAssumpID;
	}

	public Long getBenchMarkCalcID() {
		return benchMarkCalcID;
	}

	public void setBenchMarkCalcID(Long benchMarkCalcID) {
		this.benchMarkCalcID = benchMarkCalcID;
	}

	public String getFumBasedSplitTrackingFlag() {
		return fumBasedSplitTrackingFlag;
	}

	public void setFumBasedSplitTrackingFlag(String fumBasedSplitTrackingFlag) {
		this.fumBasedSplitTrackingFlag = fumBasedSplitTrackingFlag;
	}

	public BigDecimal getFumLimitexAnte() {
		return fumLimitexAnte;
	}

	public void setFumLimitexAnte(BigDecimal fumLimitexAnte) {
		this.fumLimitexAnte = fumLimitexAnte;
	}

	public BigDecimal getExAnteMaxBreachIMAAbove() {
		return exAnteMaxBreachIMAAbove;
	}

	public void setExAnteMaxBreachIMAAbove(BigDecimal exAnteMaxBreachIMAAbove) {
		this.exAnteMaxBreachIMAAbove = exAnteMaxBreachIMAAbove;
	}

	public BigDecimal getExAnteMaxTriggernotificationAbove() {
		return exAnteMaxTriggernotificationAbove;
	}

	public void setExAnteMaxTriggernotificationAbove(BigDecimal exAnteMaxTriggernotificationAbove) {
		this.exAnteMaxTriggernotificationAbove = exAnteMaxTriggernotificationAbove;
	}

	public BigDecimal getExAnteMaxBreachIMA() {
		return exAnteMaxBreachIMA;
	}

	public void setExAnteMaxBreachIMA(BigDecimal exAnteMaxBreachIMA) {
		this.exAnteMaxBreachIMA = exAnteMaxBreachIMA;
	}

	public BigDecimal getExAnteMaxTriggernotification() {
		return exAnteMaxTriggernotification;
	}

	public void setExAnteMaxTriggernotification(BigDecimal exAnteMaxTriggernotification) {
		this.exAnteMaxTriggernotification = exAnteMaxTriggernotification;
	}

	public BigDecimal getExPostMaxBreachIMA() {
		return exPostMaxBreachIMA;
	}

	public void setExPostMaxBreachIMA(BigDecimal exPostMaxBreachIMA) {
		this.exPostMaxBreachIMA = exPostMaxBreachIMA;
	}

	public BigDecimal getExPostMaxTriggernotification() {
		return exPostMaxTriggernotification;
	}

	public void setExPostMaxTriggernotification(BigDecimal exPostMaxTriggernotification) {
		this.exPostMaxTriggernotification = exPostMaxTriggernotification;
	}

	public Long getStatusID() {
		return statusID;
	}

	public void setStatusID(Long statusID) {
		this.statusID = statusID;
	}

	public String getModifiedBy() {
		return modifiedBy;
	}

	public void setModifiedBy(String modifiedBy) {
		this.modifiedBy = modifiedBy;
	}

	public LocalDate getModifiedDate() {
		return modifiedDate;
	}

	public void setModifiedDate(LocalDate modifiedDate) {
		this.modifiedDate = modifiedDate;
	}
	
	public void setModifiedDate(String modifiedDate) {
		setModifiedDate(LocalDate.parse(modifiedDate, DateTimeFormatter.ISO_LOCAL_DATE));
	}

	public Currency getCurrency() {
		return currency;
	}

	public void setCurrency(Currency currency) {
		this.currency = currency;
	}

	public InvestmentGroup getInvestmentGroup() {
		return investmentGroup;
	}

	public void setInvestmentGroup(InvestmentGroup investmentGroup) {
		this.investmentGroup = investmentGroup;
	}
}

com.vanguard.corp.ics.sdt.dao.api.portal

	ProductPortalService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.portal;

import java.util.List;

import javax.servlet.http.HttpServletRequest;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;

public interface ProductPortalService {

	public List<PortalProduct> getProducts(HttpServletRequest request);
	
	public PortalProduct getProduct(List<PortalProduct> products, String productCode);
	
	public Currency getProductCurrency(PortalProduct product, HttpServletRequest request);
	
	public InvestmentGroup getInvestmentGroup(PortalProduct product, HttpServletRequest request);
}


com.vanguard.corp.ics.sdt.dao.impl.config

	PortalConfiguration.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/SDL/trunk/src/main/java/com/vanguard/corp/ics/config/PortalConfiguration.java $
 $LastChangedRevision: 589895 $
 $Author: uvtc $
 $LastChangedDate: 2017-08-17 01:01:39 -0400 (Thu, 17 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PortalConfiguration {

	@Value("$sma-data-transformer.webservice-{portal.products.endpoint}")
	private String portalProductEndpoint;

	@Value("$sma-data-transformer.webservice-{portal.references.endpoint}")
	private String portalReferenceEndpoint;

	@Value("$sma-data-transformer.webservice-{portal.maxConnectionAttempts}")
	private int maxConnectionAttempts;

	public String getPortalProductEndpoint() {
		return portalProductEndpoint;
	}

	public void setPortalProductEndpoint(String portalProductEndpoint) {
		this.portalProductEndpoint = portalProductEndpoint;
	}

	public String getPortalReferenceEndpoint() {
		return portalReferenceEndpoint;
	}

	public void setPortalReferenceEndpoint(String portalReferenceEndpoint) {
		this.portalReferenceEndpoint = portalReferenceEndpoint;
	}

	public int getMaxConnectionAttempts() {
		return maxConnectionAttempts;
	}

	public void setMaxConnectionAttempts(int attempts) {
		this.maxConnectionAttempts = attempts;
	}

}


	ReportingDatabaseConfiguration.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.config;

import java.util.Properties;

import org.apache.tomcat.jdbc.pool.DataSource;
import org.apache.tomcat.jdbc.pool.PoolProperties;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories(basePackages = { "com.vanguard.corp.ics.repository", "com.vanguard.corp.ics.sdt.dao.impl.repository" }, entityManagerFactoryRef = "reportingEntityManagerFactory", transactionManagerRef = "reportingTransactionManager")
@EnableTransactionManagement
public class ReportingDatabaseConfiguration {

	@Value("$sma-data-transformer.webservice-{ORACLE_GMRADM_JDBC_URL}")
	private String sdtReportingConnectionUrl;
	
	@Value("${ORACLE_GMRADM_SRS_USER_ID1}")
	private String sdtDataSourceReportingUsername;

	@Value("${ORACLE_GMRADM_SRS_PASSWORD1}")
	private String sdtDataSourceReportingPassword;
	
	@Value("$sma-data-transformer.webservice-{jpa.hibernate.show_sql}")
	private boolean showSql;
	
	@Value("$sma-data-transformer.webservice-{jpa.hibernate.format_sql}")
	private boolean formatSql;
	
	@Value("$sma-data-transformer.webservice-{jpa.hibernate.use_sql_comments}")
	private boolean useSqlComments;

	@Bean(name = "reportingEntityManagerFactory")
	public LocalContainerEntityManagerFactoryBean getReportingEntityManagerFactory() {

		LocalContainerEntityManagerFactoryBean reportingEntityManagerFactory = new LocalContainerEntityManagerFactoryBean();
		reportingEntityManagerFactory.setPersistenceUnitName("GRMDB");
		reportingEntityManagerFactory.setDataSource(dataSource());
		reportingEntityManagerFactory.setJpaVendorAdapter(hibernateJpaVendorAdapter());
		reportingEntityManagerFactory.setPackagesToScan(new String[] { "com.vanguard.corp.ics.dao", "com.vanguard.corp.ics.sdt.dao.impl.entity" });
		
		Properties jpaProperties = new Properties();
		jpaProperties.put("hibernate.dialect", "org.hibernate.dialect.Oracle10gDialect");
		jpaProperties.put("hibernate.show_sql", showSql);
		jpaProperties.put("hibernate.format_sql", formatSql);
		jpaProperties.put("hibernate.use_sql_comments", useSqlComments);
		jpaProperties.put("hibernate.enable_lazy_load_no_trans", "true");

		reportingEntityManagerFactory.setJpaProperties(jpaProperties);

		return reportingEntityManagerFactory;
	}

	@Bean
	public DataSource dataSource() {

		PoolProperties poolProperties = new PoolProperties();
		poolProperties.setUrl(sdtReportingConnectionUrl);
		poolProperties.setDriverClassName("oracle.jdbc.OracleDriver");
		poolProperties.setUsername(sdtDataSourceReportingUsername);
		poolProperties.setPassword(sdtDataSourceReportingPassword);
		poolProperties.setDefaultAutoCommit(false);
		poolProperties.setDefaultReadOnly(false);
		poolProperties.setDefaultTransactionIsolation(2);
		poolProperties.setJmxEnabled(false);
		poolProperties.setTestWhileIdle(true);
		poolProperties.setTestOnBorrow(true);
		poolProperties.setValidationQuery("SELECT 1 FROM DUAL");
		poolProperties.setTestOnReturn(false);
		poolProperties.setValidationInterval(30000);
		poolProperties.setTimeBetweenEvictionRunsMillis(30000);
		poolProperties.setMaxActive(1000);
		poolProperties.setInitialSize(5);
		poolProperties.setMaxWait(10000);
		poolProperties.setRemoveAbandonedTimeout(30);
		poolProperties.setMinEvictableIdleTimeMillis(30000);
		poolProperties.setMinIdle(10);
		poolProperties.setLogAbandoned(true);
		poolProperties.setRemoveAbandoned(true);
		poolProperties.setJdbcInterceptors("org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;"
				+ "org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");

		DataSource dataSource = new DataSource();
		dataSource.setPoolProperties(poolProperties);

		return dataSource;
	}

	@Bean
	public HibernateJpaVendorAdapter hibernateJpaVendorAdapter() {

		return new HibernateJpaVendorAdapter();
	}

	@Bean(name = "reportingTransactionManager")
	public PlatformTransactionManager transactionManager() {
		JpaTransactionManager tm = new JpaTransactionManager();
		tm.setEntityManagerFactory(getReportingEntityManagerFactory().getObject());
		tm.setDataSource(dataSource());

		return tm;
	}
}


	SecurityMasterAccessConfig.java

/*
 ****************************************************************************
 *
 * Copyright (c)2016 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo.vanguard.com:8080/svn/tip/tip/via/PSI/Java/SMA/Shared/srs-security-master-data-access/branches/srs-security-master-data-access/src/test/java/com/vanguard/corp/ics/config/EntityManagerConfiguration.java $
 $LastChangedRevision: 602686 $
 $Author: USTB $
 $LastChangedDate: 2017-10-12 12:24:55 +1100 (Thu, 12 Oct 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.config;

import java.util.Properties;

import org.apache.tomcat.jdbc.pool.DataSource;
import org.apache.tomcat.jdbc.pool.PoolProperties;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

@Configuration
@EnableJpaRepositories(entityManagerFactoryRef = "entityManagerFactory")
public class SecurityMasterAccessConfig {
	@Value("$sma-data-transformer.webservice-{security.master.connectionURL}")
	private String sdlConnectionUrl;

	@Value("$sma-data-transformer.webservice-{security.master.username}")
	private String sdlDataSourceUsername;

	@Value("$sma-data-transformer.webservice-{security.master.password}")
	private String sdlDataSourcePassword;

	@Value("$sma-data-transformer.webservice-{security.master.driverClassName}")
	private String driverClassName;

	@Value("$sma-data-transformer.webservice-{security.master.showsql}")
	private Boolean showSQL;

	@Bean(name = "entityManagerFactory")
	public LocalContainerEntityManagerFactoryBean getEntityManagerFactory() {

		final LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();
		entityManagerFactory.setDataSource(sdlDataSource());
		entityManagerFactory.setJpaVendorAdapter(hibernateJpaVendorAdapter());
		entityManagerFactory.setPackagesToScan(new String[] {});
		
		//TODO Read property values from RTE properties.
		Properties jpaProperties = new Properties();
		jpaProperties.put("hibernate.dialect", "org.hibernate.dialect.SQLServerDialect");
		jpaProperties.put("hibernate.show_sql", "true");
		jpaProperties.put("hibernate.format_sql", "true");
		jpaProperties.put("hibernate.use_sql_comments", "false");
		jpaProperties.put("hibernate.enable_lazy_load_no_trans", "true");

		entityManagerFactory.setJpaProperties(jpaProperties);
		return entityManagerFactory;
	}

	@Bean
	public HibernateJpaVendorAdapter hibernateJpaVendorAdapter() {

		final HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();

		return adapter;
	}

	@Bean
	public DataSource sdlDataSource() {

		final PoolProperties poolProperties = new PoolProperties();
		poolProperties.setUrl(sdlConnectionUrl);
		poolProperties.setDriverClassName(driverClassName);
		poolProperties.setUsername(sdlDataSourceUsername);
		poolProperties.setPassword(sdlDataSourcePassword);

		poolProperties.setDefaultAutoCommit(false);
		poolProperties.setDefaultReadOnly(false);
		poolProperties.setDefaultTransactionIsolation(2);
		poolProperties.setJmxEnabled(false);
		poolProperties.setTestWhileIdle(true);
		poolProperties.setTestOnBorrow(true);
		poolProperties.setTestOnReturn(true);
		poolProperties.setValidationInterval(30000);
		poolProperties.setValidationQueryTimeout(30);
		poolProperties.setTimeBetweenEvictionRunsMillis(30000);
		poolProperties.setMaxActive(20);
		poolProperties.setInitialSize(5);
		poolProperties.setMaxWait(60000);
		poolProperties.setRemoveAbandonedTimeout(100);
		poolProperties.setMinEvictableIdleTimeMillis(30000);
		poolProperties.setMaxIdle(10);
		poolProperties.setMinIdle(5);
		poolProperties.setLogAbandoned(true);
		poolProperties.setRemoveAbandoned(false);
		poolProperties.setJdbcInterceptors(
				"org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;" +
						"org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");
		final Properties dbProperties = new Properties();
		dbProperties.put("hibernate.id.new_generator_mappings", "true");
		poolProperties.setDbProperties(dbProperties);

		final DataSource datasource = new DataSource();
		datasource.setPoolProperties(poolProperties);
		return datasource;
	}

}

com.vanguard.corp.ics.sdt.dao.impl.entity.report

	AccountBenchmarkAssociation.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

@Entity
@Table(name = "GMRADM.TACCT_BCHMRK_ASSOCN")
public class AccountBenchmarkAssociation extends Auditable {

	private static final long serialVersionUID = -3158016888303806839L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1ACCTBCHMRKASSOCNID")
	@SequenceGenerator(name = "GMRADM.SEQ1ACCTBCHMRKASSOCNID", sequenceName = "GMRADM.SEQ1ACCTBCHMRKASSOCNID", initialValue = 1, allocationSize = 1)
	@Column(name = "ACCT_BCHMRK_ASSOCN_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;
	
	@Column(name = "BCHMRK_EIP_ID")
	private String benchmarkEipId;
	
	@Column(name = "BCHMRK_ASSOCN_TYP")
	private String benchmarkAssociationType;
	
	@Column(name = "BCHMRK_NM")
	private String benchmarkName;

	public String getBenchmarkAssociationType() {
		return benchmarkAssociationType;
	}

	public String getBenchmarkEipId() {
		return benchmarkEipId;
	}

	public String getBenchmarkName() {
		return benchmarkName;
	}

	public Long getId() {
		return id;
	}

	public String getPortfolioId() {
		return portfolioId;
	}

	public void setBenchmarkAssociationType(String benchmarkAssociationType) {
		this.benchmarkAssociationType = benchmarkAssociationType;
	}

	public void setBenchmarkEipId(String benchmarkEipId) {
		this.benchmarkEipId = benchmarkEipId;
	}

	public void setBenchmarkName(String benchmarkName) {
		this.benchmarkName = benchmarkName;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

}


	AccountFund.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/Shared/TargetDataAccess/trunk/src/main/java/com/vanguard/corp/ics/dao/report/AccountFundDAO.java $
 $LastChangedRevision: 590398 $
 $Author: uqrc $
 $LastChangedDate: 2017-08-18 14:41:33 -0400 (Fri, 18 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TACCT_FND")
public class AccountFund extends Auditable {

	private static final long serialVersionUID = 7016381462869487647L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1ACCTFNDID")
	@SequenceGenerator(name = "GMRADM.SEQ1ACCTFNDID", sequenceName = "GMRADM.SEQ1ACCTFNDID", initialValue = 1, allocationSize = 1)
	@Column(name = "ACCT_FND_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;

	@Column(name = "ACCT_NM", nullable = false)
	private String accountName;
	
	@Column(name = "ACCT_SHRT_NM")
	private String accountShortName;
	
	@Column(name = "ACCT_TYP_CD", nullable = false)
	private String accountType;
	
	@Column(name = "ASSET_CLASSFN_ID", nullable = false)
	private Long assetClassificationId;
	
	@Column(name = "EIP_ID")
	private Long productEipID;

	@Column(name = "PORT_MGR_ID", nullable = false)
	private Long portfolioManagerId;
	
	@Column(name = "PORT_MGR", nullable = false)
	private String portfolioManager;
	
	@Column(name = "MGMT_STRTGY")
	private String managementStrategy;
	
	@Column(name = "CURRCY_CD", nullable = false)
	private String portfolioBaseCurrency;
	
	@Column(name = "INCPT_DT", nullable = false)
	private Date inceptionDate;
	
	@Column(name = "PORT_SZ_NO")
	private Long portfolioSize;
	
	@Column(name = "INV_OBJ_DESC")
	private String investmentObjective;

	public String getAccountName() {
		return accountName;
	}

	public String getAccountShortName() {
		return accountShortName;
	}

	public String getAccountType() {
		return accountType;
	}
	
	public Long getAssetClassificationId() {
		return assetClassificationId;
	}
	
	public Long getId() {
		return id;
	}

	public Date getInceptionDate() {
		return SafeCopy.date(inceptionDate);
	}

	public String getInvestmentObjective() {
		return investmentObjective;
	}

	public String getManagementStrategy() {
		return managementStrategy;
	}
	
	public String getPortfolioBaseCurrency() {
		return portfolioBaseCurrency;
	}

	public String getPortfolioId() {
		return portfolioId;
	}

	public String getPortfolioManager() {
		return portfolioManager;
	}

	public Long getPortfolioManagerId() {
		return portfolioManagerId;
	}

	public Long getPortfolioSize() {
		return portfolioSize;
	}

	public Long getProductEipID() {
		return productEipID;
	}

	public void setAccountName(String accountName) {
		this.accountName = accountName;
	}

	public void setAccountShortName(String accountShortName) {
		this.accountShortName = accountShortName;
	}

	public void setAccountType(String accountType) {
		this.accountType = accountType;
	}

	public void setAssetClassificationId(Long assetClassificationId) {
		this.assetClassificationId = assetClassificationId;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setInceptionDate(Date inceptionDate) {
		this.inceptionDate = SafeCopy.date(inceptionDate);
	}

	public void setInvestmentObjective(String investmentObjective) {
		this.investmentObjective = investmentObjective;
	}
	
	public void setManagementStrategy(String managementStrategy) {
		this.managementStrategy = managementStrategy;
	}

	public void setPortfolioBaseCurrency(String portfolioBaseCurrency) {
		this.portfolioBaseCurrency = portfolioBaseCurrency;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

	public void setPortfolioManager(String portfolioManager) {
		this.portfolioManager = portfolioManager;
	}

	public void setPortfolioManagerId(Long portfolioManagerId) {
		this.portfolioManagerId = portfolioManagerId;
	}

	public void setPortfolioSize(Long portfolioSize) {
		this.portfolioSize = portfolioSize;
	}

	public void setProductEipID(Long productEipID) {
		this.productEipID = productEipID;
	}

}

	AccountSetup.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TACCT_SETUP")
public class AccountSetup extends Auditable {

	private static final long serialVersionUID = -4003311034460290828L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1ACCTSMAID")
	@SequenceGenerator(name = "GMRADM.SEQ1ACCTSMAID", sequenceName = "GMRADM.SEQ1ACCTSMAID", initialValue = 1, allocationSize = 1)
	@Column(name = "ACCT_SMA_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;

	@Column(name = "ACCT_CLNT_NM", nullable = false)
	private String accountClientName;
	
	@Column(name = "RGN_LN_1_ADDR")
	private String addressLineOne;
	
	@Column(name = "RGN_LN_2_ADDR")
	private String addressLineTwo;
	
	@Column(name = "RGN_LN_3_ADDR")
	private String addressLineThree;
	
	@Column(name = "RGN_CNTRY_NM") 
	private String countryName;
	
	@Column(name = "RGN_POSTL_CD")
	private String postalCode;
	
	@Column(name = "AGRMT_BGN_DT")
	private Date agreementBeginDate;
	
	@Column(name = "AGRMT_END_DT")
	private Date agreementEndDate;
	
	@Column(name = "STATUS_CD", nullable = false)
	private String statusCode;

	public String getAccountClientName() {
		return accountClientName;
	}

	public String getAddressLineOne() {
		return addressLineOne;
	}
	
	public String getAddressLineThree() {
		return addressLineThree;
	}
	
	public String getAddressLineTwo() {
		return addressLineTwo;
	}

	public Date getAgreementBeginDate() {
		return SafeCopy.date(agreementBeginDate);
	}

	public Date getAgreementEndDate() {
		return SafeCopy.date(agreementEndDate);
	}

	public String getCountryName() {
		return countryName;
	}

	public Long getId() {
		return id;
	}

	public String getPortfolioId() {
		return portfolioId;
	}

	public String getPostalCode() {
		return postalCode;
	}

	public String getStatusCode() {
		return statusCode;
	}

	public void setAccountClientName(String accountClientName) {
		this.accountClientName = accountClientName;
	}

	public void setAddressLineOne(String addressLineOne) {
		this.addressLineOne = addressLineOne;
	}

	public void setAddressLineThree(String addressLineThree) {
		this.addressLineThree = addressLineThree;
	}

	public void setAddressLineTwo(String addressLineTwo) {
		this.addressLineTwo = addressLineTwo;
	}

	public void setAgreementBeginDate(Date agreementBeginDate) {
		this.agreementBeginDate = SafeCopy.date(agreementBeginDate);
	}

	public void setAgreementEndDate(Date agreementEndDate) {
		this.agreementEndDate = SafeCopy.date(agreementEndDate);
	}

	public void setCountryName(String countryName) {
		this.countryName = countryName;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

	public void setPostalCode(String postalCode) {
		this.postalCode = postalCode;
	}

	public void setStatusCode(String statusCode) {
		this.statusCode = statusCode;
	}

}


	AttributionSummary.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TPORT_ATTRTN_SUM", uniqueConstraints = @UniqueConstraint(columnNames = { "ATTRTN_ID"}))
public class AttributionSummary extends Auditable {

	private static final long serialVersionUID = 3656166780801373594L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ1ATTRTNID")
	@SequenceGenerator(name = "SEQ1ATTRTNID", sequenceName = "GMRADM.SEQ1ATTRTNID", initialValue = 1, allocationSize = 1)
	@Column(name = "ATTRTN_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portId;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;
	
	@ManyToOne
	@JoinColumn(name = "DATA_SRC_FILE_ID")
	private DatasourceFileDAO datasourceFileDAO;
	
	@Column(name = "ATTRTN_NM", nullable = false)
	private String name;

	@Column(name = "ONE_MM_VAL")
	private BigDecimal oneMonthVal;
	
	@Column(name = "THR_MM_VAL")
	private BigDecimal threeMonthVal;
	
	@Column(name = "SIX_MM_VAL")
	private BigDecimal sixMonthVal;
	
	@Column(name = "NINE_MM_VAL")
	private BigDecimal nineMonthVal;
	
	@Column(name = "TWLVE_MM_VAL")
	private BigDecimal twelveMonthVal;
	
	@Column(name = "YY_TO_DT_VAL")
	private BigDecimal yearToDateVal;
	
	@Column(name = "DISP_ORD_NO", nullable = false)
	private Integer displayOrder;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(String portId) {
		this.portId = portId;
	}

	public Date getEffectiveDate() {
		return SafeCopy.date(effectiveDate);
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = SafeCopy.date(effectiveDate);
	}

	
	public DatasourceFileDAO getDatasourceFileDAO() {
		return datasourceFileDAO;
	}

	public void setDatasourceFileDAO(DatasourceFileDAO datasourceFileDAO) {
		this.datasourceFileDAO = datasourceFileDAO;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public BigDecimal getOneMonthVal() {
		return oneMonthVal;
	}

	public void setOneMonthVal(BigDecimal oneMonthVal) {
		this.oneMonthVal = oneMonthVal;
	}

	public BigDecimal getThreeMonthVal() {
		return threeMonthVal;
	}

	public void setThreeMonthVal(BigDecimal threeMonthVal) {
		this.threeMonthVal = threeMonthVal;
	}

	public BigDecimal getSixMonthVal() {
		return sixMonthVal;
	}

	public void setSixMonthVal(BigDecimal sixMonthVal) {
		this.sixMonthVal = sixMonthVal;
	}

	public BigDecimal getNineMonthVal() {
		return nineMonthVal;
	}

	public void setNineMonthVal(BigDecimal nineMonthVal) {
		this.nineMonthVal = nineMonthVal;
	}

	public BigDecimal getTwelveMonthVal() {
		return twelveMonthVal;
	}

	public void setTwelveMonthVal(BigDecimal twelveMonthVal) {
		this.twelveMonthVal = twelveMonthVal;
	}

	public BigDecimal getYearToDateVal() {
		return yearToDateVal;
	}

	public void setYearToDateVal(BigDecimal yearToDateVal) {
		this.yearToDateVal = yearToDateVal;
	}

	public Integer getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(Integer displayOrder) {
		this.displayOrder = displayOrder;
	}
}

	Auditable.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.io.Serializable;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.MappedSuperclass;

import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@MappedSuperclass
public abstract class Auditable implements Serializable {

	private static final long serialVersionUID = -6127763265731375535L;

	@Column(name = "EFFTV_BGN_DT", insertable = false, updatable = false)
	private Date effectiveBeginDate;

	@Column(name = "EFFTV_END_DT")
	private Date effectiveEndDate;

	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String lastUpdatedUserId;

	@Column(name = "LST_UPDTD_TS", insertable = false, updatable = false)
	private Date lastUpdatedDate;

	public Date getEffectiveBeginDate() {
		return SafeCopy.date(effectiveBeginDate);
	}

	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = SafeCopy.date(effectiveBeginDate);
	}

	public Date getEffectiveEndDate() {
		return SafeCopy.date(effectiveEndDate);
	}

	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = SafeCopy.date(effectiveEndDate);
	}

	public String getLastUpdatedUserId() {
		return lastUpdatedUserId;
	}

	public void setLastUpdatedUserId(String lastUpdatedUserId) {
		this.lastUpdatedUserId = lastUpdatedUserId;
	}

	public Date getLastUpdatedDate() {
		return SafeCopy.date(lastUpdatedDate);
	}

	public void setLastUpdatedDate(Date lastUpdatedDate) {
		this.lastUpdatedDate = SafeCopy.date(lastUpdatedDate);
	}
}

	BrokerageAndTaxes.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TFND_CHRG")
public class BrokerageAndTaxes extends Auditable {

	private static final long serialVersionUID = -897250767441487039L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1CHRGID")
	@SequenceGenerator(name = "GMRADM.SEQ1CHRGID", sequenceName = "GMRADM.SEQ1CHRGID", initialValue = 1, allocationSize = 1)
	@Column(name = "CHRG_ID", nullable = false)
	private Long id;

	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date asOfDate;

	@Column(name = "FND_CHRG_TYP_CD", nullable = false)
	private String fundChargeType;

	@Column(name = "FND_CHRG_CURRCY_CD")
	private String fundChargeCurrency;

	@Column(name = "FND_CHRG_FREQ_CD")
	private String fundChargeFrequency;

	@Column(name = "FND_CHRG_AM")
	private BigDecimal fundChargeAmount;
	
	@ManyToOne
	@JoinColumn(name = "DATA_SRC_FILE_ID")
	private DatasourceFileDAO datasourceFileDAO;

	public Date getAsOfDate() {
		return SafeCopy.date(asOfDate);
	}

	public BigDecimal getFundChargeAmount() {
		return fundChargeAmount;
	}

	public String getFundChargeCurrency() {
		return fundChargeCurrency;
	}

	public String getFundChargeFrequency() {
		return fundChargeFrequency;
	}

	public String getFundChargeType() {
		return fundChargeType;
	}

	public Long getId() {
		return id;
	}

	public String getPortfolioId() {
		return portfolioId;
	}

	public void setAsOfDate(Date asOfDate) {
		this.asOfDate = SafeCopy.date(asOfDate);
	}

	public void setFundChargeAmount(BigDecimal fundChargeAmount) {
		this.fundChargeAmount = fundChargeAmount;
	}

	public void setFundChargeCurrency(String fundChargeCurrency) {
		this.fundChargeCurrency = fundChargeCurrency;
	}

	public void setFundChargeFrequency(String fundChargeFrequency) {
		this.fundChargeFrequency = fundChargeFrequency;
	}

	public void setFundChargeType(String fundChargeType) {
		this.fundChargeType = fundChargeType;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

	public DatasourceFileDAO getDatasourceFileDAO() {
		return datasourceFileDAO;
	}

	public void setDatasourceFileDAO(DatasourceFileDAO datasourceFileDAO) {
		this.datasourceFileDAO = datasourceFileDAO;
	}
}


	Characteristics.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

/**
 * @author UT0T
 *
 */
@Entity
@Table(name = "GMRADM.TPORT_CHARACTERISTICS")
public class Characteristics extends Auditable {

	private static final long serialVersionUID = -1016273901287694278L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ1CHARID")
	@SequenceGenerator(name = "SEQ1CHARID", sequenceName = "GMRADM.SEQ1CHARID", initialValue = 1, allocationSize = 1)
	@Column(name = "CHAR_ID", nullable = false)
	private Long id;

	@Column(name = "PORT_ID", nullable = false)
	private String portId;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;
	
	@ManyToOne
	@JoinColumn(name = "DATA_SRC_FILE_ID")
	private DatasourceFileDAO datasourceFileDAO;
	
	@Column(name = "CHAR_TYP_CD", length = 8, nullable = false)
	private String type;

	@Column(name = "CHAR_NM")
	private String name;
	
	@Column(name = "PORT_VAL_NO")
	private BigDecimal portfolio;

	@Column(name = "BCHMRK_VAL_NO")
	private BigDecimal benchmark;
	
	public DatasourceFileDAO getDatasourceFileDAO() {
		return datasourceFileDAO;
	}

	public void setDatasourceFileDAO(DatasourceFileDAO datasourceFileDAO) {
		this.datasourceFileDAO = datasourceFileDAO;
	}

	/**
	 * @return the portfolio
	 */
	public BigDecimal getPortfolio() {
		return portfolio;
	}

	/**
	 * @param portfolio
	 *            the portfolio to set
	 */
	public void setPortfolio(BigDecimal portfolio) {
		this.portfolio = portfolio;
	}

	/**
	 * @return the benchmark
	 */
	public BigDecimal getBenchmark() {
		return benchmark;
	}

	/**
	 * @param benchmark
	 *            the benchmark to set
	 */
	public void setBenchmark(BigDecimal benchmark) {
		this.benchmark = benchmark;
	}

	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}

	/**
	 * @param name
	 *            the name to set
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * @return the id
	 */
	public Long getId() {
		return id;
	}

	/**
	 * @param id
	 *            the id to set
	 */
	public void setId(Long id) {
		this.id = id;
	}

	/**
	 * @return the portId
	 */
	public String getPortId() {
		return portId;
	}

	/**
	 * @param portId
	 *            the portId to set
	 */
	public void setPortId(String portId) {
		this.portId = portId;
	}

	/**
	 * @return the type
	 */
	public String getType() {
		return type;
	}

	/**
	 * @param type
	 *            the type to set
	 */
	public void setType(String type) {
		this.type = type;
	}

	/**
	 * @return the effectiveDate
	 */
	public Date getEffectiveDate() {
		return SafeCopy.date(effectiveDate);
	}

	/**
	 * @param effectiveDate the effectiveDate to set
	 */
	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = SafeCopy.date(effectiveDate);
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (obj instanceof Characteristics == false) {
			return false;
		}
		Characteristics that = (Characteristics) obj;
		
		return new EqualsBuilder()
				.append(this.effectiveDate, that.effectiveDate)
				.append(this.portId, that.portId)
				.append(this.type, that.type)
				.append(this.name, that.name)
				.append(this.portfolio, that.portfolio)
				.append(this.benchmark, that.benchmark)
				.isEquals();
	}

	@Override
	public int hashCode() {
		return new HashCodeBuilder()
				.append(this.effectiveDate)
				.append(this.portId)
				.append(this.type)
				.append(this.name)
				.append(this.portfolio)
				.append(this.benchmark)
				.toHashCode();
	}
}


	Commentary.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TPORT_PRFMC_CMNT")
public class Commentary extends Auditable {

	private static final long serialVersionUID = 7609558027602803675L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1CMNTID")
	@SequenceGenerator(name = "GMRADM.SEQ1CMNTID", sequenceName = "GMRADM.SEQ1CMNTID", initialValue = 1, allocationSize = 1)
	@Column(name = "CMNT_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portId;
	
	@Column(name = "EFFTV_DT", nullable = false) 
	private Date asOfDate;
	
	@Column(name = "CMNT_TX")
	private String commentaryText;
	
	@Column(name = "CMNT_RSN_TYP_CD")
	private String commentaryReason;

	public String getCommentaryReason() {
		return commentaryReason;
	}

	public String getCommentaryText() {
		return commentaryText;
	}

	public Date getEffectiveDate() {
		return SafeCopy.date(asOfDate);
	}

	public Long getId() {
		return id;
	}

	public String getPortfolioId() {
		return portId;
	}

	public void setCommentaryReason(String commentaryReason) {
		this.commentaryReason = commentaryReason;
	}

	public void setCommentaryText(String commentaryText) {
		this.commentaryText = commentaryText;
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.asOfDate = SafeCopy.date(effectiveDate);
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setPortfolioId(String portfolioId) {
		this.portId = portfolioId;
	}
}


	Limit.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

@Entity
@Table(name="GMRADM.TPORT_LIM")
public class Limit extends Auditable {

	private static final long serialVersionUID = 1949826965436239469L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1LIMID")
	@SequenceGenerator(name = "GMRADM.SEQ1LIMID", sequenceName = "GMRADM.SEQ1LIMID", initialValue = 1,allocationSize = 1)
	@Column(name = "LIM_ID")
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioCode;
	
	@Column(name = "LIM_TYP_CD", nullable = false)
	private String limitTypeCode;
	
	@Column(name = "LIM_NM", nullable = false)
	private String limitName;
	
	@Column(name = "LOWR_LIM_VAL")
	private BigDecimal lowerLimitValue;
	
	@Column(name = "UPR_LIM_VAL")
	private BigDecimal upperLimitValue;
	
	@Column(name = "FUM_SPLT_LIM_VAL")
	private BigDecimal fumSplitLimitValue;
	
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getPortfolioCode() {
		return portfolioCode;
	}

	public void setPortfolioCode(String portfolioCode) {
		this.portfolioCode = portfolioCode;
	}

	public String getLimitTypeCode() {
		return limitTypeCode;
	}

	public void setLimitTypeCode(String limitTypeCode) {
		this.limitTypeCode = limitTypeCode;
	}

	public String getLimitName() {
		return limitName;
	}

	public void setLimitName(String limitName) {
		this.limitName = limitName;
	}

	public BigDecimal getLowerLimitValue() {
		return lowerLimitValue;
	}

	public void setLowerLimitValue(BigDecimal lowerLimitValue) {
		this.lowerLimitValue = lowerLimitValue;
	}

	public BigDecimal getUpperLimitValue() {
		return upperLimitValue;
	}

	public void setUpperLimitValue(BigDecimal upperLimitValue) {
		this.upperLimitValue = upperLimitValue;
	}

	public BigDecimal getFumSplitLimitValue() {
		return fumSplitLimitValue;
	}

	public void setFumSplitLimitValue(BigDecimal fumSplitLimitValue) {
		this.fumSplitLimitValue = fumSplitLimitValue;
	}
}


	PerformanceSummary.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TPORT_PRFMC_SUM")
public class PerformanceSummary extends Auditable {

	private static final long serialVersionUID = -1959909710114157028L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ1PRFMCSUMID")
	@SequenceGenerator(name = "SEQ1PRFMCSUMID", sequenceName = "GMRADM.SEQ1PRFMCSUMID", initialValue = 1, allocationSize = 1)
	@Column(name = "PRFMC_SUM_ID", nullable = false)
	private Long performanceSummaryId;

	@Column(name = "PORT_ID", nullable = false)
	private String portId;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;

	@ManyToOne
	@JoinColumn(name = "DATA_SRC_FILE_ID")
	private DatasourceFileDAO datasourceFileDAO;
	
	@Column(name = "PRFMC_TYP_NM", nullable = false)
	private String performanceTypeName;

	@Column(name = "PRFMC_TYP_CD", nullable = false)
	private String performanceTypeCode;

	@Column(name = "ONE_MM_VAL")
	private BigDecimal oneMonthValue;

	@Column(name = "THR_MM_VAL")
	private BigDecimal threeMonthValue;

	@Column(name = "SIX_MM_VAL")
	private BigDecimal sixMonthValue;

	@Column(name = "NINE_MM_VAL")
	private BigDecimal nineMonthValue;

	@Column(name = "ONE_YY_VAL")
	private BigDecimal oneYearValue;

	@Column(name = "THR_YY_VAL")
	private BigDecimal threeYearValue;

	@Column(name = "FV_YY_VAL")
	private BigDecimal fiveYearValue;

	@Column(name = "TEN_YY_VAL")
	private BigDecimal tenYearValue;

	@Column(name = "INCPT_VAL")
	private BigDecimal inceptionValue;
	
	@Column(name = "INCPT_PA_VAL")
	private BigDecimal inceptionPerformanceAdjustedValue;
	
	@Column(name = "YY_TO_DT_VAL")
	private BigDecimal yearToDateValue;
	
	@Column(name = "CURR_YY_TO_DT_VAL")
	private BigDecimal currentYearToDateValue;

	public Long getPerformanceSummaryId() {
		return performanceSummaryId;
	}

	public void setPerformanceSummaryId(Long performanceSummaryId) {
		this.performanceSummaryId = performanceSummaryId;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(String portId) {
		this.portId = portId;
	}

	public Date getEffectiveDate() {
		return SafeCopy.date(effectiveDate);
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = SafeCopy.date(effectiveDate);
	}

	public String getPerformanceTypeName() {
		return performanceTypeName;
	}

	public void setPerformanceTypeName(String performanceTypeName) {
		this.performanceTypeName = performanceTypeName;
	}

	public String getPerformanceTypeCode() {
		return performanceTypeCode;
	}

	public void setPerformanceTypeCode(String performanceTypeCode) {
		this.performanceTypeCode = performanceTypeCode;
	}

	public BigDecimal getOneMonthValue() {
		return null == oneMonthValue ? null : oneMonthValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setOneMonthValue(BigDecimal oneMonthValue) {
		this.oneMonthValue = oneMonthValue;
	}

	public BigDecimal getThreeMonthValue() {
		return null == threeMonthValue ? null : threeMonthValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setThreeMonthValue(BigDecimal threeMonthValue) {
		this.threeMonthValue = threeMonthValue;
	}

	public BigDecimal getSixMonthValue() {
		return null == sixMonthValue ? null : sixMonthValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setSixMonthValue(BigDecimal sixMonthValue) {
		this.sixMonthValue = sixMonthValue;
	}

	public BigDecimal getNineMonthValue() {
		return null == nineMonthValue ? null : nineMonthValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setNineMonthValue(BigDecimal nineMonthValue) {
		this.nineMonthValue = nineMonthValue;
	}

	public BigDecimal getOneYearValue() {
		return null == oneYearValue ? null : oneYearValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setOneYearValue(BigDecimal oneYearValue) {
		this.oneYearValue = oneYearValue;
	}

	public BigDecimal getThreeYearValue() {
		return null == threeYearValue ? null : threeYearValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setThreeYearValue(BigDecimal threeYearValue) {
		this.threeYearValue = threeYearValue;
	}

	public BigDecimal getFiveYearValue() {
		return null == fiveYearValue ? null : fiveYearValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setFiveYearValue(BigDecimal fiveYearValue) {
		this.fiveYearValue = fiveYearValue;
	}

	public BigDecimal getTenYearValue() {
		return null == tenYearValue ? null : tenYearValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setTenYearValue(BigDecimal tenYearValue) {
		this.tenYearValue = tenYearValue;
	}

	public BigDecimal getInceptionValue() {
		return null == inceptionValue ? null : inceptionValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setInceptionValue(BigDecimal inceptionValue) {
		this.inceptionValue = inceptionValue;
	}

	public BigDecimal getYearToDateValue() {
		return null == yearToDateValue ? null : yearToDateValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setYearToDateValue(BigDecimal yearToDateValue) {
		this.yearToDateValue = yearToDateValue;
	}

	public DatasourceFileDAO getDatasourceFileDAO() {
		return datasourceFileDAO;
	}

	public void setDatasourceFileDAO(DatasourceFileDAO datasourceFileDAO) {
		this.datasourceFileDAO = datasourceFileDAO;
	}

	public BigDecimal getInceptionPerformanceAdjustedValue() {
		return null == inceptionPerformanceAdjustedValue? null: inceptionPerformanceAdjustedValue.setScale(2, RoundingMode.HALF_UP);
	}

	public void setInceptionPerformanceAdjustedValue(BigDecimal inceptionPerformanceAdjustedValue) {
		this.inceptionPerformanceAdjustedValue = inceptionPerformanceAdjustedValue;
	}

	public BigDecimal getCurrentYearToDateValue() {
		return currentYearToDateValue;
	}

	public void setCurrentYearToDateValue(BigDecimal currentYearToDateValue) {
		this.currentYearToDateValue = currentYearToDateValue;
	}
}


	ValuationsReport.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/Shared/TargetDataAccess/trunk/src/main/java/com/vanguard/corp/ics/dao/report/ValuationsReportDAO.java $
 $LastChangedRevision: 589324 $
 $Author: uqrc $
 $LastChangedDate: 2017-08-15 10:54:44 -0400 (Tue, 15 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "GMRADM.TPORT_VALUTN_SUM")
public class ValuationsReport extends Auditable {

	private static final long serialVersionUID = 8059542176119580685L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1PORTSUMID")
	@SequenceGenerator(name = "GMRADM.SEQ1PORTSUMID", sequenceName = "GMRADM.SEQ1PORTSUMID", initialValue = 1, allocationSize = 1)
	@Column(name = "PORT_SUM_ID")
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioCode;
	
	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;
	
	@Column(name = "SECTY_TYP_CD", nullable = false)
	private String securityTypeCode;
	
	@Column(name = "VALUTN_VAL")
	private BigDecimal valuationValue;
	
	@Column(name = "VALUTN_PERCENT")
	private BigDecimal valuationPercent;
	
	@Column(name = "TOT_VAL")
	private BigDecimal totalValue;
	
	@ManyToOne
	@JoinColumn(name = "DATA_SRC_FILE_ID")
	private DatasourceFileDAO datasourceFileDAO;
	
	@Column(name = "CREATD_BY_USER_ID", nullable = false)
	private String createdUser;
	
	@Column(name = "CREATD_DT", nullable = false)
	private Date createdDate;
	
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getPortfolioCode() {
		return portfolioCode;
	}

	public void setPortfolioCode(String portfolioCode) {
		this.portfolioCode = portfolioCode;
	}

	public Date getEffectiveDate() {
		return SafeCopy.date(effectiveDate);
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = SafeCopy.date(effectiveDate);
	}

	public String getSecurityTypeCode() {
		return securityTypeCode;
	}

	public void setSecurityTypeCode(String securityTypeCode) {
		this.securityTypeCode = securityTypeCode;
	}

	public BigDecimal getValuationValue() {
		return valuationValue;
	}

	public void setValuationValue(BigDecimal valuationValue) {
		this.valuationValue = valuationValue;
	}

	public BigDecimal getTotalValue() {
		return totalValue;
	}

	public void setTotalValue(BigDecimal totalValue) {
		this.totalValue = totalValue;
	}

	public DatasourceFileDAO getDatasourceFileDAO() {
		return datasourceFileDAO;
	}

	public void setDatasourceFileDAO(DatasourceFileDAO datasourceFileDAO) {
		this.datasourceFileDAO = datasourceFileDAO;
	}
	
	public String getCreatedUser() {
		return createdUser;
	}

	public void setCreatedUser(String createdUser) {
		this.createdUser = createdUser;
	}

	public Date getCreatedDate() {
		return SafeCopy.date(createdDate);
	}

	public void setCreatedDate(Date createdDate) {
		this.createdDate = SafeCopy.date(createdDate);
	}

	public BigDecimal getValuationPercent() {
		return valuationPercent;
	}

	public void setValuationPercent(BigDecimal valuationPercent) {
		this.valuationPercent = valuationPercent;
	}
}


com.vanguard.corp.ics.sdt.dao.impl.entity.target

	BrokerageAndTaxesTargetDAO.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.target;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.PortfolioDAO;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;

@Entity
@Table(name = "SDLTADM.TFND_CHRG")
public class BrokerageAndTaxesTargetDAO implements PortfolioDAO<Long> {
	
	private static final long serialVersionUID = 265023419909974405L;
	
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SDLTADM.SEQ1CHRGID")
	@SequenceGenerator(name = "SDLTADM.SEQ1CHRGID", sequenceName = "SDLTADM.SEQ1CHRGID", initialValue = 1, allocationSize = 1)
	@Column(name = "CHRG_ID", nullable = false)
	private Long id;

	@Column(name = "PORT_CD", nullable = false)
	private String portfolioCode;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date asOfDate;

	@Column(name = "FND_CHRG_TYP_CD", nullable = false)
	private String fundChargeType;

	@Column(name = "FND_CHRG_CURRCY_CD")
	private String fundChargeCurrency;

	@Column(name = "FND_CHRG_FREQ_CD")
	private String fundChargeFrequency;

	@Column(name = "FND_CHRG_AM")
	private BigDecimal fundChargeAmount;

	@Column(name = "EFFTV_BGN_DT", insertable = false)
	private Date effectiveBeginDate;

	@Column(name = "EFFTV_END_DT")
	private Date effectiveEndDate;

	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String updatedUser;

	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;

	public Date getAsOfDate() {
		return SafeCopy.date(asOfDate); // feel free to get rid of all the safe copy stuff when it moves to targetdataaccess
	}

	public Date getEffectiveBeginDate() {
		return SafeCopy.date(effectiveBeginDate);
	}

	public Date getEffectiveEndDate() {
		return SafeCopy.date(effectiveEndDate);
	}

	public BigDecimal getFundChargeAmount() {
		return fundChargeAmount;
	}

	public String getFundChargeCurrency() {
		return fundChargeCurrency;
	}

	public String getFundChargeFrequency() {
		return fundChargeFrequency;
	}

	public String getFundChargeType() {
		return fundChargeType;
	}

	@Override
	public Long getId() {
		return id;
	}

	@Override
	public String getPortfolioCode() {
		return portfolioCode;
	}

	public Date getUpdatedDate() {
		return SafeCopy.date(updatedDate);
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setAsOfDate(Date asOfDate) {
		this.asOfDate = SafeCopy.date(asOfDate);
	}

	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = SafeCopy.date(effectiveBeginDate);
	}

	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = SafeCopy.date(effectiveEndDate);
	}

	public void setFundChargeAmount(BigDecimal fundChargeAmount) {
		this.fundChargeAmount = fundChargeAmount;
	}

	public void setFundChargeCurrency(String fundChargeCurrency) {
		this.fundChargeCurrency = fundChargeCurrency;
	}

	public void setFundChargeFrequency(String fundChargeFrequency) {
		this.fundChargeFrequency = fundChargeFrequency;
	}

	public void setFundChargeType(String fundChargeType) {
		this.fundChargeType = fundChargeType;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	@Override
	public void setPortfolioCode(String portfolioCode) {
		this.portfolioCode = portfolioCode;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = SafeCopy.date(updatedDate);
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}
}


com.vanguard.corp.ics.sdt.dao.impl.portal

	ProductPortalHelper.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.portal;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

@Named
public class ProductPortalHelper {

	private static final Logger LOG = LoggerFactory.getLogger(ProductPortalHelper.class);

	@Inject
	private PortalConfiguration config;
	
	public <T> T getRequest(String url, Class<T> returnClass, HttpServletRequest request) {
		
		Client client = getClient();
		client = client.register(SecureClientRequestFeature.class);
		
		final int maxAttempts = config.getMaxConnectionAttempts();
		for (int i=0; i < maxAttempts; i++) {
			try {
				return client.target(url)
						.request(MediaType.APPLICATION_JSON)
						.property(SecureClientRequestFeature.FORWARD_HTTP_SERVLET_REQUEST, request)
						.accept(MediaType.APPLICATION_JSON)
						.get(returnClass);

			} catch (final Exception e) {
				LOG.error("Error connecting to portal.", e);
				if (i < maxAttempts - 1) {
					LOG.info("Retrying Portal Connection {}/{}", i + 1, maxAttempts);
				} else {
					LOG.error("Error making request to: {}", url);
				}
			}			
		}
		
		return null;
	}

	/**
	 * extracted for testing only
	 * 
	 * @return
	 */
	protected Client getClient() {
		return ClientBuilder.newClient();
	}
}


	ProductPortalServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/SDL/trunk/src/main/java/com/vanguard/corp/ics/helpers/PortalHelper.java $
 $LastChangedRevision: 589895 $
 $Author: uvtc $
 $LastChangedDate: 2017-08-17 01:01:39 -0400 (Thu, 17 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.portal;

import java.util.Arrays;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;

@Named
public class ProductPortalServiceImpl implements ProductPortalService {

	private static final Logger LOG = LoggerFactory.getLogger(ProductPortalServiceImpl.class);

	@Inject
	private PortalConfiguration config;
	
	@Inject
	private ProductPortalHelper productPortalHelper;
	
	public List<PortalProduct> getProducts(HttpServletRequest request) {
		
		LOG.info("Using endpoint: {}", config.getPortalProductEndpoint());
		final String productEndpoint = config.getPortalProductEndpoint();
		final List<PortalProduct> products = Arrays.asList(productPortalHelper.getRequest(productEndpoint, PortalProduct[].class, request));
		return products;
	}

	public PortalProduct getProduct(List<PortalProduct> products, String productCode) {	
		return products.stream().filter(p -> p.getProductCode().equalsIgnoreCase(productCode)).findFirst().get();
	}
	
	public Currency getProductCurrency(PortalProduct product, HttpServletRequest request) {
		
		String currencyEndpoint = config.getPortalReferenceEndpoint()
				+ "/currency/" + product.getBaseCurrencyID();
		
		return productPortalHelper.getRequest(currencyEndpoint, Currency.class, request);
	}

	public InvestmentGroup getInvestmentGroup(PortalProduct product, HttpServletRequest request) {
		
		String investmentGroupEndpoint = config.getPortalReferenceEndpoint()
				+ "/investmentGroup/" + product.getInvestmentGroupID();
		
		return productPortalHelper.getRequest(investmentGroupEndpoint, InvestmentGroup.class, request);
	}

}

com.vanguard.corp.ics.sdt.dao.impl.repository

	AccountBenchmarkAssociationRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;

@Repository("accountBenchmarkAssociationReportRepository")
public interface AccountBenchmarkAssociationRepository extends JpaRepository<AccountBenchmarkAssociation, Long> {
	
	AccountBenchmarkAssociation findByPortfolioIdIs(String portfolioId);
	
	AccountBenchmarkAssociation findByPortfolioIdAndEffectiveEndDateIsNull(String portfolioId);
}


	AccountFundRepository.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/Shared/TargetDataAccess/trunk/src/main/java/com/vanguard/corp/ics/repository/report/AccountFundRepository.java $
 $LastChangedRevision: 590102 $
 $Author: uqrc $
 $LastChangedDate: 2017-08-17 15:31:25 -0400 (Thu, 17 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;

@Repository("accountFundReportRepository")
public interface AccountFundRepository extends JpaRepository<AccountFund, Long> {
	
	AccountFund findByPortfolioIdIs(String portfolioId);
	
	AccountFund findByPortfolioIdAndEffectiveEndDateIsNull(String portfolioId);
}


	AccountSetupRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;

@Repository("accountSetupReportRepository")
public interface AccountSetupRepository extends JpaRepository<AccountSetup, Long> {
	
	AccountSetup findByPortfolioIdIs(String portfolioId);
	
	AccountSetup findByPortfolioIdAndEffectiveEndDateIsNull(String portfolioId);
}


	AttributionSummaryRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;

@Repository("attributionSummaryRepository")
public interface AttributionSummaryRepository extends JpaRepository<AttributionSummary, Long> {
	
	List<AttributionSummary> findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(Date effectiveDate, String portId);
	
}


	BrokerageAndTaxesRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.BrokerageAndTaxes;

public interface BrokerageAndTaxesRepository extends JpaRepository<BrokerageAndTaxes, Long> {
	
	List<BrokerageAndTaxes> findByPortfolioIdIs(String portfolioId);
	
	BrokerageAndTaxes findByAsOfDateAndPortfolioId(Date asOfDate, String portfolioId);
	
	BrokerageAndTaxes findByAsOfDateAndPortfolioIdAndEffectiveEndDateIsNull(Date asOfdate, String portfolioId);
	
}


		BrokerageAndTaxesTargetRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.target.BrokerageAndTaxesTargetDAO;

public interface BrokerageAndTaxesTargetRepository extends JpaRepository<BrokerageAndTaxesTargetDAO, Long> {

	BrokerageAndTaxesTargetDAO findByPortfolioCodeAndAsOfDate(String portfolioId, Date asOfDate);
	
	List<BrokerageAndTaxesTargetDAO> findByAsOfDate(Date asOfDate);
}


	CharacteristicsRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

/**
 * @author UT0T
 *
 */
public interface CharacteristicsRepository extends JpaRepository<Characteristics, Long> {
	
	List<Characteristics> findByEffectiveDate(Date effectiveDate);
	
	List<Characteristics> findByEffectiveDateAndPortId(Date effectiveDate, String portId);

	List<Characteristics> findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(Date effectiveDate, String portId, String type);
}


	CommentaryRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;

@Repository("commentaryRepository")
public interface CommentaryRepository extends JpaRepository<Commentary, Long>{
	
	Commentary findByAsOfDateAndPortId(Date asOfDate, String portfolioId);
}


	PerformanceSummarayRepository.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;

@Repository("performanceSummarayRepository")
public interface PerformanceSummarayRepository extends JpaRepository<PerformanceSummary, Long> {

	List<PerformanceSummary> findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(Date effectiveDate, String portId);
	
}


	PortfolioLimitRepository.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;

public interface PortfolioLimitRepository extends JpaRepository<Limit, Long> {

	Limit findOneById(Long id);
	
	List<Limit> findByPortfolioCodeAndEffectiveEndDateIsNull(String portfolioCode);
}

	ValuationsReportRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/tip/via/PSI/Java/SMA/Shared/TargetDataAccess/trunk/src/main/java/com/vanguard/corp/ics/repository/report/ValuationsReportRepository.java $
 $LastChangedRevision: 589466 $
 $Author: uqrc $
 $LastChangedDate: 2017-08-15 16:17:40 -0400 (Tue, 15 Aug 2017) $
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;

public interface ValuationsReportRepository extends JpaRepository<ValuationsReport, Long> {
	
	ValuationsReport findOneById(Long id);

	ValuationsReport findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(String portfolioCode, String securityTypeCode, Date effectiveDate);
}

com.vanguard.corp.ics.sdt.service.api

	CommentaryService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api;

import java.util.Date;

import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

public interface CommentaryService {

	public CommentaryDTO getCommentary(String portId, Date asOfDate);
	
	public void saveOrUpdateCommentary(CommentaryDTO commentary);
	
}


	DataTransferService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api;

import java.util.Date;

import javax.servlet.http.HttpServletRequest;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;

@FunctionalInterface
public interface DataTransferService {

	void transfer(Date asOfDate, String portId, DataSetType dataSetType, String calledByUserId, HttpServletRequest request);

}


	TransferService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api;

import java.util.Date;

import javax.servlet.http.HttpServletRequest;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;

public interface TransferService {

	boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request);

	void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request);

	TransferService.Priority getPriority();

	public enum Priority {
		HIGHEST
		, HIGH
		, MEDIUM
		, LOW
		, LOWEST
		;
	}
}


	TransferServiceComparator.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api;

import java.util.Comparator;


public class TransferServiceComparator implements Comparator<TransferService> {

	@Override
	public int compare(final TransferService o1, final TransferService o2) {
		return o1.getPriority().ordinal() - o2.getPriority().ordinal();
	}

}


com.vanguard.corp.ics.sdt.service.api.constants

AnalyticsTypeCode.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

public enum AnalyticsTypeCode {

	EX_ANTE_RISK("Ex Ante- Tracking Error", "EATE", true),
	ONE_YR_EX_POST("1 yr Ex-Post Tracking Error", "1YEP", true),
	THREE_YR_EX_POST("3 yr Ex-Post Tracking Error", "3YEP", true),
	ONE_YR_STANDARD_DEV("1 yr Standard Deviation", "1YSD", false),
	THREE_YR_STANDARD_DEV("3 yr Standard Deviation", "3YSD", false);
	
	private final String name;
	private final String code;
	private final boolean limit;
	
	AnalyticsTypeCode(String name, String code, boolean limit) {
		this.name = name;
		this.code = code;
		this.limit = limit;
	}

	public String getName() {
		return name;
	}

	public String getCode() {
		return code;
	}
	
	public boolean hasLimit() {
		return limit;
	}
}

	AttributionSummaryOrderType.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

public enum AttributionSummaryOrderType {
	
		STOCK_SELECTION_IMPACT 			("Stock Selection Impact", 1),
		FUTURES_IMPACT 					("Futures Impact", 2),
		LIQUIDITY_MANAGEMENT_IMPACT		("Liquidity Management Impact", 3),
		SECURITY_PRICE_EXECUTION 		("Security Price Execution", 4),
		TRADING_COST 					("Trading Cost", 5),
		CURRENCY_PRICE_EXECUTION 		("Currency Price Execution", 6),
		DIVIDEND_WITHOLDING_IMPACT 		("Dividend Withholding Impact", 7),
		SECURITY_LENDING_INCOME 		("Security Lending Income", 8),
		MGMT_AND_CUSTODY_FEES 			("Mgmt & Custody Fees", 9),
		SUBSTITUTES_IMPACT 				("Substitutes Impact", 10),
		RESTRICTIONS_IMPACT 			("Restrictions Impact", 11),
		INTERNAL_LIQUIDITY 				("Internal Liquidity", 12),
		RESIDUAL 						("Residual", 13);
		

		private final String attributionName;
		private final int attributionOrder;

		private AttributionSummaryOrderType(final String attributionName, final int attributionOrder) {
			this.attributionName = attributionName;
			this.attributionOrder = attributionOrder;
		}

		public String getAttributionName() {
			return attributionName;
		}

		public int getAttributionOrder() {
			return attributionOrder;
		}

		public static AttributionSummaryOrderType byAttributionName(String attributionName) {
			AttributionSummaryOrderType returnType = null;
			for (AttributionSummaryOrderType type : AttributionSummaryOrderType.values()) {
				if (type.getAttributionName().equals(attributionName)) {
					returnType = type;
					break;
				}
			}
			return returnType;
		}
		
}


	CharacteristicsType.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

public enum CharacteristicsType {

	PORTFOLIO_CHARACTERISTICS	("CHARSTCS", "MarketCharacteristics")
	, COUNTRY_ALLOCATION		("CONALOCN", "CountryAllocation")
	, CURRENCY_ALLOCATION		("CURALOCN", "CurrencyAllocation")
	, MARKET_SEGMENTATION		("MKTSGMNT", "MarketCharacteristics")
	, REGIONAL_ALLOCATION		("REGALOCN", "RegionalAllocation")
	, SECTOR_ALLOCATION			("SECALOCN", "SectorAllocation")
	, TOP_TEN_HOLDINGS			("TOP10HOL", "TopTenHoldings")
	, UNKNOWN					("UNKNOWNN", "")
	;

	private final String reportingCode;
	private final String targetCode;

	private CharacteristicsType(String reportingCode, String targetCode) {
		this.reportingCode = reportingCode;
		this.targetCode = targetCode;
	}

	public String getReportingCode() {
		return reportingCode;
	}

	public String getTargetCode() {
		return targetCode;
	}

	public static CharacteristicsType byReportingCodeOrUnknown(String reportingCode) {
		for (CharacteristicsType type : CharacteristicsType.values()) {
			if (type.getReportingCode().equals(reportingCode)) {
				return type;
			}
		}
		return CharacteristicsType.UNKNOWN;
	}
	
	public static CharacteristicsType byTargetCodeOrUnknown(String targetCode) {
		for (CharacteristicsType type : CharacteristicsType.values()) {
			if (type.getTargetCode().equals(targetCode)) {
				return type;
			}
		}
		return CharacteristicsType.UNKNOWN;
	}
}


	DataSetType.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;


public enum DataSetType {

	CHARACTERISTICS
	, PRODUCT_DATA
	, RISK_SUMMARY
	, VALUATIONS
	, ATTRIBUTION_SUMMARY
	, PERFORMANCE_SUMMARY
	, BROKERAGE_TAXES
	;
}



	MarketSegmentationType.java
package com.vanguard.corp.ics.sdt.service.api.constants;

public enum MarketSegmentationType {

	LARGE			("Large Cap", "Large")
	, MEDIUM_LARGE	("Medium/Large Cap", "Large/Medium")
	, MEDIUM		("Medium Cap", "Medium")
	, MEDIUM_SMALL	("Medium/Small Cap", "Small/Medium")
	, SMALL			("Small Cap", "Small")
	;

	private final String targetName;
	private final String reportingName;

	private MarketSegmentationType(final String targetName, final String reportingName) {
		this.targetName = targetName;
		this.reportingName = reportingName;
	}

	public String getTargetName() {
		return targetName;
	}

	public String getReportingName() {
		return reportingName;
	}

	public static MarketSegmentationType byTargetNameOrNull(String targetName) {
		for (MarketSegmentationType type : MarketSegmentationType.values()) {
			if (type.getTargetName().equals(targetName)) {
				return type;
			}
		}
		return null;
	}
}
	


	PerformanceSummaryCode.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

public enum PerformanceSummaryCode {
	PFT_CODE ("PFT"),
	BMK_CODE ("BMK"),
	DIFF_CODE ("Diff");

	private final String code;

	private PerformanceSummaryCode(String code) {
		this.code = code;
	}

	public String getCode() {
		return code;
	}

}


	PerformanceSummaryName.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

import java.util.Arrays;

public enum PerformanceSummaryName {
	PORTFOLIO_GROSS ("Portfolio (Gross)"),
	BMK_NET ("Bmk (Net)"),
	DIFF ("Diff"),
	BMK_DIV_RETURN ("Bmk (Div Return)"),
	BMK_PRICE_RETURN ("Bmk (Price Return)"),
	PORTFOLIO_NET ("Portfolio (Net)"),
	BMK_GROSS ("Bmk (Gross)");

	private final String name;

	private PerformanceSummaryName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}
	
	public static PerformanceSummaryName of(String value) {
		return Arrays.stream(values()).filter(v ->
        value.equals(v.getName())).findFirst().orElse(null);
	}
	
}


	SecurityTypeCode.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

public enum SecurityTypeCode {

	DERIVATIVES("Derivatives", "DERI"),
	EQUITY("Equity", "EQUI"),
	FUTURES("Futures", "FUTU"),
	FORWARD_FOREX("Forward Forex", "FWFX"),
	LIQUIDITY("Liquidity", "LIQU"),
	FIXED_INTEREST("Securities", "SECU");
	
	private final String name;
	private final String code;
	
	SecurityTypeCode(String name, String code) {
		this.name = name;
		this.code = code;
	}

	public String getName() {
		return name;
	}

	public String getCode() {
		return code;
	}
}


com.vanguard.corp.ics.sdt.service.api.exception

	DataTransferException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;


public class DataTransferException extends RuntimeException {

	private static final long serialVersionUID = 1L;

	public DataTransferException(final String message) {
		super(message);
	}

	public DataTransferException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


	GenerateLimitException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class GenerateLimitException extends DataTransferException {

	private static final long serialVersionUID = 1L;

	public GenerateLimitException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


	ReadAttributeSummaryException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class ReadAttributeSummaryException extends DataTransferException {
	private static final long serialVersionUID = 1L;

	public ReadAttributeSummaryException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


	ReadCharacteristicsException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class ReadCharacteristicsException extends DataTransferException {

	private static final long serialVersionUID = 1L;

	public ReadCharacteristicsException(final String message, final Throwable cause) {
		super(message, cause);
	}

}


	ReadPerformanceSummaryException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class ReadPerformanceSummaryException extends DataTransferException {
	private static final long serialVersionUID = 1L;

	public ReadPerformanceSummaryException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


	ReadProductPortalException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class ReadProductPortalException extends DataTransferException {

	private static final long serialVersionUID = 1L;
	
	public ReadProductPortalException(final String message) {
		super(message);
	}
	
	public ReadProductPortalException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


	ReadValuationsException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class ReadValuationsException extends DataTransferException {

	private static final long serialVersionUID = 1L;
	
	public ReadValuationsException(final String message, final Throwable cause) {
		super(message, cause);
	}

}


		SaveAttributeSummaryException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class SaveAttributeSummaryException extends DataTransferException {
	private static final long serialVersionUID = 1L;

	public SaveAttributeSummaryException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


		SaveCharacteristicsException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class SaveCharacteristicsException extends DataTransferException {

	private static final long serialVersionUID = 1L;

	public SaveCharacteristicsException(final String message, final Throwable cause) {
		super(message, cause);
	}

}


		SavePerformanceSummaryException.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.exception;

public class SavePerformanceSummaryException extends DataTransferException {
	private static final long serialVersionUID = 1L;

	public SavePerformanceSummaryException(final String message, final Throwable cause) {
		super(message, cause);
	}
}


com.vanguard.corp.ics.sdt.service.api.util

	DateParser.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateParser {

	public static final String DATE_FORMAT = "yyyy-MM-dd";

	public Date parse(final String strDate) {
		final SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		
		Date actualDate;
		try {
			actualDate = formatter.parse(strDate);
		}
		catch (ParseException e) {
			throw new DateParserException(String.format("Failed to parse \"%s\"", strDate), e);
		}

		// SimpleDateFormat automatically modifies the date when
		// the date is out of range for the month,
		// e.g. 2017-06-31 becomes 2017-07-01
		//
		// check to make sure that didn't happen here
		int expectedMonth = Integer.parseInt(strDate.substring(5, 7), 10);
		Calendar cal = Calendar.getInstance();
		cal.setTime(actualDate);
		int actualMonth = cal.get(Calendar.MONTH) + 1;
		if (expectedMonth != actualMonth) {
			throw new DateParserException(String.format("Invalid date %s converted to %s", strDate, formatter.format(actualDate)));
		}

		return actualDate;
	}

	public static class DateParserException extends RuntimeException {
		
		private static final long serialVersionUID = 1L;

		public DateParserException(final String msg) {
			super(msg);
		}
		
		public DateParserException(final String msg, final Throwable cause) {
			super(msg, cause);
		}
	}
}


	SafeCopy.java

package com.vanguard.corp.ics.sdt.service.api.util;

import java.util.Date;

public class SafeCopy {

	public static Date date(Date toBeCopied) {
		if (toBeCopied == null) {
			return null;
		}
		
		Date copied = new Date();
		copied.setTime(toBeCopied.getTime());
		return copied;
	}
}


	Utilities.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;

import javax.inject.Named;

import com.vanguard.services.suds.entity.VGUser;
import com.vanguard.services.suds.factory.VGUserFactory;

@Named
public class Utilities {

	// we cannot maintain state in an autowired object
	// lest we encounter threading issues

	public Date getPreviousMonthEnd(Date date) {

		Calendar cal = new GregorianCalendar();
		cal.setTime(date);
		cal.add(Calendar.MONTH, -1);
		cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));

		return cal.getTime();
	}

	// TODO Fix issue where getAuthenticatedUser returns a String instead of a
	// VGUser. May have to do with filter ordering?
	public String getCurrentUsername() {

		return getAuthenticatedUser().getUsername();
	}

	/**
	 * extracted for testing only
	 * 
	 * @return
	 */
	protected VGUser getAuthenticatedUser() {
		return VGUserFactory.getAuthenticatedUser();
	}

	
	public Date generateDateFromString(String dateString, String dateFormat) {

		DateFormat df = new SimpleDateFormat(dateFormat, Locale.ENGLISH);

		Date output = new Date();

		try {
			output = df.parse(dateString);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return output;
	}
}


com.vanguard.corp.ics.sdt.service.impl

		BrokerageAndTaxesServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import org.springframework.transaction.annotation.Transactional;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.BrokerageAndTaxes;
import com.vanguard.corp.ics.sdt.dao.impl.entity.target.BrokerageAndTaxesTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.repository.BrokerageAndTaxesRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.BrokerageAndTaxesTargetRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;

public class BrokerageAndTaxesServiceImpl implements TransferService {

	@Inject
	BrokerageAndTaxesRepository brokerageAndTaxesReportRepo;

	@Inject
	BrokerageAndTaxesTargetRepository brokerageAndTaxesTargetRepo;

	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}

	@Override
	public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.BROKERAGE_TAXES;
	}

	@Transactional
	@Override
	public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) {
		Assert.notNull(asOfDate);
		Assert.hasText(calledByUserId);

		if (StringUtils.isEmpty(portId)) {

			// retrieve all target records by as of date
			List<BrokerageAndTaxesTargetDAO> targetRecordList = brokerageAndTaxesTargetRepo.findByAsOfDate(asOfDate);

			if (CollectionUtils.isNotEmpty(targetRecordList)) {
				for (BrokerageAndTaxesTargetDAO targetRecord : targetRecordList) {
					if (targetRecord != null) {
						saveReportRecord(targetRecord, calledByUserId);
					}
				}
			}

		} else {
			moveFromTargetToReport(portId, asOfDate, calledByUserId);
		}

	}

	private void moveFromTargetToReport(String portfolioId, Date asOfDate, String calledByUserId) {
		BrokerageAndTaxesTargetDAO targetRecord = getTargetRecordByPortIdAndAsOfdate(portfolioId, asOfDate);

		// only save if a record in target table was found
		if (targetRecord != null) {
			saveReportRecord(targetRecord, calledByUserId);
		}
	}

	private BrokerageAndTaxesTargetDAO getTargetRecordByPortIdAndAsOfdate(String portfolioId, Date asOfDate) {
		return brokerageAndTaxesTargetRepo.findByPortfolioCodeAndAsOfDate(portfolioId, asOfDate);
	}

	private void saveReportRecord(BrokerageAndTaxesTargetDAO targetRecord, String calledByUserId) {
		// perform update logic (end date old records if found in report table)
		updateExistingRecord(targetRecord);
		
		BrokerageAndTaxes reportRecord = generateReportRecord(targetRecord, calledByUserId);
		brokerageAndTaxesReportRepo.save(reportRecord);
	}

	/**
	 * Queries report (L1) table if existing record exists, if it does end date
	 * it
	 * 
	 * @param targetRecord
	 */
	private void updateExistingRecord(BrokerageAndTaxesTargetDAO targetRecord) {
		BrokerageAndTaxes existingRecord = brokerageAndTaxesReportRepo
				.findByAsOfDateAndPortfolioIdAndEffectiveEndDateIsNull(targetRecord.getAsOfDate(),
						targetRecord.getPortfolioCode());

		if (existingRecord != null) {
			existingRecord.setEffectiveEndDate(new Date());
		}
	}

	private BrokerageAndTaxes generateReportRecord(BrokerageAndTaxesTargetDAO targetRecord, String calledByUserId) {
		BrokerageAndTaxes output = new BrokerageAndTaxes();

		/*
		 * if charge amount was null in target, charge amount should be null in
		 * report as well
		 */
		BigDecimal roundedValue = null;

		if (targetRecord.getFundChargeAmount() != null) {
			roundedValue = targetRecord.getFundChargeAmount().setScale(0, RoundingMode.HALF_UP);
		}

		output.setPortfolioId(targetRecord.getPortfolioCode());
		output.setAsOfDate(targetRecord.getAsOfDate());
		output.setFundChargeType(targetRecord.getFundChargeType());
		output.setFundChargeCurrency(targetRecord.getFundChargeCurrency());
		output.setFundChargeFrequency(targetRecord.getFundChargeFrequency());
		output.setFundChargeAmount(roundedValue);
		output.setLastUpdatedUserId(calledByUserId);

		return output;
	}

}


		CommentaryServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import java.util.Date;

import javax.inject.Inject;
import javax.inject.Named;

import org.springframework.transaction.annotation.Transactional;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.CommentaryRepository;
import com.vanguard.corp.ics.sdt.service.api.CommentaryService;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

@Named
@Transactional
public class CommentaryServiceImpl implements CommentaryService {

	@Inject
	private CommentaryRepository commentaryRepository;

	private final DateParser dateParser = new DateParser();

	@Override
	public CommentaryDTO getCommentary(String portId, Date asOfDate) {
		
		// find existing commentary record
		Commentary commentaryEntity = commentaryRepository.findByAsOfDateAndPortId(asOfDate, portId);

		//if no commentary found return null
		if(commentaryEntity == null){
			return null;
		}
		
		CommentaryDTO retrievedCommentary = new CommentaryDTO();
		
		retrievedCommentary.setPortId(commentaryEntity.getPortfolioId());
		retrievedCommentary.setAsOfDate(commentaryEntity.getEffectiveDate().toString()); 
		retrievedCommentary.setCommentary(commentaryEntity.getCommentaryText());
		

		return retrievedCommentary;
	}

	@Override
	public void saveOrUpdateCommentary(CommentaryDTO commentary) {
		
		//flag for new commentary in table
		boolean isNewCommentary = false;
		
		// find existing commentary record
		Commentary commentaryEntity = commentaryRepository.findByAsOfDateAndPortId(dateParser.parse(commentary.getAsOfDate()), commentary.getPortId());
		
		if (commentaryEntity == null){
			isNewCommentary = true;
			commentaryEntity = new Commentary();
		}
		
		commentaryEntity.setPortfolioId(commentary.getPortId());
		commentaryEntity.setEffectiveDate(dateParser.parse(commentary.getAsOfDate()));
		commentaryEntity.setCommentaryText(commentary.getCommentary());
		commentaryEntity.setEffectiveBeginDate(new Date());
		
		if(isNewCommentary){
			commentaryRepository.save(commentaryEntity);
		}

	}

}


		DataTransferServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.service.impl;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.collections.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferServiceComparator;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.DataTransferException;

@Named
public class DataTransferServiceImpl implements DataTransferService {

	private static final String DATE_FORMAT = "yyyy-MM-dd";
	private static final String IDENTIFIER = "[DataTransferServiceImpl.transfer]";
	private static final Logger LOGGER = LoggerFactory.getLogger(DataTransferServiceImpl.class);

	@Inject
	private List<TransferService> services;

	@Override
	public void transfer(final Date asOfDate, final String portId, final DataSetType dataSetType, final String calledByUserId, final HttpServletRequest request) {
		Assert.hasText(calledByUserId);
		final SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<Exception> caughtExceptions = new ArrayList<>();
		List<TransferService> exceptionThrownBy = new ArrayList<>();

		Collections.sort(services, new TransferServiceComparator());
		for (TransferService service : services) {
			try {
				LOGGER.info(String.format("%s checking %s; asOfDate:%s, portId:%s, dataSet:%s"
						, IDENTIFIER, service.getClass().getSimpleName()
						, formatter.format(asOfDate), portId, dataSetType));
				
				if (service.handles(asOfDate, portId, dataSetType, request)) {
					service.transfer(asOfDate, portId, calledByUserId, request);
					LOGGER.info(String.format("%s %s completed successfully"
							, IDENTIFIER, service.getClass().getSimpleName()));
				}
			}
			catch (Exception e) {
				caughtExceptions.add(e);
				exceptionThrownBy.add(service);
				
				String msg = String.format("%s %s thrown by %s; msg:%s"
						, IDENTIFIER
						, e.getClass().getSimpleName()
						, service.getClass().getSimpleName()
						, e.getMessage()
						);
				LOGGER.error(msg, e);
			}
		}
		
		if (CollectionUtils.isNotEmpty(caughtExceptions)) {
			final int size = caughtExceptions.size();
			final StringBuilder sb = new StringBuilder()
			.append(IDENTIFIER).append(' ')
			.append(size).append(" exception")
			.append(size == 1 ? "" : "s")
			.append(" thrown while processing request by ")
			.append(calledByUserId).append(" with parameters")
			.append(" asOfDate:").append(formatter.format(asOfDate))
			.append(" portId:").append(portId)
			.append(" dataSet:").append(dataSetType).append("; ")
			;
			
			for (int i = 0; i < size; i++) {
				sb.append(caughtExceptions.get(i).getClass().getSimpleName()).append(" thrown by ")
				.append(exceptionThrownBy.get(i).getClass().getSimpleName()).append("; ");
			}
			
			LOGGER.error(sb.toString());
			throw new DataTransferException(sb.toString());
		}
	}

}
		ProductDataServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadProductPortalException;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;

@Named
public class ProductDataServiceImpl implements TransferService {

	@Inject
	ProductPortalService productPortal;

	@Inject
	Utilities utilities;

	@Inject
	private AccountFundRepository accountFundRepository;

	@Inject
	private AccountSetupRepository accountSetupRepository;

	@Inject
	private AccountBenchmarkAssociationRepository accountBenchmarkAssociationRepository;

	@Override
	public Priority getPriority() {
		return TransferService.Priority.HIGHEST;
	}

	@Override
	public boolean handles(final Date asOfDate, final String portId, final DataSetType dataSetType,
			final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.PRODUCT_DATA;
	}

	@Override
	public void transfer(final Date asOfDate, final String portId, final String calledByUserId, final HttpServletRequest request) {
		Assert.hasText(calledByUserId, "[ProductDataServiceImpl.transfer] calledByUserId is required");
		
	    final SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
	    List<PortalProduct> products;
	    try {
	        products = productPortal.getProducts(request);
	    }
	    catch (Exception e) {
	        final String msg = String.format("[ProductDataServiceImpl.transfer] asOfDate:%s portId:%s threw %s; msg:%s",
	                f.format(asOfDate), portId, e.getClass().getSimpleName(), e.getMessage());
	        throw new ReadProductPortalException(msg, e);
	    }
	    
	    if (CollectionUtils.isNotEmpty(products)) {
	        transferProductData(products, portId, request, calledByUserId);
	    }
	    else {
	        final String msg = "[ProductDataServiceImpl.transfer] No products retrieved.";
	        throw new ReadProductPortalException(msg);
	    }
	}
	
	private void transferProductData(List<PortalProduct> products, final String portId, final HttpServletRequest request, String calledByUserId) {
	    Assert.notEmpty(products);
	    
	    if (StringUtils.isEmpty(portId)) {
	        for (PortalProduct product : products) {
	            moveProductPortalDataToReport(product, request, calledByUserId);
	        }
	    }
	    else {
	        PortalProduct portProduct = productPortal.getProduct(products, portId);
	        moveProductPortalDataToReport(portProduct, request, calledByUserId);
	    }
	}
	
	public void moveProductPortalDataToReport(PortalProduct product, HttpServletRequest request, String calledByUserId) {
		
		if(product != null) {
			// TODO How should we handle currency IDs that don't Exist in PWS?
			// Right now they only have 3 currencies.
			if (!(product.getBaseCurrencyID() == 1 || product.getBaseCurrencyID() == 2
					|| product.getBaseCurrencyID() == 3)) {
				Currency currency = new Currency();
				currency.setCurrencyCode("N/A");
				product.setCurrency(currency);
			} else {
				product.setCurrency(productPortal.getProductCurrency(product, request));
			}

			product.setInvestmentGroup(productPortal.getInvestmentGroup(product, request));

			AccountFund accountFundRecord = generateAccountFundRecord(product, calledByUserId);
			accountFundRepository.save(accountFundRecord);
				
			AccountSetup accountSetupRecord = generateAccountSetupRecord(product, calledByUserId);
			accountSetupRepository.save(accountSetupRecord);
				
			AccountBenchmarkAssociation accountBenchmarkAssociationRecord = generateAccountBenchmarkAssociationRecord(product, calledByUserId);
			accountBenchmarkAssociationRepository.save(accountBenchmarkAssociationRecord);

		} else {
			final String msg = "[ProductDataServiceImpl.transfer] Product Portal is feeding null data.";
			throw new ReadProductPortalException(msg);
		}
	}
	
	private AccountFund generateAccountFundRecord(PortalProduct product, String calledByUserId) {

		AccountFund output = new AccountFund();

		// get record by portId
		AccountFund existingFundRecord = accountFundRepository
				.findByPortfolioIdAndEffectiveEndDateIsNull(product.getProductCode());

		if (existingFundRecord != null) {
			// set end date on existing record
			existingFundRecord.setEffectiveEndDate(new Date());
		}

		output.setPortfolioId(product.getProductCode());
		output.setAccountName(product.getProductName());
		output.setPortfolioManagerId(product.getInvestmentGroupID());
		output.setPortfolioBaseCurrency(product.getCurrency().getCurrencyCode());

		Assert.notNull(product.getInvestmentGroup(), "Investment group is null for Port ID:"+product.getProductCode());
		output.setPortfolioManager(product.getInvestmentGroup().getInvestmentGroupName());

		// TODO How should we handle products with no PerfInceptionDate?
		if (product.getPerfInceptionDate() != null && !product.getPerfInceptionDate().isEmpty()) {
			output.setInceptionDate(utilities.generateDateFromString(product.getPerfInceptionDate(),
					RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT));
		} else {
			output.setInceptionDate(new Date());
		}

		output.setInvestmentObjective(product.getInvestmentObjective());
		output.setLastUpdatedUserId(calledByUserId);

		// TODO Below are not in one of Cognos Sections. These fields cannot be
		// null in the database.
		output.setAccountType("TEST");
		output.setAssetClassificationId(Long.valueOf(3));

		return output;
	}
	
	private AccountSetup generateAccountSetupRecord(PortalProduct product, String calledByUserId) {

		AccountSetup output = new AccountSetup();

		// get record by portId
		AccountSetup existingAccountSetupRecord = accountSetupRepository
				.findByPortfolioIdAndEffectiveEndDateIsNull(product.getProductCode());

		if (existingAccountSetupRecord != null) {
			// set end date on existing record
			existingAccountSetupRecord.setEffectiveEndDate(new Date());
		}

		output.setPortfolioId(product.getProductCode());
		output.setAccountClientName(product.getClientID());
		output.setLastUpdatedUserId(calledByUserId);

		// TODO Below is not in one of Cognos Sections. This field cannot be
		// null in the database.
		output.setStatusCode("ACTIVE");

		return output;
	}
	
	private AccountBenchmarkAssociation generateAccountBenchmarkAssociationRecord(PortalProduct product, String calledByUserId) {

		AccountBenchmarkAssociation output = new AccountBenchmarkAssociation();

		// get record by portId
		AccountBenchmarkAssociation existingAccountBenchmarkAssociationRecord = accountBenchmarkAssociationRepository
				.findByPortfolioIdAndEffectiveEndDateIsNull(product.getProductCode());

		if (existingAccountBenchmarkAssociationRecord != null) {
			// set end date on existing record
			existingAccountBenchmarkAssociationRecord.setEffectiveEndDate(new Date());
		}

		output.setPortfolioId(product.getProductCode());
		output.setBenchmarkName(product.getBenchMarkName());
		output.setLastUpdatedUserId(calledByUserId);
		
		return output;
	}

}

	ValuationsServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.repository.target.ValuationsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;
import com.vanguard.corp.ics.sdt.dao.impl.repository.ValuationsReportRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.constants.SecurityTypeCode;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadValuationsException;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.dao.target.ValuationsTargetDAO;

@Named
public class ValuationsServiceImpl implements TransferService {
	
	@Inject 
	Utilities utilities;

	@Inject
	private ValuationsRepository valuationsTargetRepository;
	
	@Inject
	private ValuationsReportRepository valuationsReportRepository;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}
	
	@Override
	public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.VALUATIONS;
	}
	
	@Override
	@Transactional
	public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) {
		Assert.notNull(asOfDate, "[ValuationsServciceImpl.transfer] asOfDate cannot be null");
		Assert.hasText(calledByUserId, "[ValuationsServiceImpl.transfer] calledByUserId is required");
		
		List<String> portIds = valuationsTargetRepository.findPortIdByDate(asOfDate);
		if (StringUtils.isEmpty(portId)) {	
			for (String portfolioId : portIds) {
				moveValuationsFromTargetToReport(portfolioId, asOfDate, calledByUserId);
			}
		}
		else {
			moveValuationsFromTargetToReport(portId, asOfDate, calledByUserId);
		}
	}

	public void moveValuationsFromTargetToReport(String portfolioId, Date valuationDate, String calledByUserId) {
		ValuationsTargetDAO currentValuationTarget = getValuationTargetRecord(portfolioId, valuationDate);
		
		saveReportRecords(currentValuationTarget, calledByUserId);
	}
	
	public ValuationsTargetDAO getValuationTargetRecord(String portfolioId, Date valuationDate) {

		final SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
		try{
		ValuationsTargetDAO targetRecord = valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valuationDate, portfolioId);
		
		return targetRecord;
		
		}catch(Exception e){
			final String msg = String.format(
					"[ValuationsServiceImpl.transfer] The target record for Date %s and Port ID %s does not exist."
					, f.format(valuationDate), portfolioId
					, e.getClass().getSimpleName(), e.getMessage());
			throw new ReadValuationsException(msg, e);
		}
		
		
	}
	
	private void saveReportRecords(ValuationsTargetDAO targetRecord, String calledByUserId){
		List<ValuationsReport> targetRecords = generateValuationReportRecords(targetRecord, calledByUserId);
			
		for(ValuationsReport valutionReportRecord: targetRecords) {
			valuationsReportRepository.save(valutionReportRecord);
		}
			
		
	}

	public List<ValuationsReport> generateValuationReportRecords(ValuationsTargetDAO valuationTarget, String calledByUserId) {
		
		List<ValuationsReport> output = new ArrayList<ValuationsReport>();
		
		for (SecurityTypeCode value : SecurityTypeCode.values()) {
			
			ValuationsReport valuationReport = new ValuationsReport();
			
			ValuationsReport existingValuationReport = 
					valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(
							valuationTarget.getPortfolioCode(), value.getCode(), valuationTarget.getValueDate());
			
			if(existingValuationReport != null){
				existingValuationReport.setEffectiveEndDate(new Date());
			}

			
			// UQRC: LST_UPDTD_TS isn't triggered on GMRADM.TPORT_VALUTN_SUM
			valuationReport.setCreatedUser(calledByUserId);
			valuationReport.setCreatedDate(valuationTarget.getCreatedDate());
			valuationReport.setPortfolioCode(valuationTarget.getPortfolioCode());
			valuationReport.setEffectiveDate(valuationTarget.getValueDate());
			valuationReport.setTotalValue(valuationTarget.getTotalValue());
			valuationReport.setDatasourceFileDAO(valuationTarget.getDatasourceFileDAO());
			valuationReport.setLastUpdatedUserId(calledByUserId);
			valuationReport.setEffectiveBeginDate(new Date());

			switch (value) {
				case DERIVATIVES :	
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getDerivitivesValue());
					output.add(valuationReport);
					
					break;
				case EQUITY :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getEquityValue());
					output.add(valuationReport);
					
					break;
				case FUTURES :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getFuturesValue());
					output.add(valuationReport);
					
					break;
				case FORWARD_FOREX :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getForwardForiegnExchangeValue());
					output.add(valuationReport);
					
					break;
				case LIQUIDITY :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getLiquidityValue());
					output.add(valuationReport);
					
					break;
				default :
					Assert.isTrue(value.getCode().equals("SECU"));
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getFixedInterestValue());
					output.add(valuationReport);
					
			}

		}

		return output;
	}
}

com.vanguard.corp.ics.sdt.service.impl.attributionsummary

	AttributionSummaryConverter.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.attributionsummary;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.inject.Named;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.service.api.constants.AttributionSummaryOrderType;


@Named
public class AttributionSummaryConverter {
	
	private static final Logger LOG = LoggerFactory.getLogger(AttributionSummaryConverter.class);

	public List<AttributionSummary> convert(final List<AttributionTargetDAO> attributionTargetDAOs, final String calledByUserId) {
		Assert.notEmpty(attributionTargetDAOs);
		Assert.noNullElements(attributionTargetDAOs.toArray());
		Assert.hasText(calledByUserId);
		final List<AttributionSummary> converted = new ArrayList<>(attributionTargetDAOs.size());
		Map<String, AttributionSummary> attributionSummaryMap = new HashMap<String, AttributionSummary>();
		AttributionSummary attributionSummary;

		for (AttributionTargetDAO targetDao : attributionTargetDAOs) {
			String key = targetDao.getPortfolioCode() + "_"
					+ targetDao.getAttrtnName();
			if (attributionSummaryMap.containsKey(key)) {
				attributionSummary = attributionSummaryMap.get(key);
			} else {
				attributionSummary = new AttributionSummary();
				attributionSummary.setEffectiveDate(targetDao.getEffectiveDate());
				attributionSummary.setPortId(targetDao.getPortfolioCode());
				attributionSummary.setName(targetDao.getAttrtnName());
				attributionSummary.setLastUpdatedUserId(calledByUserId);
				if (null != targetDao.getDatasourceFileDAO()) {
					attributionSummary.setDatasourceFileDAO(targetDao.getDatasourceFileDAO());
					
				}
				AttributionSummaryOrderType displayOrder = getDisplayOrder(targetDao.getAttrtnName());
				if( displayOrder !=null){
					attributionSummary.setDisplayOrder(displayOrder.getAttributionOrder());
				}
				else {
					attributionSummary.setDisplayOrder(99);
				}
				
				attributionSummaryMap.put(key, attributionSummary);
			}

			getAttributionTypeCodeValues(attributionSummary, targetDao);

		}

		// Iterate Map to prepare converted list
		for (AttributionSummary attSummary : attributionSummaryMap.values()) {
			converted.add(attSummary);
		}
		return converted;
	}

	private void getAttributionTypeCodeValues(AttributionSummary attributionSummary, AttributionTargetDAO targetDao) {

		if (("1MON").equalsIgnoreCase(targetDao.getAttrtnTypeCd())) {
			attributionSummary.setOneMonthVal(targetDao.getAttrtnTypeVal());
		}

		else if (("3MON").equalsIgnoreCase(targetDao.getAttrtnTypeCd())) {
			attributionSummary.setThreeMonthVal(targetDao.getAttrtnTypeVal());

		}

		else if (("6MON").equalsIgnoreCase(targetDao.getAttrtnTypeCd())) {
			attributionSummary.setSixMonthVal(targetDao.getAttrtnTypeVal());

		}

		else if (("9MON").equalsIgnoreCase(targetDao.getAttrtnTypeCd())) {
			attributionSummary.setNineMonthVal(targetDao.getAttrtnTypeVal());

		}

		else if (("12MO").equalsIgnoreCase(targetDao.getAttrtnTypeCd())) {
			attributionSummary.setTwelveMonthVal(targetDao.getAttrtnTypeVal());

		}

		else if (("CYTD").equalsIgnoreCase(targetDao.getAttrtnTypeCd())) {
			attributionSummary.setYearToDateVal(targetDao.getAttrtnTypeVal());

		}
		
		else {
			LOG.warn("[AttributionSummaryConverter.getAttributionTypeCodeValues] AttributionTypeCodeValues does not match the expected values.targetDao.getAttrtnTypeCd():{},targetDao.getPortfolioCode():{} ", targetDao.getAttrtnTypeCd(), targetDao.getPortfolioCode());
		}
	}

	private AttributionSummaryOrderType getDisplayOrder(String attributionName) {
		return AttributionSummaryOrderType.byAttributionName(attributionName);
	}

}


		AttributionSummaryTransferService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.attributionsummary;

import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.repository.target.AttributionSummaryTargetRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AttributionSummaryRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadAttributeSummaryException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveAttributeSummaryException;

@Named
public class AttributionSummaryTransferService implements TransferService {

	@Inject
	private AttributionSummaryRepository repo;

	@Inject
	private AttributionSummaryTargetRepository readRepo;
	
	@Inject AttributionSummaryConverter dataConverter;

	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}

	@Override
	public boolean handles(final Date effectiveDate, final String portId, final DataSetType dataSetType,
			final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.ATTRIBUTION_SUMMARY;
	}

	@Override
	@Transactional
	public void transfer(final Date effectiveDate, final String portId, final String calledByUserId, final HttpServletRequest request) {

		Assert.notNull(effectiveDate, "[AttributionSummaryTransferService.transfer] effectiveDate cannot be null");
		Assert.hasText(calledByUserId, "[AttributionSummaryTransferService.transfer] calledByUserId is required");

		List<AttributionTargetDAO> targetData = readAttributionSummary(effectiveDate, portId);

		if (CollectionUtils.isNotEmpty(targetData)) {
			saveAttributionSummary(targetData, effectiveDate, portId, calledByUserId);
		}
	}
	
	/**
	 * Retrieves L2 Data  
	 * @param effectiveDate
	 * @param portId
	 * @return
	 */
	private List<AttributionTargetDAO> readAttributionSummary(final Date effectiveDate, final String portId) {
		List<AttributionTargetDAO> readList;
		try {
			if (StringUtils.isEmpty(portId)) {
				readList = readRepo.findAllByEffectiveDate(effectiveDate);
			} else {
				readList = readRepo.findAllByEffectiveDateAndPortfolioCode(effectiveDate, portId);
			}
		} catch (Exception e) {
			final String msg = String.format(
					"[AttributionSummaryTransferService.transfer] %s thrown while reading attribution summary; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new ReadAttributeSummaryException(msg, e);
		}

		return readList;
	}
	
	/**
	 * 1. L2 data is converted to L2 data structure.
	 * 2. Existing L3 data is end dated.
	 * 3. L3 data is persisted into DB 
	 * @param readList
	 */

	private void saveAttributionSummary(List<AttributionTargetDAO> readList, final Date effectiveDate,
			final String portId,final String calledByUserId) {


		try {
			// Convert
			final List<AttributionSummary> attributionSummaries = dataConverter.convert(readList, calledByUserId);

			// Update existing records
			updateExistingData(effectiveDate, portId);

			// insert new records
			repo.save(attributionSummaries);

		} catch (Exception e) {
			final String msg = String.format(
				"[AttributionSummaryTransferService.transfer] %s thrown while saving Attribution; msg:%s"
				, e.getClass().getSimpleName()
				, e.getMessage()
				);
			throw new SaveAttributeSummaryException(msg, e);
		}
	}
	

	/**
	 * Existing L3 data is end dated.
	 * @param effectiveDate
	 * @param portId
	 */
	private void updateExistingData(final Date effectiveDate, final String portId) {
		List<AttributionSummary> storedAttributionSummary = repo.findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(effectiveDate, portId);
		for (AttributionSummary attributionSummary : storedAttributionSummary) {
			attributionSummary.setEffectiveEndDate(new Date());
		}
	}

}


com.vanguard.corp.ics.sdt.service.impl.characteristics

	CharacteristicsConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.EnumSet;
import java.util.Set;

import javax.inject.Named;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.constants.MarketSegmentationType;

@FunctionalInterface
public interface CharacteristicsConverter {

	Characteristics convert(FactsetMonthlyCharacteristicsTargetDAO targetCharacteristics, String calledByUserId);

	@Named
	public class Impl implements CharacteristicsConverter {
		
		public static final int ROUNDING_PRECISION = 1;

		@Override
		public Characteristics convert(FactsetMonthlyCharacteristicsTargetDAO targetCharacteristics, String calledByUserId) {
			Assert.notNull(targetCharacteristics);
			Assert.hasText(calledByUserId);
			Characteristics c = new Characteristics();
			
			c.setEffectiveDate(targetCharacteristics.getFactsetEffectiveDate());
			c.setPortId(targetCharacteristics.getPortfolioCode());
			c.setType(determineCharacteristicsType(targetCharacteristics.getCharacteristicsType(), targetCharacteristics.getCharacteristicsName()));
			c.setName(determineName(targetCharacteristics.getCharacteristicsName(), c.getType()));
			c.setPortfolio(round(targetCharacteristics.getPortfolioValue()));
			c.setBenchmark(round(targetCharacteristics.getBenchMarkValue()));
			c.setLastUpdatedUserId(calledByUserId);
			
			return c;
		}

		private String determineCharacteristicsType(String targetCode, String targetName) {
			Set<CharacteristicsType> special = EnumSet.of(CharacteristicsType.PORTFOLIO_CHARACTERISTICS, CharacteristicsType.MARKET_SEGMENTATION);
			CharacteristicsType type = CharacteristicsType.byTargetCodeOrUnknown(targetCode);
			
			if (special.contains(type)) {
				MarketSegmentationType msType = MarketSegmentationType.byTargetNameOrNull(targetName);
				
				if (msType == null) {
					type = CharacteristicsType.PORTFOLIO_CHARACTERISTICS;
				}
				else {
					type = CharacteristicsType.MARKET_SEGMENTATION;
				}
			}
			
			return type.getReportingCode();
		}

		private String determineName(String targetName, String reportingTypeCode) {
			CharacteristicsType type = CharacteristicsType.byReportingCodeOrUnknown(reportingTypeCode);
			
			if (type == CharacteristicsType.MARKET_SEGMENTATION) {
				MarketSegmentationType msType = MarketSegmentationType.byTargetNameOrNull(targetName);
				Assert.notNull(msType, String.format("To get MARKET_SEGMENTATION, \"%s\" must be in MarketSegmentationType.  Apparently something went wrong.", targetName));
				
				return msType.getReportingName();
			}
			
			return targetName;
		}

		private BigDecimal round(BigDecimal value) {
			if (value == null) {
				return null;
			}
			
			return value.setScale(ROUNDING_PRECISION, RoundingMode.HALF_UP);
		}
	}
}

	CharacteristicsHelperService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.inject.Inject;
import javax.inject.Named;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.dao.impl.repository.CharacteristicsRepository;

public interface CharacteristicsHelperService {

	List<Characteristics> retrieveAll(Date asOfDate);

	List<Characteristics> retrieveAll(Date asOfDate, String portId);

	void logicalDelete(Date asOfDate, String portId, String characteristicsType);

	List<Characteristics> saveAll(List<Characteristics> saveList);

	@Named
	public static class Impl implements CharacteristicsHelperService {

		@Inject
		private CharacteristicsRepository repo;

		@Override
		public List<Characteristics> retrieveAll(final Date asOfDate) {
			return repo.findByEffectiveDate(asOfDate);
		}

		@Override
		public List<Characteristics> retrieveAll(final Date asOfDate, final String portId) {
			return repo.findByEffectiveDateAndPortId(asOfDate, portId);
		}

		@Override
		public void logicalDelete(final Date asOfDate, final String portId, final String characteristicsType) {

			List<Characteristics> storedCharacteristics = repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, portId, characteristicsType);
			for (Characteristics characteristics : storedCharacteristics) {
				characteristics.setEffectiveEndDate(new Date());
			}
		}

		@Override
		public List<Characteristics> saveAll(final List<Characteristics> saveList) {
			if (saveList.isEmpty()) {
				return saveList;
			}

			logicalDeleteBeforeSaving(saveList);
			return repo.save(saveList);
		}

		private void logicalDeleteBeforeSaving(final List<Characteristics> saveList) {
			Set<DeleteCombo> toBeDeleted = new HashSet<>();

			for (Characteristics characteristics : saveList) {
				toBeDeleted.add(new DeleteCombo(characteristics.getPortId(), characteristics.getType()));
			}

			Date asOfDate = saveList.get(0).getEffectiveDate();
			Iterator<DeleteCombo> iterator = toBeDeleted.iterator();
			while (iterator.hasNext()) {
				DeleteCombo deleteMe = iterator.next();
				logicalDelete(asOfDate, deleteMe.portId, deleteMe.type);
			}
		}

	}

	public static class DeleteCombo {

		final String portId;
		final String type;

		DeleteCombo(final String portId, final String type) {
			Assert.notNull(portId);
			Assert.notNull(type);
			this.portId = portId;
			this.type = type;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (!(obj instanceof CharacteristicsHelperService.DeleteCombo)) {
				return false;
			}
			DeleteCombo that = (DeleteCombo) obj;
			return this.portId.equals(that.portId) && this.type.equals(that.type);
		}

		@Override
		public int hashCode() {
			int hash = 17;
			hash = hash * 31 + this.portId.hashCode();
			hash = hash * 31 + this.type.hashCode();
			return hash;
		}
	}
}

	CharacteristicsRounder.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.List;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

public interface CharacteristicsRounder {

	boolean handles(String characteristicsTypeCode);

	List<Characteristics> round(List<Characteristics> toBeRounded);

	public abstract static class BaseClass implements CharacteristicsRounder {
		
		protected CharacteristicsType getType(String reportingTypeCode) {
			return CharacteristicsType.byReportingCodeOrUnknown(reportingTypeCode);
		}
	}
}


CharacteristicsTransferService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;

@Named
public class CharacteristicsTransferService implements TransferService {

	private static final Logger LOG = LoggerFactory.getLogger(CharacteristicsTransferService.class);

	@Inject
	private FactsetMonthlyCharacteristicsRepository readRepo;

	@Inject
	private CharacteristicsConverter converter;

	@Inject
	private List<CharacteristicsRounder> rounders;

	@Inject
	private CharacteristicsHelperService writeRepo;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}

	@Override
	public boolean handles(final Date asOfDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.CHARACTERISTICS;
	}

	@Override
	@Transactional
	public void transfer(final Date asOfDate, final String portId, final String calledByUserId, final HttpServletRequest request) {

		Assert.notNull(asOfDate, "[CharacteristicsTransferService.transfer] asOfDate cannot be null");
		Assert.hasText(calledByUserId, "[CharacteristicsTransferService.transfer] calledByUserId is required");

		List<FactsetMonthlyCharacteristicsTargetDAO> readList = readCharacteristics(asOfDate, portId);
		if (CollectionUtils.isNotEmpty(readList)) {
			Map<String, Map<String, List<Characteristics>>> converted = convertCharacteristics(readList, calledByUserId);
			List<Characteristics> rounded = magicRoundCharacteristics(converted);
			saveCharacteristics(rounded);
		}
		else {
			final SimpleDateFormat formatter = new SimpleDateFormat(DateParser.DATE_FORMAT);
			LOG.warn("[CharacteristicsTransferService.transfer] characteristics read list is null/empty for asOfDate:{}, portId:{}", formatter.format(asOfDate), portId);
		}
	}

	private List<FactsetMonthlyCharacteristicsTargetDAO> readCharacteristics(final Date asOfDate, final String portId) {
		List<FactsetMonthlyCharacteristicsTargetDAO> readList;
		try {
			if (StringUtils.isEmpty(portId)) {
				readList = readRepo.findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate);
			}
			else {
				readList = readRepo.findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId);
			}
		}
		catch (Exception e) {
			final String msg = String.format(
					"[CharacteristicsTransferService.transfer] %s thrown while reading characteristics; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new ReadCharacteristicsException(msg, e);
		}
		
		return readList;
	}

	private Map<String, Map<String, List<Characteristics>>> convertCharacteristics(List<FactsetMonthlyCharacteristicsTargetDAO> readList, String calledByUserId) {
		Map<String, Map<String, List<Characteristics>>> convertedMap = new HashMap<>();
		
		Map<String, List<Characteristics>> characteristicsForPortId;
		List<Characteristics> characteristicsOfType;
		Characteristics c;
		for (FactsetMonthlyCharacteristicsTargetDAO dao : readList) {
			c = converter.convert(dao, calledByUserId);
			
			characteristicsForPortId = convertedMap.get(c.getPortId());
			if (characteristicsForPortId == null) {
				characteristicsForPortId = new HashMap<>();
				convertedMap.put(c.getPortId(), characteristicsForPortId);
			}
			
			characteristicsOfType = characteristicsForPortId.get(c.getType());
			if (characteristicsOfType == null) {
				characteristicsOfType = new ArrayList<>();
				characteristicsForPortId.put(c.getType(), characteristicsOfType);
			}
			
			characteristicsOfType.add(c);
		}
		
		return convertedMap;
	}

	private List<Characteristics> magicRoundCharacteristics(Map<String, Map<String, List<Characteristics>>> converted) {
		List<Characteristics> rounded = new ArrayList<>();
		
		for (Entry<String, Map<String, List<Characteristics>>> characteristicsByPortId : converted.entrySet()) {
			for (Entry<String, List<Characteristics>> characteristicsByType : characteristicsByPortId.getValue().entrySet()) {
				rounded.addAll(identifyAndApplyAppropriateRounder(characteristicsByType.getKey(), characteristicsByType.getValue()));
			}
		}
		
		return rounded;
	}

	private List<Characteristics> identifyAndApplyAppropriateRounder(String type, List<Characteristics> characteristics) {
		List<Characteristics> afterRounding = new ArrayList<>();
		
		for (CharacteristicsRounder rounder : rounders) {
			if (rounder.handles(type)) {
				afterRounding.addAll(rounder.round(characteristics));
			}
		}
		
		return afterRounding;
	}

	private void saveCharacteristics(List<Characteristics> rounded) {
		try {
			writeRepo.saveAll(rounded);
		}
		catch (Exception e) {
			final String msg = String.format(
					"[CharacteristicsTransferService.transfer] %s thrown while saving characteristics; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new SaveCharacteristicsException(msg, e);
		}
	}
}


		MagicRounder.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.math.BigDecimal;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;

import javax.inject.Named;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class MagicRounder extends CharacteristicsRounder.BaseClass {

	private static final BigDecimal ONE_HUNDRED = new BigDecimal("100.0");

	@Override
	public boolean handles(String characteristicsTypeCode) {
		Set<CharacteristicsType> magic = EnumSet.of(
				CharacteristicsType.COUNTRY_ALLOCATION
				, CharacteristicsType.CURRENCY_ALLOCATION
				, CharacteristicsType.MARKET_SEGMENTATION
				, CharacteristicsType.REGIONAL_ALLOCATION
				, CharacteristicsType.SECTOR_ALLOCATION
				);
		
		return magic.contains(getType(characteristicsTypeCode));
	}

	@Override
	public List<Characteristics> round(List<Characteristics> toBeRounded) {
		Assert.notEmpty(toBeRounded);
		Assert.noNullElements(toBeRounded.toArray());
		
		Characteristics maxPortfolioOb = toBeRounded.get(0);
		Characteristics maxBenchmarkOb = toBeRounded.get(0);
		BigDecimal maxPortfolioValue = maxPortfolioOb.getPortfolio();
		BigDecimal maxBenchmarkValue = maxBenchmarkOb.getBenchmark();
		BigDecimal totalPortfolioValue = new BigDecimal("0.0");
		BigDecimal totalBenchmarkValue = new BigDecimal("0.0");
		BigDecimal portfolioValue;
		BigDecimal benchmarkValue;
		boolean foundNullPortfolio = false;
		boolean foundNullBenchmark = false;

		for (Characteristics ch : toBeRounded) {
			portfolioValue = ch.getPortfolio();
			if (portfolioValue == null) {
				foundNullPortfolio = true;
			}
			else {
				totalPortfolioValue = totalPortfolioValue.add(portfolioValue);
				
				if (portfolioValue.compareTo(maxPortfolioValue) > 0) {
					maxPortfolioValue = portfolioValue;
					maxPortfolioOb = ch;
				}
			}
			
			benchmarkValue = ch.getBenchmark();
			if (benchmarkValue == null) {
				foundNullBenchmark = true;
			}
			else {
				totalBenchmarkValue = totalBenchmarkValue.add(benchmarkValue);
				
				if (benchmarkValue.compareTo(maxBenchmarkValue) > 0) {
					maxBenchmarkValue = benchmarkValue;
					maxBenchmarkOb = ch;
				}
			}
		}
		
		if (!foundNullPortfolio) {
			BigDecimal diffPortfolio = ONE_HUNDRED.subtract(totalPortfolioValue);
			if (diffPortfolio.compareTo(BigDecimal.ZERO) != 0) {
				maxPortfolioOb.setPortfolio(maxPortfolioOb.getPortfolio().add(diffPortfolio));
			}
		}
		
		if (!foundNullBenchmark) {
			BigDecimal diffBenchmark = ONE_HUNDRED.subtract(totalBenchmarkValue);
			if (diffBenchmark.compareTo(BigDecimal.ZERO) != 0) {
				maxBenchmarkOb.setBenchmark(maxBenchmarkOb.getBenchmark().add(diffBenchmark));
			}
		}

		return toBeRounded;
	}

}


		MundaneRounder.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.EnumSet;
import java.util.List;
import java.util.Set;

import javax.inject.Named;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class MundaneRounder extends CharacteristicsRounder.BaseClass {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		Set<CharacteristicsType> mundane = EnumSet.of(
				CharacteristicsType.PORTFOLIO_CHARACTERISTICS
				, CharacteristicsType.UNKNOWN
				);
		
		return mundane.contains(getType(characteristicsTypeCode));
	}

	@Override
	public List<Characteristics> round(List<Characteristics> toBeRounded) {
		Assert.notNull(toBeRounded);
		
		return toBeRounded;
	}

}


		TopTenHoldingsRounder.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.List;

import javax.inject.Named;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class TopTenHoldingsRounder extends CharacteristicsRounder.BaseClass {

	private static final int MAGIC_ROUNDING_MAX_COUNT = 9;

	private MagicRounder magicRounder = new MagicRounder();
	private MundaneRounder mundaneRounder = new MundaneRounder();

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.TOP_TEN_HOLDINGS == getType(characteristicsTypeCode);
	}

	@Override
	public List<Characteristics> round(List<Characteristics> toBeRounded) {
		Assert.notNull(toBeRounded);
		
		if (toBeRounded.size() > MAGIC_ROUNDING_MAX_COUNT) {
			return mundaneRounder.round(toBeRounded);
		}
		
		return magicRounder.round(toBeRounded);
	}

}


com.vanguard.corp.ics.sdt.service.impl.performancesummary

	PerformanceSummaryDataConverter.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.performancesummary;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.inject.Named;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.dao.target.PerformanceCalculationDAO;
import com.vanguard.corp.ics.enums.CalculationPeriodEnum;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;
import com.vanguard.corp.ics.sdt.service.api.constants.PerformanceSummaryCode;
import com.vanguard.corp.ics.sdt.service.api.constants.PerformanceSummaryName;

@Named
public class PerformanceSummaryDataConverter {
	private Logger log = LoggerFactory.getLogger(PerformanceSummaryDataConverter.class);
	/**
	 * Converts Target data(L2) to report readable data(L1).
	 * If no L2 data is available and Port Id is not null, then default records (Portfolio Gross / BMK Net, Diff) are created.
	 * Diff is calculated by subtracting BMK Net values from Portfolio Gross values.
	 * @param readList - List containing the data from L2 table
	 * @param effectiveDate - Effective Date
	 * @param portId - Port ID
	 * @param calledByUserId - User Id
	 * @return
	 */
	public List<PerformanceSummary> convert(List<PerformanceCalculationDAO> readList, Date effectiveDate,
			String portId, String calledByUserId) {
		log.info("Data size form L2 for EffectiveDate: [" + effectiveDate + "] portId: [" + portId+"] - "+readList.size());
		//1. Group L2 data with port id as key.
		Map<String, List<PerformanceCalculationDAO>> performanceSummayDAOMap = new HashMap<>();
		for (PerformanceCalculationDAO performanceCalculationDao : readList) {
			String key = performanceCalculationDao.getPrtCd();
			if (performanceSummayDAOMap.containsKey(key)) {
				performanceSummayDAOMap.get(key).add(performanceCalculationDao);
			} else {
				List<PerformanceCalculationDAO> list = new ArrayList<>();
				list.add(performanceCalculationDao);
				performanceSummayDAOMap.put(key, list);
			}
		}
		log.info("Number of port id's in the list [Note: multiple ports id's are got only when port id in the endpoint is null] "+performanceSummayDAOMap.size());

		List<PerformanceSummary> performanceSummaries = new ArrayList<>();
		// 2. If L2 data is empty, create default records (Portfolio Gross / BMK Net, Diff).
		if(performanceSummayDAOMap.isEmpty()) {
			if(null != portId) {
				performanceSummaries.add(createPerformanceSummaryNullData(PerformanceSummaryName.PORTFOLIO_GROSS.getName(), PerformanceSummaryCode.PFT_CODE.getCode(), effectiveDate, portId));
				performanceSummaries.add(createPerformanceSummaryNullData(PerformanceSummaryName.BMK_NET.getName(), PerformanceSummaryCode.BMK_CODE.getCode(), effectiveDate, portId));
				performanceSummaries.add(createDiffRecord(performanceSummaries.get(0), performanceSummaries.get(1)));
			}
		} else {
			// 3. If L2 data is not empty, group data under each port id based on the Type.
			for (Map.Entry<String, List<PerformanceCalculationDAO>> entry : performanceSummayDAOMap.entrySet()) {
				performanceSummaries.addAll(createPortfolioGrossData(entry.getValue(), effectiveDate, portId));
				log.info("L1 records for port id: "+entry.getKey()+" is "+performanceSummaries.size());
			}
		}
		// 4. Update all records with User ID.
		for(PerformanceSummary summary : performanceSummaries){
			summary.setLastUpdatedUserId(calledByUserId);
		}
		return performanceSummaries;
	}

	/**
	 * Each L2 record will be split into Portfolio and benchmark records. L2 will have more than 1 records for a single portfolio / bmk map. 
	 * Each of these records will have different periods (@CalculationPeriodEnum). All these periods for a single portfolio / bmk map will 
	 * be converted into a single PerfomanceSummary (L1) record.
	 * @param readList - List containing the data from L2 table
	 * @param effectiveDate - Effective Date
	 * @param portId - Port ID
	 * @return
	 */
	private List<PerformanceSummary> createPortfolioGrossData(List<PerformanceCalculationDAO> readList, Date effectiveDate, String portId) {
		List<PerformanceSummary> convertedData = new ArrayList<>();
		Map<String, PerformanceSummary> prtData = new HashMap<>();
		//1. Group L2 data based on the portfolio type
		for (PerformanceCalculationDAO dao : readList) {
			String prtTypeKey = dao.getPrtType();
			if(prtData.containsKey(prtTypeKey)) {
				addCommonPortfolioData(prtData.get(prtTypeKey), dao);
			} else {
				PerformanceSummary data = new PerformanceSummary();
				data.setPerformanceTypeName(prtTypeKey);
				data.setEffectiveDate(dao.getCalcDt());
				data.setPortId(dao.getPrtCd());
				prtData.put(prtTypeKey,addCommonPortfolioData(data, dao));
			}
		}
		//1. Group L2 data based on the bmk type
		Map<String, PerformanceSummary> bmkData = new HashMap<>();
		for (PerformanceCalculationDAO dao : readList) {
			String key = dao.getBmkType();
			if(bmkData.containsKey(key)) {
				addCommonBmkData(bmkData.get(key), dao);
			} else {
				PerformanceSummary data = new PerformanceSummary();
				data.setPerformanceTypeName(key);
				data.setEffectiveDate(dao.getCalcDt());
				data.setPortId(dao.getPrtCd());
				bmkData.put(key, addCommonBmkData(data, dao));
			}
		}
		convertedData.addAll(prtData.values());
		convertedData.addAll(bmkData.values());
		return calculateDifferenceBetweenPortfolioAndBenchMark(convertedData, effectiveDate, portId);
	}

	private PerformanceSummary addCommonPortfolioData(PerformanceSummary data, PerformanceCalculationDAO dao) {
		data.setPerformanceTypeCode(PerformanceSummaryCode.PFT_CODE.getCode());
		if (dao.getPeriod().equals(CalculationPeriodEnum.CYTD)) {
			data.setYearToDateValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P1M)) {
			data.setOneMonthValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P3M)) {
			data.setThreeMonthValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P6M)) {
			data.setSixMonthValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P1Y)) {
			data.setOneYearValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P3YPA)) {
			data.setThreeYearValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P5YPA)) {
			data.setFiveYearValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.PINCP)) {
			data.setInceptionValue(dao.getPrtVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.PINCEPPA)) {
			data.setInceptionPerformanceAdjustedValue(dao.getPrtVal());
		} else {
			data.setYearToDateValue(dao.getPrtVal());
		}
		return data;
	}
	
	private PerformanceSummary addCommonBmkData(PerformanceSummary data, PerformanceCalculationDAO dao) {
		data.setPerformanceTypeCode(PerformanceSummaryCode.BMK_CODE.getCode());
		if (dao.getPeriod().equals(CalculationPeriodEnum.CYTD)) {
			data.setYearToDateValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P1M)) {
			data.setOneMonthValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P3M)) {
			data.setThreeMonthValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P6M)) {
			data.setSixMonthValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P1Y)) {
			data.setOneYearValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P3YPA)) {
			data.setThreeYearValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.P5YPA)) {
			data.setFiveYearValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.PINCP)) {
			data.setInceptionValue(dao.getBmkVal());
		} else if (dao.getPeriod().equals(CalculationPeriodEnum.PINCEPPA)) {
			data.setInceptionPerformanceAdjustedValue(dao.getBmkVal());
		} else {
			data.setYearToDateValue(dao.getBmkVal());
		}
		return data;
	}

	private List<PerformanceSummary> calculateDifferenceBetweenPortfolioAndBenchMark(
			List<PerformanceSummary> performanceSummaries, Date effectiveDate, String portId) {
		List<PerformanceSummary> convertedData = new ArrayList<>();
		PerformanceSummary portfolio = null;
		PerformanceSummary bmk = null;

		for (PerformanceSummary data : performanceSummaries) {
			if (PerformanceSummaryName.PORTFOLIO_GROSS.getName().equals(data.getPerformanceTypeName())) {
				portfolio = data;
			} else if (PerformanceSummaryName.BMK_NET.getName().equals(data.getPerformanceTypeName())) {
				bmk = data;
			} else {
				addNotNullOptionalRecords(data, convertedData);
			}
		}
		// create default records (Portfolio Gross / BMK Net, Diff).
		if (null == portfolio) {
			portfolio = createPerformanceSummaryNullData(PerformanceSummaryName.PORTFOLIO_GROSS.getName(), PerformanceSummaryCode.PFT_CODE.getCode(), effectiveDate, portId);
		}
		if (null == bmk) {
			bmk = createPerformanceSummaryNullData(PerformanceSummaryName.BMK_NET.getName(), PerformanceSummaryCode.BMK_CODE.getCode(), effectiveDate, portId);
		}
		convertedData.add(createDiffRecord(portfolio, bmk));
		convertedData.add(portfolio);
		convertedData.add(bmk);

		return convertedData;

	}

	private void addNotNullOptionalRecords(PerformanceSummary ps, List<PerformanceSummary> convertedData) {
		if (isValidPerformanceSummaryName(ps.getPerformanceTypeName())) {
			if (checkIfNotNullValueExist(ps.getOneMonthValue(), ps.getThreeMonthValue(), ps.getSixMonthValue(),
					ps.getNineMonthValue(), ps.getOneYearValue(), ps.getThreeYearValue(), ps.getFiveYearValue(),
					ps.getTenYearValue(), ps.getInceptionValue(), ps.getYearToDateValue())) {
				convertedData.add(ps);
			}
		}
	}

	private boolean isValidPerformanceSummaryName(String performanceTypeName) {
		return PerformanceSummaryName.of(performanceTypeName) != null;
	}

	boolean checkIfNotNullValueExist(Object... args) {
		for (Object arg : args) {
			if (arg != null) {
				return true;
			}
		}
		return false;
	}

	private PerformanceSummary createPerformanceSummaryNullData(String name, String code, Date effectiveDate, String portId) {
		PerformanceSummary performanceSummary = new PerformanceSummary();
		performanceSummary.setPerformanceTypeName(name);
		performanceSummary.setPerformanceTypeCode(code);
		performanceSummary.setEffectiveDate(effectiveDate);
		performanceSummary.setPortId(portId);
		performanceSummary.setOneMonthValue(null);
		performanceSummary.setThreeMonthValue(null);
		performanceSummary.setSixMonthValue(null);
		performanceSummary.setNineMonthValue(null);
		performanceSummary.setOneYearValue(null);
		performanceSummary.setThreeYearValue(null);
		performanceSummary.setFiveYearValue(null);
		performanceSummary.setTenYearValue(null);
		performanceSummary.setInceptionValue(null);
		performanceSummary.setYearToDateValue(null);
		return performanceSummary;
	}

	private PerformanceSummary createDiffRecord(PerformanceSummary portfolio, PerformanceSummary bmk) {
		PerformanceSummary performanceSummary = new PerformanceSummary();
		performanceSummary.setEffectiveDate(portfolio.getEffectiveDate());
		performanceSummary.setPortId(portfolio.getPortId());
		performanceSummary.setPerformanceTypeName(PerformanceSummaryName.DIFF.getName());
		performanceSummary.setPerformanceTypeCode(PerformanceSummaryCode.DIFF_CODE.getCode());
		performanceSummary.setOneMonthValue(getDiffValue(portfolio.getOneMonthValue(), bmk.getOneMonthValue()));
		performanceSummary.setThreeMonthValue(getDiffValue(portfolio.getThreeMonthValue(), bmk.getThreeMonthValue()));
		performanceSummary.setSixMonthValue(getDiffValue(portfolio.getSixMonthValue(), bmk.getSixMonthValue()));
		performanceSummary.setNineMonthValue(getDiffValue(portfolio.getNineMonthValue(), bmk.getNineMonthValue()));
		performanceSummary.setOneYearValue(getDiffValue(portfolio.getOneYearValue(), bmk.getOneYearValue()));
		performanceSummary.setThreeYearValue(getDiffValue(portfolio.getThreeYearValue(), bmk.getThreeYearValue()));
		performanceSummary.setFiveYearValue(getDiffValue(portfolio.getFiveYearValue(), bmk.getFiveYearValue()));
		performanceSummary.setTenYearValue(getDiffValue(portfolio.getTenYearValue(), bmk.getTenYearValue()));
		performanceSummary.setInceptionValue(getDiffValue(portfolio.getInceptionValue(), bmk.getInceptionValue()));
		performanceSummary.setYearToDateValue(getDiffValue(portfolio.getYearToDateValue(), bmk.getYearToDateValue()));

		return performanceSummary;
	}

	private BigDecimal getDiffValue(BigDecimal portfolioGross, BigDecimal bmkNet) {
		BigDecimal result = null;
		if (null != portfolioGross && null != bmkNet) {
			result = portfolioGross.subtract(bmkNet);
		}
		return result;
	}

}


		PerformanceSummaryTransferService.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.performancesummary;

import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.PerformanceCalculationDAO;
import com.vanguard.corp.ics.repository.target.PerformanceCalculationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.PerformanceSummarayRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadPerformanceSummaryException;
import com.vanguard.corp.ics.sdt.service.api.exception.SavePerformanceSummaryException;

@Named
public class PerformanceSummaryTransferService implements TransferService {
	private Logger log = LoggerFactory.getLogger(PerformanceSummaryTransferService.class);

	@Inject
	private PerformanceCalculationRepository readRepo;

	@Inject
	private PerformanceSummarayRepository repo;

	@Inject
	PerformanceSummaryDataConverter dataConverter;

	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}

	@Override
	public boolean handles(final Date effectiveDate, final String portId, final DataSetType dataSetType,
			final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.PERFORMANCE_SUMMARY;
	}

	@Override
	@Transactional
	public void transfer(Date effectiveDate, String portId, String calledByUserId, HttpServletRequest request) {
		log.info("Transfer service input params - EffectiveDate: [" + effectiveDate + "] portId: [" + portId
				+ "] calledByUser: [" + calledByUserId + "]");
		Assert.notNull(effectiveDate, "[PerformanceSummaryTransferService.transfer] effectiveDate cannot be null");
		Assert.hasText(calledByUserId, "[PerformanceSummaryTransferService.transfer] calledByUserId is required");

		List<PerformanceCalculationDAO> targetData = readPerformanceSummary(effectiveDate, portId);
		savePerformanceSummary(targetData, effectiveDate, portId, calledByUserId);
	}

	private List<PerformanceCalculationDAO> readPerformanceSummary(Date effectiveDate, String portId) {
		List<PerformanceCalculationDAO> readList;
		try {
			if (StringUtils.isEmpty(portId)) {
				readList = readRepo.findByCalculationDateAndLastestVersion(effectiveDate);
			} else {
				readList = readRepo.findByCalculationDateAndPortCodeAndLastestVersion(effectiveDate, portId);
			}
			log.info("Is there data for EffectiveDate: [" + effectiveDate + "] portId: [" + portId+"] - "+CollectionUtils.isEmpty(readList));
		} catch (Exception e) {
			final String msg = String.format(
					"[PerformanceSummaryTransferService.transfer] %s thrown while reading performance summary; msg:%s",
					e.getClass().getSimpleName(), e.getMessage());
			throw new ReadPerformanceSummaryException(msg, e);
		}
		return readList;
	}

	private void savePerformanceSummary(List<PerformanceCalculationDAO> readList, Date effectiveDate, String portId,
			String calledByUserId) {
		try {
			/*
			 * 1. Convert 2. Calculate difference = Portfolio (Gross) - Bmk
			 * (Net). Add null values if either of Portfolio (Gross) - Bmk (Net)
			 * are not present.
			 */
			List<PerformanceSummary> performanceSummaries = dataConverter.convert(readList, effectiveDate, portId,
					calledByUserId);

			if (CollectionUtils.isNotEmpty(performanceSummaries)) {
				// Update existing recors
				updateExistingData(effectiveDate, portId);

				// insert new records
				repo.save(performanceSummaries);
			}

		} catch (Exception e) {
			final String msg = String.format(
					"[PerformanceSummaryTransferService.transfer] %s thrown while saving Performance; msg:%s",
					e.getClass().getSimpleName(), e.getMessage());
			throw new SavePerformanceSummaryException(msg, e);
		}
	}

	private void updateExistingData(Date effectiveDate, String portId) {
		List<PerformanceSummary> storedPerformanceSummary = repo
				.findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(effectiveDate, portId);
		for (PerformanceSummary performanceSummary : storedPerformanceSummary) {
			performanceSummary.setEffectiveEndDate(new Date());
		}
	}
}


com.vanguard.corp.ics.sdt.service.impl.risksummary

	LimitValidator.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.risksummary;

import java.math.BigDecimal;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;

@Named
public class LimitValidator {

	public boolean isValid(AnalyticsTypeCode analyticType, BigDecimal lowerLimit, BigDecimal upperLimit,
			BigDecimal splitLimit) {

		// Analytic type is not ExAnte. This is independent of upper limit and split limit. Lower limit can be empty or populated
		boolean valid = analyticType != AnalyticsTypeCode.EX_ANTE_RISK;

		// Analytic type is ExAnte and all limits are empty
		valid = valid || (lowerLimit == null && isUpperAndSplitNull(upperLimit, splitLimit));

		// Analytic type is ExAnte. Only lower limit is populated or lower, upper, and split are all populated
		valid = valid || (lowerLimit != null && (isUpperAndSplitNull(upperLimit, splitLimit) || isUpperAndSplitNotNull(upperLimit, splitLimit)));

		return valid;
	}

	private boolean isUpperAndSplitNull(BigDecimal upperLimit, BigDecimal splitLimit) {
		return upperLimit == null && splitLimit == null;
	}

	private boolean isUpperAndSplitNotNull(BigDecimal upperLimit, BigDecimal splitLimit) {
		return upperLimit != null && splitLimit != null;
	}
}

	RiskSummaryServiceImpl.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.risksummary;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.repository.PortfolioLimitRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.GenerateLimitException;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadProductPortalException;

@Named
public class RiskSummaryServiceImpl implements TransferService {
	
	private static final Logger LOG = LoggerFactory.getLogger(RiskSummaryServiceImpl.class);
	
	private static final BigDecimal hundred = new BigDecimal("100");

	@Inject
	ProductPortalService productPortalService;
	
	@Inject
	LimitValidator limitValidator;

	@Inject
	PortfolioLimitRepository portfolioLimitRepository;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}
	
	@Override
	public boolean handles(final Date asOfDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.RISK_SUMMARY;
	}
	
	@Override
	@Transactional
	public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) {
		Assert.hasText(calledByUserId);
		final SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
		List<PortalProduct> products;
		
		try {
			products = productPortalService.getProducts(request);
		} catch (Exception e) {
			final String msg = String.format("[RiskSummaryServiceImpl.transfer] asOfDate:%s portId:%s threw %s; msg:%s ",
					f.format(asOfDate), portId, e.getClass().getSimpleName(), e.getMessage());
			throw new ReadProductPortalException(msg, e);
		}
		
		if (CollectionUtils.isNotEmpty(products)) {
	        if (StringUtils.isEmpty(portId)) {
				for (PortalProduct product : products) {
					moveRiskSummaryDataToReport(product, calledByUserId);
				}
			}
			else {
				PortalProduct product = productPortalService.getProduct(products, portId);
				moveRiskSummaryDataToReport(product, calledByUserId);
			}
	    }
		else {
	        final String msg = "[ProductDataServiceImpl.transfer] No products retrieved.";
	        throw new ReadProductPortalException(msg);
	    }
	}

	private void moveRiskSummaryDataToReport(PortalProduct product, String calledByUserId) {
		Assert.notNull(product);
	
		List<Limit> existinglimits;
		List<Limit> limits;

		limits = generateRiskSummaryLimitReportRecords(product, calledByUserId);
		existinglimits = portfolioLimitRepository.findByPortfolioCodeAndEffectiveEndDateIsNull(product.getProductCode());
		
		for (Limit existingLimit : existinglimits) {
			existingLimit.setEffectiveEndDate(new Date());
			portfolioLimitRepository.save(existingLimit);
		}
		
		portfolioLimitRepository.save(limits);
	}

	private List<Limit> generateRiskSummaryLimitReportRecords(PortalProduct product, String calledByUserId) {
		org.springframework.util.Assert.notNull(product);
		
		String portId = product.getProductCode();
		List<Limit> limits = new ArrayList<>();
		
		for (AnalyticsTypeCode analyticType : AnalyticsTypeCode.values()) {
			
			if (!analyticType.hasLimit()) {
				continue;
			}
			
			Limit limit = new Limit();
			limit.setEffectiveBeginDate(new Date());
			
			limit.setPortfolioCode(portId);
			limit.setLimitTypeCode(analyticType.getCode());
			limit.setLimitName(analyticType.getName());	
			limit.setLastUpdatedUserId(calledByUserId);
			
			BigDecimal lowerLimit = getLowerLimit(product, analyticType);
			BigDecimal upperLimit = getUpperLimit(product, analyticType);
			BigDecimal splitLimit = (analyticType == AnalyticsTypeCode.EX_ANTE_RISK) ? product.getFumLimitexAnte() : null;
			
			if (limitValidator.isValid(analyticType, lowerLimit, upperLimit, splitLimit)) {
				LOG.info("Valid limits lower:{} upper:{} split:{} for {} on {} portfolio", lowerLimit, upperLimit, splitLimit, analyticType, portId);
				
			    limit.setLowerLimitValue(lowerLimit);
			    limit.setUpperLimitValue(upperLimit);
			    limit.setFumSplitLimitValue(splitLimit);
			    
			    limits.add(limit);
			} else {
				LOG.error("Invalid limits lower:{} upper:{} split:{} for {} on {} portfolio", lowerLimit, upperLimit, splitLimit, analyticType, portId);
				throw new GenerateLimitException("Received invalid limits for " + portId + " portfolio", null);
			}
		}
		
		return limits;
	}
	
	private BigDecimal getLowerLimit(PortalProduct product, AnalyticsTypeCode analyticType) {
		BigDecimal limit;
		
		if (analyticType == AnalyticsTypeCode.EX_ANTE_RISK && product.getExAnteMaxBreachIMA() != null) {
			BigDecimal benchmarkValue = product.getExAnteMaxBreachIMA();	
			limit = benchmarkValue.divide(hundred);
		}  else if ((analyticType == AnalyticsTypeCode.ONE_YR_EX_POST || analyticType == AnalyticsTypeCode.THREE_YR_EX_POST) && product.getExPostMaxBreachIMA() != null) {
			BigDecimal benchmarkValue = product.getExPostMaxBreachIMA();
			limit = benchmarkValue.divide(hundred);
		} else {
			limit = null;
		}

		return limit;
	}
	
	private BigDecimal getUpperLimit(PortalProduct product, AnalyticsTypeCode analyticType) {
		BigDecimal limit;
		
		if (analyticType == AnalyticsTypeCode.EX_ANTE_RISK && product.getExAnteMaxBreachIMAAbove() != null) {
			BigDecimal benchmarkValue = product.getExAnteMaxBreachIMAAbove();
			limit = benchmarkValue.divide(hundred);
		} else {
			limit = null;
		}
		
		return limit;
	}
}

com.vanguard.corp.ics.sdt.webservice
	Application.java

/*
 ****************************************************************************
 *
 * Copyright (c)2015 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/tip/ngsa/projects/maven-extensions/archetypes/spring-boot-jaxrs/trunk/src/main/resources/archetype-resources/src/main/java/Application.java $
 $LastChangedRevision: 428375 $
 $Author: urok $
 $LastChangedDate: 2015-11-24 16:09:33 -0500 (Tue, 24 Nov 2015) $
*/
package com.vanguard.corp.ics.sdt.webservice;

import java.util.EnumSet;

import javax.servlet.DispatcherType;
import javax.servlet.Filter;

import org.apache.catalina.core.StandardHost;
import org.apache.catalina.startup.Tomcat;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.actuate.autoconfigure.ManagementServerProperties;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.FilterRegistrationBean;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.ImportResource;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

import com.vanguard.cto.support.SpringBootConfig;
import com.vanguard.servlet.filter.F5Filter;
import com.vanguard.spring.condition.NonWindowsCondition;
import com.vanguard.spring.condition.WindowsCondition;
import com.vanguard.spring.connector.VanguardTomcatConnectorCustomizer;

@SpringBootApplication(exclude = {
		DataSourceAutoConfiguration.class
		, DataSourceTransactionManagerAutoConfiguration.class
		, HibernateJpaAutoConfiguration.class
		})
@EnableCircuitBreaker
@ImportResource({
	"classpath*:/META-INF/**/spring-bootstrap.xml"
	, "classpath*:/META-INF/**/spring-bootstrap-standalone.xml"
	})
public class Application {

	public static final String BASE_PATH = "rs";
	protected static final String LOCAL_RTEID = "inte";
	protected static final String LOCAL_SPRING_PROFILE = "local";
	protected static final String KEY_RTEID = "RTEID";

	protected static boolean isWindowsOS = SystemUtils.IS_OS_WINDOWS;
	static SpringApplication app = new SpringApplication(Application.class);
	TomcatEmbeddedServletContainerFactory tomcat = createTomcatEmbeddedServletContainerFactory();
	FilterRegistrationBean registration = new FilterRegistrationBean();

    @Value("${jersey.config.server.debug:false}")
    protected boolean isJerseyDebug;

	public static void main(String[] args) {
		SpringBootConfig.initialize(Application.class);
		setLocalProperties(app);
		app.run(args);
	}

	/**
	 * For local testing, default to RTE=inte and spring.profiles.active=local,
	 * both of which can be overriden from the command line
	 * 
	 * @param app
	 */
	protected static void setLocalProperties(SpringApplication app) {
		if (isWindowsOS) {
			System.setProperty(KEY_RTEID, System.getProperty(KEY_RTEID, LOCAL_RTEID));
			app.setAdditionalProfiles(LOCAL_SPRING_PROFILE);
		}
	}

	protected TomcatEmbeddedServletContainerFactory createTomcatEmbeddedServletContainerFactory() {
		return new TomcatEmbeddedServletContainerFactory() {

			@Override
			protected TomcatEmbeddedServletContainer getTomcatEmbeddedServletContainer(Tomcat tomcat) {
				((StandardHost) tomcat.getHost()).setErrorReportValveClass(StringUtils.EMPTY);
				return super.getTomcatEmbeddedServletContainer(tomcat);
			}
		};
	}

	@Bean
	public EmbeddedServletContainerFactory servletContainer() {
		tomcat.addConnectorCustomizers(new VanguardTomcatConnectorCustomizer());
		return tomcat;
	}

	/**
	 * Needed to FAKE Auth with SUDS lib, must to set to order 0 and MUST appear
	 * BEFORE requestContextFilter() in java source
	 */
	@Bean
	@Conditional({ WindowsCondition.class, NonProductionCondition.class })
	public FilterRegistrationBean ntFilter() {
		FilterRegistrationBean ntRegistration = new FilterRegistrationBean(new NTHeaderFilter());
		ntRegistration.setName("NTFilter");
		ntRegistration.setOrder(Ordered.HIGHEST_PRECEDENCE);
		ntRegistration.addUrlPatterns("/*");
		return ntRegistration;
	}

	/**
	 * After ntFilter() for SUDS lib
	 */
	@Bean
	public FilterRegistrationBean requestContextFilter() {
		FilterRegistrationBean rcRegistration = new FilterRegistrationBean(new org.springframework.web.filter.RequestContextFilter());
		rcRegistration.setName("RequestContextFilter");
		rcRegistration.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
		rcRegistration.addUrlPatterns("/*");
		return rcRegistration;
	}

	@Bean
	public FilterRegistrationBean springSecurityFilterChain() {
		FilterRegistrationBean filterRegistration = new FilterRegistrationBean(new org.springframework.web.filter.DelegatingFilterProxy());
		filterRegistration.setName("SpringSecurityFilterChain");
		filterRegistration.setOrder(Ordered.HIGHEST_PRECEDENCE + 2);
		filterRegistration.addUrlPatterns("/*");
		return filterRegistration;
	}

	@Bean
	@Conditional(NonWindowsCondition.class)
	public FilterRegistrationBean f5Filter() {
		FilterRegistrationBean f5Registration = new FilterRegistrationBean(new F5Filter());
		f5Registration.setName("F5Filter");
		f5Registration.setOrder(Ordered.HIGHEST_PRECEDENCE + 3);
		f5Registration.addUrlPatterns("/" + BASE_PATH + "/*");
		return f5Registration;
	}

	/**
	 * Initializes and registers the JAX-RS filter implementation, currently
	 * Jersey.
	 * 
	 * @return The JAX-RS filter registration.
	 * @throws ClassNotFoundException
	 * @throws IllegalAccessException
	 * @throws InstantiationException
	 */
	@Bean
	public FilterRegistrationBean jaxrsFilter() throws ReflectiveOperationException { 
		Filter filter = (Filter) Class.forName("org.glassfish.jersey.servlet.ServletContainer").newInstance();
		registration.setFilter(filter);
		registration.setName("JerseyFilter");
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		// Set the Jersey filter mapping and context path
		registration.addUrlPatterns("/" + BASE_PATH + "/*");
		registration.addInitParameter("jersey.config.servlet.filter.contextPath", BASE_PATH);
		// Load the common package and application package
		registration.addInitParameter("jersey.config.server.provider.packages", "com.vanguard.jaxrs.feature;com.vanguard.corp.ics.sdt");
		// Enable media type mappings on the URI such as .xml and .json
		registration.addInitParameter("jersey.config.server.mediaTypeMappings", "xml:application/xml, json:application/json");
		// Enable Java bean validation integration
		registration.addInitParameter("jersey.config.beanValidation.enableOutputValidationErrorEntity.servers", "true");
		// Forward 404s to Spring MVC, which serves up the Actuator endpoints
		// and non-jersey resources
		registration.addInitParameter("jersey.config.servlet.filter.forwardOn404", "true");

		if (isJerseyDebug) {
			// Debug parameter switches
			registration.addInitParameter("jersey.config.server.monitoring.statistics.enabled", "true");
			registration.addInitParameter("jersey.config.server.tracing.type", "ALL");
			registration.addInitParameter("jersey.config.server.tracing.threshold", "VERBOSE");
		}

		// TODO Remove below code after testing
		if (isWindowsOS) {
			registration.addInitParameter("jaxrs.config.csrf.enableNullOriginBypass", "true");
			registration.addInitParameter("jaxrs.config.cors.allowedOrigins", "localhost.vanguard.com:8080");
			registration.addInitParameter("jaxrs.config.csrf.enableTokenCheck", "false");
		}
		return registration;
	}

	@Bean
	public ApplicationSecurity applicationSecurity() {
		return new ApplicationSecurity();
	}

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public static class ApplicationSecurity extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			// This disables Spring Security on only the Spring Boot Actuator endpoints.
			http.authorizeRequests().antMatchers("/" + BASE_PATH + "/**").permitAll().and().csrf().disable();
		}
	}
}

	NonProductionCondition.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice;

import java.util.Arrays;
import java.util.List;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class NonProductionCondition implements Condition{

	@Override
	public boolean matches(ConditionContext context,
			AnnotatedTypeMetadata metadata) {
		String environments = "dev,int,inte,sat,catp,prf,test";
		List<String> environmentsList = Arrays.asList(environments.split(","));
		String propertyValue = context.getEnvironment().getProperty("RTEID");
		return environmentsList.contains(propertyValue);
	}

}


	NTHeaderFilter.java

package com.vanguard.corp.ics.sdt.webservice;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

public class NTHeaderFilter implements Filter {
	
	private NTHeaderValues ntHeaderValues = new NTHeaderValues();
	
	public NTHeaderFilter() {
	}

	
	public void destroy() {
	}

	
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException 
	{
		HttpServletRequest req = (HttpServletRequest) request;
		FakeHeadersRequest sdsrw = new FakeHeadersRequest(req);
		chain.doFilter(sdsrw, response);
	}

	
	public void init(FilterConfig fConfig) throws ServletException {
	}

	
	public class FakeHeadersRequest extends HttpServletRequestWrapper {

		public FakeHeadersRequest(HttpServletRequest request) {
			super(request);
		}

		@Override
		public String getHeader(String name) {
			
			if(ntHeaderValues.headerValueMap.containsKey(name)){
				return ntHeaderValues.headerValueMap.get(name);
			}
			return super.getHeader(name);
		}
	}
	
	public class NTHeaderValues {
		
		public Map<String,String> headerValueMap;
		
		public NTHeaderValues(){
			headerValueMap = new HashMap<String,String>();
			headerValueMap.put("SM_UNIVERSALID","UWJA");
			headerValueMap.put("APP_CODE","SDT");
			headerValueMap.put("POID","1232135819");
			headerValueMap.put("SRV_TYPE","INTR");
			headerValueMap.put("Authorization","true");
		}		
	}
	
}


com.vanguard.corp.ics.sdt.webservice.resource

	CalculationEngineParameters.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.ws.rs.PathParam;

public class CalculationEngineParameters {

	public static final String PATH = "{month}/{year}";

	public static final long MONTH_MIN = 1;
	public static final long MONTH_MAX = 12;
	public static final String PARM_MONTH = "month";

	public static final long YEAR_MIN = 2010;
	public static final long YEAR_MAX = 2100;
	public static final String PARM_YEAR = "year";

	@NotNull
	@Min(value=MONTH_MIN)
	@Max(value=MONTH_MAX)
	@PathParam(PARM_MONTH)
	private Integer month;

	@NotNull
	@Min(value=YEAR_MIN)
	@Max(value=YEAR_MAX)
	@PathParam(PARM_YEAR)
	private Integer year;

	public Integer getMonth() {
		return month;
	}

	public void setMonth(final Integer month) {
		this.month = month;
	}

	public Integer getYear() {
		return year;
	}

	public void setYear(final Integer year) {
		this.year = year;
	}
}


	CalculationEngineResource.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.resource;

import java.util.Optional;

import javax.annotation.security.PermitAll;
import javax.validation.Valid;
import javax.ws.rs.BeanParam;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import com.vanguard.corp.ics.portal.PortalService;
import com.vanguard.corp.ics.portal.domain.Product;
import com.vanguard.corp.ics.sdt.service.calculation.PerformanceCalculationService;

@PermitAll
@Path(CalculationEngineResource.PATH)
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
@Consumes({ MediaType.APPLICATION_JSON })
public class CalculationEngineResource {

	private static Logger LOGGER = LoggerFactory.getLogger(CalculationEngineResource.class);

	public static final String PATH = "calculation";

	@Autowired
	private PerformanceCalculationService calcService;

	@Autowired
	private PortalService portal;

	@GET
	@Path(CalculationEngineParameters.PATH)
	public Response finalCalcsAll(@Valid @BeanParam CalculationEngineParameters parms) {

		LOGGER.debug("Running final calcs for {}-{}", parms.getMonth(), parms.getYear());

//		calcService.calculate(parms.getMonth(), parms.getYear())

		return Response.ok("Finished Calcs").build();
	}

	@GET
	@Path(CalculationSingleParameters.PATH)
	public Response finalCalcsSingle(@Valid @BeanParam CalculationSingleParameters parms) {

		final Optional<Product> p = portal.getProduct(parms.getPortfolioCode());

		if (!p.isPresent()) {
			LOGGER.debug("Error fetching product: {}", parms.getPortfolioCode());
			return Response.serverError().build();
		}

		LOGGER.debug("Running final calcs for {}-{}", parms.getMonth(), parms.getYear());
		LOGGER.debug("Calculating with Code={}", parms.getPortfolioCode());

//		calcService.calculate(p.get(), parms.getMonth(), parms.getYear())

		return Response.ok("Finished Calcs").build();
	}

}


	CalculationSingleParameters.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.NotNull;
import javax.ws.rs.PathParam;

import com.vanguard.validator.constraints.SafeString;

public class CalculationSingleParameters extends CalculationEngineParameters {

	public static final String PATH = "{portfolioCode}/" + CalculationEngineParameters.PATH;

	public static final String PARM_PORTFOLIO_CODE = "portfolioCode";

	@NotNull
	@SafeString
	@PathParam(PARM_PORTFOLIO_CODE)
	private String portfolioCode;

	public String getPortfolioCode() {
		return portfolioCode;
	}

	public void setPortfolioCode(final String portCode) {
		this.portfolioCode = portCode;
	}
}


	CommentaryDTO.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;

import com.vanguard.validator.constraints.SafeString;

public class CommentaryDTO {
	public static final String PARM_AS_OF_DATE = "asOfDate";
	public static final String PARM_PORT_ID = "portId";
	public static final String PARM_DATA_SET = "dataSet";
	public static final String DATE_PATTERN = "^(\\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$"; // yyyy-MM-dd
	public static final String ALLOWED_CHARS = "_";

	private String id;
	
	@NotNull
	@Pattern(regexp=DATE_PATTERN)
	private String asOfDate;

	@NotNull
	@SafeString
	private String portId;

	@NotNull
	@SafeString
	private String commentary;

	public String getAsOfDate() {
		return asOfDate;
	}

	public String getCommentary() {
		return commentary;
	}

	public String getId() {
		return id;
	}

	public String getPortId() {
		return portId;
	}

	public void setAsOfDate(final String asOfDate) {
		this.asOfDate = asOfDate;
	}

	public void setCommentary(final String commentary) {
		this.commentary = commentary;
	}

	public void setId(final String id) {
		this.id = id;
	}

	public void setPortId(final String portId) {
		this.portId = portId;
	}
}


		CommentaryParameters.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.ws.rs.QueryParam;

import com.vanguard.validator.constraints.SafeString;

public class CommentaryParameters {

	public static final String PARM_AS_OF_DATE = "asOfDate";
	public static final String PARM_PORT_ID = "portId";
	public static final String DATE_PATTERN = "^(\\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$"; // yyyy-MM-dd

	@NotNull
	@Pattern(regexp=DATE_PATTERN)
	@QueryParam(PARM_AS_OF_DATE)
	private String asOfDate;

	@NotNull
	@SafeString
	@QueryParam(PARM_PORT_ID)
	private String portId;

	public String getAsOfDate() {
		return asOfDate;
	}

	public void setAsOfDate(final String asOfDate) {
		this.asOfDate = asOfDate;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(final String portId) {
		this.portId = portId;
	}
}


		CommentaryResource.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import java.util.Date;

import javax.annotation.security.PermitAll;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import javax.ws.rs.BeanParam;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.container.ResourceContext;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.service.api.CommentaryService;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;

@PermitAll
@Path(CommentaryResource.PATH)
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
@Consumes({ MediaType.APPLICATION_JSON })
public class CommentaryResource {

	public static final String PATH = "commentary";

	private static Logger LOGGER = LoggerFactory.getLogger(CommentaryResource.class);
	private final DateParser dateParser = new DateParser();

	@Context
	private ResourceContext resourceContext;

	@Context
	private HttpServletRequest request;

	@Inject
	private CommentaryService commentaryService;

	@GET
	public Response retrieveCommentary(@Valid @BeanParam CommentaryParameters parms) {
		Date inputDate;

		try {
			inputDate = dateParser.parse(parms.getAsOfDate());
		}
		catch (Exception e) {
			LOGGER.error(String.format("[CommentaryResource.retrieveCommentary] %s thrown; msg:%s",
					e.getClass().getSimpleName(), e.getMessage()), e);
			return Response.status(Response.Status.BAD_REQUEST).build();
		}

		CommentaryDTO commentary = commentaryService.getCommentary(parms.getPortId(), inputDate);

		if (commentary != null) {
			LOGGER.info("Commentary Id: " + commentary.getId());
			LOGGER.info("Commentary Port Id: " + commentary.getPortId());
			LOGGER.info("Commentary Date: " + commentary.getAsOfDate());
			LOGGER.info("Commentary Text: " + commentary.getCommentary());
			LOGGER.info("Status is: " + Response.ok().entity(commentary).build().getStatus());

			return Response.ok().entity(commentary).build();

		}
		else {
			LOGGER.warn("Could not find Mandate with asOfDate: {} and portId: {}", parms.getAsOfDate(), parms.getPortId());
			LOGGER.warn("Reponse: " + Response.Status.BAD_REQUEST);

			return Response.status(Response.Status.BAD_REQUEST).build();
		}

	}

	@POST
	public Response updateCommentary(@Valid CommentaryDTO commentary) {

		commentaryService.saveOrUpdateCommentary(commentary);

		return Response.ok().entity(commentary).build();
	}
}


	DataTransferParameters.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.QueryParam;

import com.vanguard.validator.constraints.SafeString;
import com.vanguard.validator.constraints.UserName;

public class DataTransferParameters {

	public static final String PARM_AS_OF_DATE = "asOfDate";
	public static final String PARM_PORT_ID = "portId";
	public static final String PARM_DATA_SET = "dataSet";
	public static final String PARM_UID = "UID"; // from siteminder
	public static final String DATE_PATTERN = "^(\\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$"; // yyyy-MM-dd
	public static final String ALLOWED_CHARS = "_";

	@NotNull
	@Pattern(regexp=DATE_PATTERN)
	@QueryParam(PARM_AS_OF_DATE)
	private String asOfDate;

	@SafeString
	@QueryParam(PARM_PORT_ID)
	private String portId;

	@SafeString(allow=ALLOWED_CHARS)
	@QueryParam(PARM_DATA_SET)
	private String dataSet;

	@NotNull
	@UserName
	@HeaderParam(PARM_UID)
	private String uid;

	public String getAsOfDate() {
		return asOfDate;
	}

	public void setAsOfDate(final String asOfDate) {
		this.asOfDate = asOfDate;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(final String portId) {
		this.portId = portId;
	}

	public String getDataSet() {
		return dataSet;
	}

	public void setDataSet(final String dataSet) {
		this.dataSet = dataSet;
	}

	public String getUid() {
		return uid;
	}

	public void setUid(String uid) {
		this.uid = uid;
	}
}


		DataTransferResource.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import java.util.Date;

import javax.annotation.security.PermitAll;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import javax.ws.rs.BeanParam;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.container.ResourceContext;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;

@PermitAll
@Path(DataTransferResource.PATH)
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public class DataTransferResource {

	public static final String PATH = "transfer";
	public static final String DATE_FORMAT = "yyyy-MM-dd";
	
	private static Logger LOGGER = LoggerFactory.getLogger(DataTransferResource.class);
	private final DateParser dateParser = new DateParser();

	@Context
	private ResourceContext resourceContext;

	@Context
	private HttpServletRequest request;

	@Inject
	private DataTransferService service;

	@GET
	public Response transfer(@Valid @BeanParam DataTransferParameters parms) {
		Date asOfDate;
		DataSetType dataSetType;

		try {
			asOfDate = dateParser.parse(parms.getAsOfDate());
			dataSetType = parseDataSet(parms.getDataSet());
			
			// temporary log to make sure user id is retrieved successfully
			LOGGER.info("Request by {} for date:{}, portId:{}, dataSet:{}", parms.getUid(), parms.getAsOfDate(), parms.getPortId(), parms.getDataSet());
		}
		catch (Exception e) {
			LOGGER.error(String.format("[DataTransferResource.transfer] %s thrown; msg:%s",
					e.getClass().getSimpleName(), e.getMessage()), e);
			return Response.status(Response.Status.BAD_REQUEST).build();
		}

		service.transfer(asOfDate, parms.getPortId(), dataSetType, parms.getUid(), request);
		return Response.ok().build();
	}

	private DataSetType parseDataSet(final String dataSet) {
		return dataSet == null ? null : DataSetType.valueOf(dataSet);
	}
}


	TomcatDefaultErrorResource.java

/*
 ****************************************************************************
 *
 * Copyright (c)2016 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:


*/

package com.vanguard.corp.ics.sdt.webservice.resource;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * Embedded tomcat is forwarding 500s to this url as the catch all error handler
 * This will inspect the incoming request and log something.
 * Removing this resource causes the 500s to convert to 404s.
 * 
 * TODO This should be moved to spring-boot-common
 * 
 * @author ush8
 *
 */
@Component
@Path("/error")
public class TomcatDefaultErrorResource {

	private static final String ERROR = "ERROR";
	private Logger logger = LoggerFactory.getLogger(TomcatDefaultErrorResource.class);

	@GET
	public String handleError(@Context HttpServletResponse response, @Context HttpServletRequest request) throws IOException {

		// this is from tomcat's default error handler logic. See StandardHostValve.throwable
		if (ERROR.equals(getDispatcherType(request))) {
			Integer originalStatusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
			String originalURL = (String) request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI);
			String originalMessage = (String) request.getAttribute(RequestDispatcher.ERROR_MESSAGE);
			Throwable originalThrown = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);

			response.setStatus(originalStatusCode.intValue());
			logger.error("Error From URL:" + originalURL + " Message:" + originalMessage + " StatusCode:" + originalStatusCode, originalThrown);
		} else {
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		response.setContentLength(0);
		response.getOutputStream().flush();
		response.getOutputStream().close();
		
		return null;
	}

	protected String getDispatcherType(HttpServletRequest request) {
		return request.getDispatcherType().toString();
	}
	
}




src/test/java
com.vanguard.corp.ics.portal.config
	PortalSDKConfigurationTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.portal.config;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class PortalSDKConfigurationTest {

	private static final String TEST_TOKEN_URL = "testTokenUrl";
	private static final String TEST_USERNAME = "testUsername";
	private static final String TEST_REFERENCE_END_POINT = "testReferenceEndPoint";
	private static final String TEST_ENDPOINT = "testEndpoint";
	private static final String TEST_PASSWORD = "testPassword";
	private static final int TEST_RETRY_COUNT = 1;

	private PortalSDKConfiguration unitUnderTest = new PortalSDKConfiguration();

	@Test
	public void setup() {
		unitUnderTest.setPortalPassword(TEST_PASSWORD);
		unitUnderTest.setPortalProductEndpoint(TEST_ENDPOINT);
		unitUnderTest.setPortalReferenceEndpoint(TEST_REFERENCE_END_POINT);
		unitUnderTest.setPortalUsername(TEST_USERNAME);
		unitUnderTest.setRetryCount(TEST_RETRY_COUNT);
		unitUnderTest.setTokenURL(TEST_TOKEN_URL);

		assertEquals(TEST_PASSWORD, unitUnderTest.getPortalPassword());
		assertEquals(TEST_ENDPOINT, unitUnderTest.getPortalProductEndpoint());
		assertEquals(TEST_REFERENCE_END_POINT, unitUnderTest.getPortalReferenceEndpoint());
		assertEquals(TEST_USERNAME, unitUnderTest.getPortalUsername());
		assertEquals(TEST_RETRY_COUNT, unitUnderTest.getRetryCount());
		assertEquals(TEST_TOKEN_URL, unitUnderTest.getTokenURL());
	}

}


com.vanguard.corp.ics.sdt.behaviors.commentary

	CommentaryDtoDataTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.commentary;

import static org.junit.Assert.*;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

public class CommentaryDtoDataTest {
	
	private final String TEST_ID = "1";
	private final String TEST_PORTFOLIO_ID = "TestPortId";
	private final String TEST_AS_OF_DATE = "2017-01-01";
	private final String TEST_COMMENTARY_TEXT = "Test Commentary.";

	/**
	 * Test getters and setters
	 */
	@Test
	public void shouldGetAndSetValues() {
		CommentaryDTO commentary = new CommentaryDTO();
		
		commentary.setId(TEST_ID);
		commentary.setPortId(TEST_PORTFOLIO_ID);
		commentary.setAsOfDate(TEST_AS_OF_DATE);
		commentary.setCommentary(TEST_COMMENTARY_TEXT);
		
		assertEquals(commentary.getId(), TEST_ID);
		assertEquals(commentary.getPortId(), TEST_PORTFOLIO_ID);
		assertEquals(commentary.getAsOfDate(), TEST_AS_OF_DATE);
		assertEquals(commentary.getCommentary(), TEST_COMMENTARY_TEXT);
		
	}

}


	CommentaryEndpointTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.commentary;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import org.junit.Before;
import org.junit.Test;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.service.api.CommentaryService;
import com.vanguard.corp.ics.sdt.test.commentary.CommentaryServiceApplicationTester;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryResource;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;

public class CommentaryEndpointTest extends CommentaryServiceApplicationTester {

	private CommentaryService mockService;

	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		mockService = this.getMockService();
	}

	@Test
	public void endpointHandlesRetrieveWithAsOfDateAndPortIdParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		when(mockService.getCommentary(eq(portId), eq(asOfDate))).thenReturn(commentary);

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).getCommentary(eq(portId), eq(asOfDate));
	}
	
	@Test
	public void endpointRespondsWithBadRequestIfNoMatchingCommentaryForAsOfDateAndPortIdParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		when(mockService.getCommentary(eq(portId), eq(asOfDate))).thenReturn(null);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatusInfo().getStatusCode());
		
		verify(mockService, times(1)).getCommentary(eq(portId), eq(asOfDate));
	}
	
	@Test
	public void asOfDateIsRequiredOnRetrieve() {
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));
	}
	
	@Test
	public void asOfDateMustHaveCorrectFormatOnRetrieve() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "12/31/2016");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));;
	}

	@Test
	public void asOfDateMustBeAnActualDateOnRetrieve() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-02-29");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));
	}

	@Test
	public void portIdIsRequiredOnRetrieve() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));		
	}
	
	@Test
	public void endpointHandlesUpdateWithCommentary() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).saveOrUpdateCommentary(any(CommentaryDTO.class));		
	}
	
	@Test
	public void asOfDateIsRequiredOnUpdate() {
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));		
	}
	
	@Test
	public void asOfDateMustHaveCorrectFormatOnUpdate() {
		String asOf = "17-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));
	}

	@Test
	public void asOfDateMustBeAnActualDateOnUpdate() {
		String asOf = "2017-07-32";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));
	}
	
	@Test
	public void portIdIsRequiredOnUpdate() {
		String asOf = "2017-07-04";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));		
	}
	
	@Test
	public void commentaryIsRequiredOnUpdate() {
		String asOf = "2017-07-32";
		String portId = "ABC123";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
	
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));	
	}
	
	@Test
	public void endpointRespondsWithInternalServerErrorIfExceptionsOccurDuringRetrieve() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		doThrow(new RuntimeException()).when(mockService).getCommentary(eq(portId), eq(asOfDate));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());

		verify(mockService, times(1)).getCommentary(eq(portId), eq(asOfDate));
	}
	
	@Test
	public void endpointRespondsWithInternalServerErrorIfExceptionsOccurDuringUpdate() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		doThrow(new RuntimeException()).when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());

		verify(mockService, times(1)).saveOrUpdateCommentary(any(CommentaryDTO.class));	
	}
	
}


	CommentaryEntityTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.commentary;

import static org.junit.Assert.assertEquals;

import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;

public class CommentaryEntityTest {
	
	private final Long TEST_ID = Long.valueOf(1);
	private final String TEST_PORTFOLIO_ID = "Portfolio ID1";
	private final Date TEST_EFFECTIVE_DATE = new Date(1);
	private final String TEST_COMMENTARY_TEXT = "Test commentary text";
	private final String TEST_COMMENTARY_REASON = "Test commentary reason type";
	private final Date TEST_EFFECTIVE_BEGIN_DATE = new Date(2);
	private final Date TEST_EFFECTIVE_END_DATE = new Date(3);
	private final Date TEST_UPDATED_DATE = new Date();
	private final String TEST_UPDATED_USER = "updated user";

	/**
	 * Test getters and setters 
	 */
	@Test
	public void shouldGetAndSetValues(){
		Commentary commentary = new Commentary();
		
		commentary.setId(TEST_ID);
		commentary.setPortfolioId(TEST_PORTFOLIO_ID);
		commentary.setEffectiveDate(TEST_EFFECTIVE_DATE);
		commentary.setCommentaryText(TEST_COMMENTARY_TEXT);
		commentary.setCommentaryReason(TEST_COMMENTARY_REASON);
		commentary.setEffectiveBeginDate(TEST_EFFECTIVE_BEGIN_DATE);
		commentary.setEffectiveEndDate(TEST_EFFECTIVE_END_DATE);
		commentary.setLastUpdatedDate(TEST_UPDATED_DATE);
		commentary.setLastUpdatedUserId(TEST_UPDATED_USER);
		
		assertEquals(commentary.getId(), TEST_ID);
		assertEquals(commentary.getPortfolioId(), TEST_PORTFOLIO_ID);
		assertEquals(commentary.getEffectiveDate(), TEST_EFFECTIVE_DATE);
		assertEquals(commentary.getCommentaryText(), TEST_COMMENTARY_TEXT);
		assertEquals(commentary.getCommentaryReason(), TEST_COMMENTARY_REASON);
		assertEquals(commentary.getEffectiveBeginDate(), TEST_EFFECTIVE_BEGIN_DATE);
		assertEquals(commentary.getEffectiveEndDate(), TEST_EFFECTIVE_END_DATE);
		assertEquals(TEST_UPDATED_DATE, commentary.getLastUpdatedDate());
		assertEquals(TEST_UPDATED_USER, commentary.getLastUpdatedUserId());
	}

}


	CommentaryParmsTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.commentary;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryParameters;

public class CommentaryParmsTest {

	private CommentaryParameters classUnderTest = new CommentaryParameters();

	@Test
	public void parametersHasPortId() {
		String portId = "ABC123";
		classUnderTest.setPortId(portId);
		assertEquals(portId, classUnderTest.getPortId());
	}

	@Test
	public void parametersHasAsOfDate() {
		String asOfDate = "2017-09-11";
		classUnderTest.setAsOfDate(asOfDate);
		assertEquals(asOfDate, classUnderTest.getAsOfDate());
	}
}


	CommentaryServiceFunctionalityTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.commentary;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.impl.repository.TestCommentaryRepository;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.service.impl.CommentaryServiceImpl;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

public class CommentaryServiceFunctionalityTest {

	@InjectMocks
	CommentaryServiceImpl commentaryService = new CommentaryServiceImpl();

	@Spy
	TestCommentaryRepository testCommentaryRepository = new TestCommentaryRepository();

	private CommentaryDTO existingCommentary;
	private final DateParser dateParser = new DateParser();

	private static final String AS_OF_DATE = "2017-09-25";
	private static final String PORT_ID = "ONE88";
	private static final String COMMENTARY_TXT = "This is sample commentary";
	
	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);

		testCommentaryRepository.testCommentaryEntity.setEffectiveDate(dateParser.parse(AS_OF_DATE));
		testCommentaryRepository.testCommentaryEntity.setPortfolioId(PORT_ID);
		testCommentaryRepository.testCommentaryEntity.setCommentaryText(COMMENTARY_TXT);
		
		existingCommentary = new CommentaryDTO();

		existingCommentary.setAsOfDate(AS_OF_DATE);
		existingCommentary.setPortId(PORT_ID);
		existingCommentary.setCommentary(COMMENTARY_TXT);
	}

	@Test
	public void serviceReturnsExistingCommentaryThatMatchesGivenDateAndPortId() {

		CommentaryDTO commentary = commentaryService.getCommentary(PORT_ID, dateParser.parse(AS_OF_DATE));

		assertNotNull(commentary);
		assertEquals(dateParser.parse(AS_OF_DATE).toString(), commentary.getAsOfDate());
		assertEquals(PORT_ID, commentary.getPortId());
		assertEquals(COMMENTARY_TXT, commentary.getCommentary());
	}

	@Test
	public void serviceReturnsNullWhenNoMatchForGivenDateAndPortId() {
		when(testCommentaryRepository.findByAsOfDateAndPortId(dateParser.parse(AS_OF_DATE), PORT_ID)).thenReturn(null);
		
		CommentaryDTO commentary = commentaryService.getCommentary(PORT_ID, dateParser.parse(AS_OF_DATE));

		assertNull(commentary);
	}
	
	@Test
	public void serviceUpdatesExistingCommentaryForGivenDateAndPortId() {
		commentaryService.saveOrUpdateCommentary(existingCommentary);
		
		assertEquals(dateParser.parse(AS_OF_DATE), testCommentaryRepository.testCommentaryEntity.getEffectiveDate());
		assertEquals(PORT_ID, testCommentaryRepository.testCommentaryEntity.getPortfolioId());
		assertEquals(COMMENTARY_TXT, testCommentaryRepository.testCommentaryEntity.getCommentaryText());
	}
	
	@Test
	public void serviceInsertsNewCommentaryWhenThereIsNoExistingCommentaryForGivenDateAndPortId() {
		String date = "2000-01-01";
		String portId = "ABC123";
		String text = "Hi!  I'm a comment!";
		
		when(testCommentaryRepository.findByAsOfDateAndPortId(dateParser.parse(date), portId)).thenReturn(null);
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(date);
		commentary.setPortId(portId);
		commentary.setCommentary(text);
		
		commentaryService.saveOrUpdateCommentary(commentary);
		
		assertEquals(dateParser.parse(date), testCommentaryRepository.testCommentaryEntity.getEffectiveDate());
		assertEquals(portId, testCommentaryRepository.testCommentaryEntity.getPortfolioId());
		assertEquals(text, testCommentaryRepository.testCommentaryEntity.getCommentaryText());
	}
	

}

com.vanguard.corp.ics.sdt.behaviors.datatransfer

	DataTransferEndpointTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.datatransfer;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import org.junit.Before;
import org.junit.Test;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.test.characteristics.DataTransferServiceApplicationTester;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

public class DataTransferEndpointTest extends DataTransferServiceApplicationTester {

	private DataTransferService mockService;

	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		mockService = this.getMockService();
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateParameter() throws ParseException {
		String asOf = "2017-07-04";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(eq(asOfDate), isNull(), isNull(), eq(userId), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), isNull(), isNull(), eq(userId), nullable(HttpServletRequest.class));
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateAndPortIdParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(eq(asOfDate), eq(portId), isNull(), eq(userId), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), eq(portId), isNull(), eq(userId), nullable(HttpServletRequest.class));
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateAndDataSetParameters() throws ParseException {
		String asOf = "2017-07-04";
		String dataSet = DataSetType.CHARACTERISTICS.toString();
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		DataSetType dataSetType = DataSetType.valueOf(dataSet);
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(eq(asOfDate), isNull(), eq(dataSetType), eq(userId), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, dataSet);
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), isNull(), eq(dataSetType), eq(userId), nullable(HttpServletRequest.class));
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateAndPortIdAndDataSetParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String dataSet = DataSetType.CHARACTERISTICS.toString();
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		DataSetType dataSetType = DataSetType.valueOf(dataSet);
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(eq(asOfDate), eq(portId), eq(dataSetType), eq(userId), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, dataSet);
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), eq(portId), eq(dataSetType), eq(userId), nullable(HttpServletRequest.class));
	}
	
	@Test
	public void asOfDateIsRequired() {
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));
		
		WebTarget webTarget = this.target(DataTransferResource.PATH);
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));
	}
	
	@Test
	public void asOfDateMustHaveCorrectFormat() {
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));
		
		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "12/31/2016");
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));
	}

	@Test
	public void asOfDateMustBeAnActualDate() {
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-02-29");
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));
	}

	@Test
	public void dataSetMustBeAnActualDataSetType() {
		String userId = "UXYZ";
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-07-04");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, "UNKNOWN_VALUE");
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), eq(userId), any(HttpServletRequest.class));
	}

	@Test
	public void endpointRespondsWithInternalServerErrorIfExceptionsOccurDuringDataTransfer() throws ParseException {
		String asOf = "2017-07-04";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		String userId = "UXYZ";
		doThrow(new RuntimeException()).when(mockService).transfer(eq(asOfDate), isNull(), isNull(), eq(userId), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, userId);
		Response response = builder.get();
		assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());

		verify(mockService, times(1)).transfer(eq(asOfDate), isNull(), isNull(), eq(userId), nullable(HttpServletRequest.class));
	}
}


	DataTransferParmsTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.datatransfer;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;

public class DataTransferParmsTest {

	private DataTransferParameters classUnderTest = new DataTransferParameters();

	@Test
	public void parametersHasPortId() {
		String portId = "ABC123";
		classUnderTest.setPortId(portId);
		assertEquals(portId, classUnderTest.getPortId());
	}

	@Test
	public void parametersHasAsOfDate() {
		String asOfDate = "2017-09-11";
		classUnderTest.setAsOfDate(asOfDate);
		assertEquals(asOfDate, classUnderTest.getAsOfDate());
	}

	@Test
	public void parametersHasDataSetType() {
		String dataSetType = "CHARACTERISTICS";
		classUnderTest.setDataSet(dataSetType);
		assertEquals(dataSetType, classUnderTest.getDataSet());
	}

	@Test
	public void parametersHasUid() {
		String uid = "UABC";
		classUnderTest.setUid(uid);
		assertEquals(uid, classUnderTest.getUid());
	}
}


	DataTransferServiceFunctionalityTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.powermock.reflect.Whitebox;

import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferServiceComparator;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.DataTransferException;
import com.vanguard.corp.ics.sdt.service.impl.DataTransferServiceImpl;


public class DataTransferServiceFunctionalityTest {

	private DataTransferServiceImpl classUnderTest = new DataTransferServiceImpl();
	private List<TransferService> services;
	
	@Mock
	private TransferService mock1;
	
	@Mock
	private TransferService mock2;
	
	@Mock
	private TransferService mock3;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		services = new ArrayList<>();
		services.add(mock1);
		services.add(mock2);
		services.add(mock3);
		Whitebox.setInternalState(classUnderTest, "services", services);
	}

	@Test
	public void serviceCallsMultipleTransferHandlersWhenTheyAgreeToHandleTheRequest() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		String calledByUserId = "UXYZ";
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, calledByUserId, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(1)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
	}

	@Test
	public void serviceCallsOnlyTransferHandlersThatAgreeToHandleTheRequest() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		String calledByUserId = "UXYZ";
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, calledByUserId, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(0)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock3, times(0)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
	}

	@Test
	public void serviceCallsNoTransferHandlersWhenNoneAgreeToHandleTheRequest() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		String calledByUserId = "UXYZ";
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, calledByUserId, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(0)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock2, times(0)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock3, times(0)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
	}

	@Test
	public void servicePrioritizesTransferServicesFromHighestPriorityFirstToLowestPriorityLast() {
		TransferService highest = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.valueOf("HIGHEST"); }
		};
		TransferService high = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.HIGH; }
		};
		TransferService medium = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.MEDIUM; }
		};
		TransferService low = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.LOW; }
		};
		TransferService lowest = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, String calledByUserId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.LOWEST; }
		};
		
		List<TransferService> list = new ArrayList<>();
		list.add(lowest);
		list.add(low);
		list.add(medium);
		list.add(high);
		list.add(highest);
		assertEquals(highest, list.get(4));
		assertEquals(high, list.get(3));
		assertEquals(medium, list.get(2));
		assertEquals(low, list.get(1));
		assertEquals(lowest, list.get(0));
		
		TransferServiceComparator comparator = new TransferServiceComparator();
		Collections.sort(list, comparator);
		assertEquals(highest, list.get(0));
		assertEquals(high, list.get(1));
		assertEquals(medium, list.get(2));
		assertEquals(low, list.get(3));
		assertEquals(lowest, list.get(4));
		
		list.clear();
		list.add(medium);
		list.add(lowest);
		list.add(highest);
		list.add(low);
		list.add(high);
		assertEquals(highest, list.get(2));
		assertEquals(high, list.get(4));
		assertEquals(medium, list.get(0));
		assertEquals(low, list.get(3));
		assertEquals(lowest, list.get(1));
		
		Collections.sort(list, comparator);
		assertEquals(highest, list.get(0));
		assertEquals(high, list.get(1));
		assertEquals(medium, list.get(2));
		assertEquals(low, list.get(3));
		assertEquals(lowest, list.get(4));
	}

	@Test(expected=DataTransferException.class)
	public void serviceLogsCaughtExceptionsAndIndicatesFailureResponse() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		String calledByUserId = "UXYZ";
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenThrow(new RuntimeException());
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, calledByUserId, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(0)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).transfer(any(Date.class), nullable(String.class), eq(calledByUserId), nullable(HttpServletRequest.class));
	}

	@Test(expected=DataTransferException.class)
	public void serviceHandlesExceptionsAndContinuesToProcessDataTransfersBeforeIndicatingFailureResponse() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		String calledByUserId = "UXYZ";
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenThrow(new RuntimeException());
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenThrow(new RuntimeException());
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenThrow(new RuntimeException());
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, calledByUserId, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceRequiresCalledByUserIdParameter() {
		classUnderTest.transfer(null, null, null, null, null);
		
		verify(mock1, never()).getPriority();
		verify(mock2, never()).getPriority();
		verify(mock3, never()).getPriority();
	}
}


com.vanguard.corp.ics.sdt.behaviors.datatransfer.attributionsummary

	AttributionSummaryConversionTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.attributionsummary;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.service.api.constants.AttributionSummaryOrderType;
import com.vanguard.corp.ics.sdt.service.impl.attributionsummary.AttributionSummaryConverter;


public class AttributionSummaryConversionTest {

	private AttributionSummaryConverter converter = new AttributionSummaryConverter();
	
	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfAttributionSummaryListParameterIsNull() {
		converter.convert(null, "abc");
	}

	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfAttributionSummaryListParameterIsEmpty() {
		converter.convert(new ArrayList<AttributionTargetDAO>(), "abc");
	}

	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfAttributionSummaryListParameterContainsNulls() {
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(new AttributionTargetDAO());
		attributionSummaries.add(null);
		attributionSummaries.add(new AttributionTargetDAO());
		converter.convert(attributionSummaries, "abc");
	}

	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfCalledByUserIdParameterIsNull() {
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(new AttributionTargetDAO());
		converter.convert(attributionSummaries, null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfCalledByUserIdParameterIsEmpty() {
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(new AttributionTargetDAO());
		converter.convert(attributionSummaries, "");
	}

	@Test
	public void convertsTargetAttributionSummaryEntitiesIntoReportingAttributionSummaryEntities() {
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		attributionSummaries.add(AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO));
		String calledByUserId = "UXYZ";
		
		@SuppressWarnings("rawtypes")
		List converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		Object ob = converted.get(0);
		assertTrue(ob instanceof AttributionSummary);
	}

	@Test
	public void doesNotCopyPrimaryKey() {
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		attributionSummaries.add(AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO));
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertNull(as.getId());
		assertNotNull(attributionSummaries.get(0).getId());
	}

	@Test
	public void copiesEffectiveDate() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		Date effectiveDate = new Date();
		targetAttributionSummary.setEffectiveDate(effectiveDate);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(effectiveDate, as.getEffectiveDate());
	}

	@Test
	public void copiesPortId() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		String portId = "ABC123";
		targetAttributionSummary.setPortfolioCode(portId);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(portId, as.getPortId());
	}

	@Test
	public void copiesAttributionName() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary =  AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		String name = "big fancy name";
		targetAttributionSummary.setAttrtnName(name);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(name, as.getName());
	}

	@Test
	public void copiesOneMonthValue() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","1MON", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(val, as.getOneMonthVal());
	}

	@Test
	public void copiesThreeMonthValue() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(val, as.getThreeMonthVal());
	}

	@Test
	public void copiesSixMonthValue() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","6MON", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(val, as.getSixMonthVal());
	}

	@Test
	public void copiesNineMonthValue() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","9MON", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(val, as.getNineMonthVal());
	}

	@Test
	public void copiesTwelveMonthValue() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","12MO", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(val, as.getTwelveMonthVal());
	}

	@Test
	public void copiesYearToDateValue() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","CYTD", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(val, as.getYearToDateVal());
	}

	@Test
	public void copiesCalledByUserId() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		BigDecimal val = BigDecimal.valueOf(1.23456);
		targetAttributionSummary.setAttrtnTypeVal(val);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(calledByUserId, as.getLastUpdatedUserId());
	}

	@Test
	public void doesNotSetLastUpdatedTimestamp() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertNull(as.getLastUpdatedDate());
	}

	@Test
	public void doesNotSetEffectiveBeginDate() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertNull(as.getEffectiveBeginDate());
	}

	@Test
	public void doesNotSetEffectiveEndDate() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertNull(as.getEffectiveEndDate());
	}

	@Test
	public void assignsAppropriateDisplayOrderForRecognizedAttributionNames() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		String name = AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(1, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(2, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(3, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(4, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.TRADING_COST.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(5, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(6, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(7, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(8, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(9, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(10, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(11, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(12, as.getDisplayOrder().intValue());
		
		name = AttributionSummaryOrderType.RESIDUAL.getAttributionName();
		targetAttributionSummary.setAttrtnName(name);
		converted = converter.convert(attributionSummaries, calledByUserId);
		as = converted.get(0);
		assertEquals(13, as.getDisplayOrder().intValue());
	}

	@Test
	public void assignsHighValueForDisplayOrderForUnrecognizedAttributionNames() {
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO targetAttributionSummary = AttributionSummaryTestHelper.buildAttributionSummary(new Date(), "portId", "name","3MON", 10,datasourceFileDAO);
		String name = "Super Fun Attribution Name";
		targetAttributionSummary.setAttrtnName(name);
		
		List<AttributionTargetDAO> attributionSummaries = new ArrayList<>();
		attributionSummaries.add(targetAttributionSummary);
		String calledByUserId = "UXYZ";
		
		List<AttributionSummary> converted = converter.convert(attributionSummaries, calledByUserId);
		assertFalse(converted.isEmpty());
		
		AttributionSummary as = converted.get(0);
		assertEquals(99, as.getDisplayOrder().intValue());
	}
}


	AttributionSummaryDataTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.attributionsummary;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.math.BigDecimal;
import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;

public class AttributionSummaryDataTest {
	
	private AttributionSummary classUnderTest = new AttributionSummary();

	
	@Test
	public void attributionSummaryHasAttributionSummaryId() {
		final Long id = Long.valueOf(123L);
		classUnderTest.setId(id);
		assertEquals(id, classUnderTest.getId());
	}
	
	@Test
	public void AttributionSummaryHasDataSrcFileId() {
		final Long id = Long.valueOf(123L);
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(id);
		classUnderTest.setDatasourceFileDAO(datasourceFileDAO);
		assertEquals(datasourceFileDAO, classUnderTest.getDatasourceFileDAO());
	}
	
	
	@Test
	public void attributeSummaryHasPortId() {
		String portId = "PORT_ID";
		classUnderTest.setPortId(portId);
		assertEquals(classUnderTest.getPortId(), portId );
	}

	@Test
	public void attributeSummaryHasEffectiveDates() {
		Calendar cal = Calendar.getInstance();
		final Date effectiveEnd = cal.getTime();
		cal.add(Calendar.YEAR, -1); // last year
		final Date effectiveBegin = cal.getTime();
		assertNotEquals(effectiveBegin, effectiveEnd);
		
		classUnderTest.setEffectiveBeginDate(effectiveBegin);
		classUnderTest.setEffectiveEndDate(effectiveEnd);
		classUnderTest.setEffectiveDate(effectiveBegin);
		assertEquals(effectiveBegin, classUnderTest.getEffectiveBeginDate());
		assertEquals(effectiveEnd, classUnderTest.getEffectiveEndDate());
		assertEquals(effectiveBegin, classUnderTest.getEffectiveDate());
	}

	@Test
	public void attributeSummaryHasName() {
		String name = "TEST_NAME";
		classUnderTest.setName(name);
		assertEquals(classUnderTest.getName(), name );
	}

	@Test
	public void attributeSummaryHasOneMonthVal() {
		final BigDecimal oneMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setOneMonthVal(oneMonthVal);
		assertEquals(oneMonthVal, classUnderTest.getOneMonthVal());
	}

	@Test
	public void attributeSummaryHasThreeMonthVal() {
		final BigDecimal threeMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setThreeMonthVal(threeMonthVal);
		assertEquals(threeMonthVal, classUnderTest.getThreeMonthVal());
	}

	@Test
	public void attributeSummaryHasSixMonthVal() {
		final BigDecimal sixMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setSixMonthVal(sixMonthVal);
		assertEquals(sixMonthVal, classUnderTest.getSixMonthVal());
	}

	@Test
	public void attributeSummaryHasNineMonthVal() {
		final BigDecimal nineMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setNineMonthVal(nineMonthVal);
		assertEquals(nineMonthVal, classUnderTest.getNineMonthVal());
	}

	@Test
	public void attributeSummaryHasTwelveMonthVal() {
		final BigDecimal twelveMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setTwelveMonthVal(twelveMonthVal);
		assertEquals(twelveMonthVal, classUnderTest.getTwelveMonthVal());
	}

	@Test
	public void attributeSummaryHasYearToDateVal() {
		final BigDecimal yearToDate = new BigDecimal("1234567890.12345");
		classUnderTest.setYearToDateVal(yearToDate);
		assertEquals(yearToDate, classUnderTest.getYearToDateVal());
	}

	@Test
	public void attributeSummaryHasLastUpdatedUserId() {
		String name = "TEST_NAME";
		classUnderTest.setLastUpdatedUserId(name);
		assertEquals(classUnderTest.getLastUpdatedUserId(), name );
	}

	@Test
	public void attributeSummaryHasLastUpdatedDate() {
		Calendar cal = Calendar.getInstance();
		final Date lastUpdatedDate = cal.getTime();
		classUnderTest.setLastUpdatedDate(lastUpdatedDate);
		assertEquals(lastUpdatedDate, classUnderTest.getLastUpdatedDate());
	}

	@Test
	public void attributeSummaryHasDisplayOrder() {
		final Integer displayOrder = 1;
		classUnderTest.setDisplayOrder(displayOrder);
		assertEquals(displayOrder, classUnderTest.getDisplayOrder());
	}
	
	@Test
	public void attributeSummaryHasDatasourceFileDao() {
		final DatasourceFileDAO datasourceFileDao = new DatasourceFileDAO();
		classUnderTest.setDatasourceFileDAO(datasourceFileDao);
		assertEquals(datasourceFileDao, classUnderTest.getDatasourceFileDAO());
	}

}


	AttributionSummaryTestHelper.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.attributionsummary;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.service.api.constants.AttributionSummaryOrderType;

public class AttributionSummaryTestHelper {

	public static List<AttributionTargetDAO> buildAttributionSummaryTargetList(final Date effectiveDate,
			final String portId) {
		List<AttributionTargetDAO> attributionTargetDAO = new ArrayList<>();
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName(), "1MON", Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName(), "1MON", Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName(), "1MON", Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName(), "1MON", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.TRADING_COST.getAttributionName(), "1MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName(), "1MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName(), "1MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName(), "1MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName(), "1MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "1MON", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "1MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "1MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "1MON", 5000, datasourceFileDAO));
		
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName(), "3MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName(), "3MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName(), "3MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName(), "3MON", 100,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.TRADING_COST.getAttributionName(), "3MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName(), "3MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName(), "3MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName(), "3MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName(), "3MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "3MON", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "3MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "3MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "3MON", 5000, datasourceFileDAO));
		
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName(), "6MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName(), "6MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName(), "6MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName(), "6MON", 100,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.TRADING_COST.getAttributionName(), "6MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName(), "6MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName(), "6MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName(), "6MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName(), "6MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "6MON", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "6MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "6MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "6MON", 5000, datasourceFileDAO));
		
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName(), "9MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName(), "9MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName(), "9MON",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName(), "9MON", 100,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.TRADING_COST.getAttributionName(), "9MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName(), "9MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName(), "9MON",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName(), "9MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName(), "9MON", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "9MON", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "9MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "9MON", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "9MON", 5000, datasourceFileDAO));
		
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName(), "12MO",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName(), "12MO",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName(), "12MO",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName(), "12MO", 100,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.TRADING_COST.getAttributionName(), "12MO", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName(), "12MO",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName(), "12MO",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName(), "12MO", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName(), "12MO", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "12MO", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "12MO", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "12MO", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "12MO", 5000, datasourceFileDAO));
		
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName(), "CYTD",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName(), "CYTD",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName(), "CYTD",Integer.MAX_VALUE, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName(), "CYTD", 100,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.TRADING_COST.getAttributionName(), "CYTD", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName(), "CYTD",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName(), "CYTD",5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName(), "CYTD", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName(), "CYTD", 5000,datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "CYTD", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "CYTD", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "CYTD", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "CYTD", 5000, datasourceFileDAO));
		
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName(), "ABCD", 100, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName(), "ABCD", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName(), "ABCD", 5000, datasourceFileDAO));
		attributionTargetDAO.add(buildAttributionSummary(effectiveDate, portId, AttributionSummaryOrderType.RESIDUAL.getAttributionName(), "ABCD", 5000, datasourceFileDAO));
		
		return attributionTargetDAO;
	}

	public static AttributionTargetDAO buildAttributionSummary(final Date effectiveDate, final String portId,
			final String name, final String code, final int max, DatasourceFileDAO datasourceFileDAO) {

		Random generator = new Random((new Date()).getTime());
		AttributionTargetDAO c = new AttributionTargetDAO();
		c.setId(generator.nextLong());
		c.setEffectiveDate(effectiveDate);
		c.setPortfolioCode(portId);
		c.setAttrtnName(name);
		c.setAttrtnTypeCd(code);
		c.setDatasourceFileDAO(datasourceFileDAO);
		c.setAttrtnTypeVal(BigDecimal.valueOf(max));
		return c;
	}

	public BigDecimal getRandomBigDecimal(final int max) {
		Random generator = new Random((new Date()).getTime());
		double val = generator.nextDouble() * 2.0 * (double) max;
		val -= max;
		return new BigDecimal(String.format("%.5f", val));
	}

	public Map<Integer, String> getDisplayOrder() {
		Map<Integer, String> displayOrder = new HashMap<>();
		displayOrder.put(1, AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName());
		displayOrder.put(2, AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName());
		displayOrder.put(3, AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName());
		displayOrder.put(4, AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName());
		displayOrder.put(5, AttributionSummaryOrderType.TRADING_COST.getAttributionName());
		displayOrder.put(6, AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName());
		displayOrder.put(7, AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName());
		displayOrder.put(8, AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName());
		displayOrder.put(9, AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName());
		displayOrder.put(10, AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName());
		displayOrder.put(11, AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName());
		displayOrder.put(12, AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName());
		displayOrder.put(13, AttributionSummaryOrderType.RESIDUAL.getAttributionName());
		displayOrder.put(14, "Fake Attribution Summary");

		return displayOrder;
	}
}


	AttributionSummaryTransferServiceTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.attributionsummary;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Random;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.repository.target.AttributionSummaryTargetRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AttributionSummaryRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadAttributeSummaryException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveAttributeSummaryException;
import com.vanguard.corp.ics.sdt.service.impl.attributionsummary.AttributionSummaryConverter;
import com.vanguard.corp.ics.sdt.service.impl.attributionsummary.AttributionSummaryTransferService;;

@RunWith(MockitoJUnitRunner.class)
public class AttributionSummaryTransferServiceTest {
	@InjectMocks
	private TransferService classUnderTest = new AttributionSummaryTransferService();

	@Mock
	private AttributionSummaryTargetRepository readRepo;

	@Mock
	private AttributionSummaryRepository jpaRepo;

	@Mock
	private AttributionSummaryConverter dataConverter;

	private static final String PORT_ID_1 = "PORT01";

	@Mock
	private HttpServletRequest request;

	@Before
	public void setUp() throws Exception {
	}

	@Test
	public void serviceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, classUnderTest.getPriority());
	}

	@Test
	public void serviceWantsToHandleAttributionSummaryyDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, DataSetType.ATTRIBUTION_SUMMARY, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(classUnderTest.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceDoesNotAcceptNullEffectiveDate() {
		classUnderTest.transfer(null, PORT_ID_1, "abc", request);
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceDoesNotAcceptNullCalledByUserId() {
		classUnderTest.transfer(new Date(), PORT_ID_1, null, request);
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceDoesNotAcceptEmptyCalledByUserId() {
		classUnderTest.transfer(null, PORT_ID_1, "", request);
	}

	@Test
	public void serviceShouldGetDataByEffectiveDateOnlyWhenPortIdIsNull() {
		Date effectiveDate = new Date();
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(new Date(), null, calledByUserId, request);
		verify(readRepo, times(1)).findAllByEffectiveDate(effectiveDate);
	}

	@Test
	public void serviceShouldGetDataByEffectiveDateAndPortIdWhenPortIdIsNotNull() {
		Date effectiveDate = new Date();
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(new Date(), PORT_ID_1, calledByUserId, request);
		verify(readRepo, times(1)).findAllByEffectiveDateAndPortfolioCode(effectiveDate, PORT_ID_1);
	}

	@Test(expected = ReadAttributeSummaryException.class)
	public void serviceShouldThrowReadCharacteristicsExceptionWithInvalidEffectiveDate() {
		Date invalidEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		when(readRepo.findAllByEffectiveDate(invalidEffectiveDate)).thenThrow(Exception.class);
		classUnderTest.transfer(invalidEffectiveDate, null, calledByUserId, request);
	}

	@Test(expected = ReadAttributeSummaryException.class)
	public void serviceShouldThrowReadAttributionExceptionWithInvalidPortId() {
		Date validEffectiveDate = new Date();
		String invalidPortId = "INVALID_PORT_ID";
		String calledByUserId = "UXYZ";
		when(readRepo.findAllByEffectiveDateAndPortfolioCode(validEffectiveDate, invalidPortId))
				.thenThrow(Exception.class);
		classUnderTest.transfer(validEffectiveDate, invalidPortId, calledByUserId, request);
	}

	@Test
	public void serviceShouldFetchDataWithvalidEffectiveDate() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<AttributionTargetDAO> attributionSummaryDAOs = Arrays.asList(new AttributionTargetDAO());
		when(readRepo.findAllByEffectiveDate(validEffectiveDate)).thenReturn(attributionSummaryDAOs);
		classUnderTest.transfer(validEffectiveDate, null, calledByUserId, request);
		verify(readRepo, times(1)).findAllByEffectiveDate(validEffectiveDate);
	}

	@Test(expected = SaveAttributeSummaryException.class)
	public void serviceShouldThrowExceptionWhenDataWriteFails() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		AttributionTargetDAO attributionSummaryDAO = new AttributionTargetDAO();
		attributionSummaryDAO.setEffectiveDate(validEffectiveDate);
		attributionSummaryDAO.setPortfolioCode(PORT_ID_1);
		List<AttributionTargetDAO> attributionSummaryDAOs = Arrays.asList(attributionSummaryDAO);
		when(readRepo.findAllByEffectiveDateAndPortfolioCode(validEffectiveDate, PORT_ID_1))
				.thenReturn(attributionSummaryDAOs);
		AttributionSummary attributionSummary = new AttributionSummary();
		attributionSummary.setEffectiveDate(validEffectiveDate);
		attributionSummary.setPortId(PORT_ID_1);
		List<AttributionSummary> attributionSummaries = Arrays.asList(attributionSummary);
		when(dataConverter.convert(attributionSummaryDAOs, calledByUserId)).thenReturn(attributionSummaries);
		when(jpaRepo.save(attributionSummaries)).thenThrow(Exception.class);
		classUnderTest.transfer(validEffectiveDate, PORT_ID_1, calledByUserId, request);
	}

	@Test
	public void serviceShouldNotCallJpaRepoToSaveDataWhenDataListIsEmpty() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<AttributionSummary> attributionSummaries = new ArrayList<>();
		classUnderTest.transfer(validEffectiveDate, null, calledByUserId, request);
		verify(jpaRepo, times(0)).save(attributionSummaries);
	}

	@Test
	public void serviceShouldExecuteLogicalDelete() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		AttributionTargetDAO attributionSummaryDAO = new AttributionTargetDAO();
		attributionSummaryDAO.setEffectiveDate(validEffectiveDate);
		attributionSummaryDAO.setPortfolioCode(PORT_ID_1);
		List<AttributionTargetDAO> attributionSummaryDAOs = Arrays.asList(attributionSummaryDAO);
		AttributionSummary attributionSummary = new AttributionSummary();
		attributionSummary.setEffectiveDate(validEffectiveDate);
		attributionSummary.setPortId(PORT_ID_1);
		List<AttributionSummary> attributionSummaries = Arrays.asList(attributionSummary);
		when(readRepo.findAllByEffectiveDateAndPortfolioCode(validEffectiveDate, PORT_ID_1))
				.thenReturn(attributionSummaryDAOs);
		when(dataConverter.convert(attributionSummaryDAOs, calledByUserId)).thenReturn(attributionSummaries);
		when(jpaRepo.findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(validEffectiveDate, PORT_ID_1))
				.thenReturn(attributionSummaries);
		classUnderTest.transfer(validEffectiveDate, PORT_ID_1, calledByUserId, request);
		verify(jpaRepo, times(1)).save(attributionSummaries);
	}

	@Test
	public void serviceShouldConvertAttributionSummaryDAOToAttributionSummary() {
		AttributionSummaryConverter converter = new AttributionSummaryConverter();
		Date validEffectiveDate = null;
		String calledByUserId = "UXYZ";
		AttributionTargetDAO attributionTargetDAO = new AttributionTargetDAO();
		attributionTargetDAO.setId(new Random().nextLong());
		attributionTargetDAO.setEffectiveDate(validEffectiveDate);
		attributionTargetDAO.setPortfolioCode(PORT_ID_1);
		attributionTargetDAO.setAttrtnName("FAKE");
		attributionTargetDAO.setAttrtnTypeCd("CYTD");
		attributionTargetDAO.setAttrtnTypeVal(BigDecimal.ONE);

		attributionTargetDAO.setUpdatedUser("FAKE");
		attributionTargetDAO.setUpdatedDate(validEffectiveDate);
		List<AttributionTargetDAO> attributionSummaryDAOs = Arrays.asList(attributionTargetDAO);
		List<AttributionSummary> attributionSummaries = converter.convert(attributionSummaryDAOs, calledByUserId);

		for (AttributionSummary summary : attributionSummaries) {
			assertEquals(summary.getEffectiveDate(), validEffectiveDate);
			assertEquals(summary.getPortId(), PORT_ID_1);
			assertEquals(summary.getName(), "FAKE");
			assertEquals(summary.getOneMonthVal(), null);
			assertEquals(summary.getThreeMonthVal(), null);
			assertEquals(summary.getSixMonthVal(), null);
			assertEquals(summary.getNineMonthVal(), null);
			assertEquals(summary.getTwelveMonthVal(), null);
			assertEquals(summary.getYearToDateVal(), BigDecimal.ONE);
			assertEquals(summary.getEffectiveBeginDate(), validEffectiveDate);
			assertEquals(summary.getEffectiveEndDate(), validEffectiveDate);
			assertEquals(summary.getLastUpdatedUserId(), "UXYZ");
			assertEquals(summary.getLastUpdatedDate(), validEffectiveDate);
		}
	}

	@Test
	public void serviceShouldAddDisplayOrderingToAttributionSummaryWithValidNames() {
		AttributionSummaryConverter converter = new AttributionSummaryConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<AttributionTargetDAO> attributionSummaryDAOs = AttributionSummaryTestHelper
				.buildAttributionSummaryTargetList(validEffectiveDate, PORT_ID_1);
		List<AttributionSummary> attributionSummaries = converter.convert(attributionSummaryDAOs, calledByUserId);
		Comparator<AttributionSummary> comparator = new Comparator<AttributionSummary>() {
			@Override
			public int compare(AttributionSummary o1, AttributionSummary o2) {
				return o1.getDisplayOrder().compareTo(o2.getDisplayOrder());
			}
		};
		Collections.sort(attributionSummaries, comparator);
		AttributionSummaryTestHelper attributionHelper = new AttributionSummaryTestHelper();
		Map<Integer, String> displayOrder = attributionHelper.getDisplayOrder();
		Integer i = 1;
		for(AttributionSummary summary : attributionSummaries){
			assertEquals(i, summary.getDisplayOrder());
			assertEquals(displayOrder.get(summary.getDisplayOrder()), summary.getName());
			i++;
		}
	}

	@Test
	public void serviceShouldAddDisplayOrderingToAttributionSummaryWithInValidNames() {
		AttributionSummaryConverter converter = new AttributionSummaryConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<AttributionTargetDAO> attributionSummaryDAOs = new ArrayList<>();
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		attributionSummaryDAOs.add(AttributionSummaryTestHelper.buildAttributionSummary(validEffectiveDate, PORT_ID_1,
				"INVALID_NAME", "CYTD", 5000, datasourceFileDAO));
		List<AttributionSummary> attributionSummaries = converter.convert(attributionSummaryDAOs, calledByUserId);
		Comparator<AttributionSummary> comparator = new Comparator<AttributionSummary>() {
			@Override
			public int compare(AttributionSummary o1, AttributionSummary o2) {
				return o1.getDisplayOrder().compareTo(o2.getDisplayOrder());
			}
		};
		Collections.sort(attributionSummaries, comparator);
		AttributionSummaryTestHelper attributionHelper = new AttributionSummaryTestHelper();
		Map<Integer, String> displayOrder = attributionHelper.getDisplayOrder();
		for (int i = 0; i < attributionSummaries.size(); i++) {
			assertEquals(new Integer(99), attributionSummaries.get(i).getDisplayOrder());
			assertNull(displayOrder.get(attributionSummaries.get(i).getDisplayOrder()));
		}
	}

}


		AttributionTargetDAOTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.attributionsummary;

import static org.junit.Assert.assertEquals;

import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;

public class AttributionTargetDAOTest {

	private AttributionTargetDAO dao = new AttributionTargetDAO();

	@Test
	public void testForCoverage() {
		String lastUpdatedUserId = "ABCD";
		Calendar c = Calendar.getInstance();
		c.add(Calendar.MONTH, -1);
		c.add(Calendar.MONTH, -1);
		Date lastUpdatedDate = c.getTime();

		dao.setUpdatedUser(lastUpdatedUserId);
		assertEquals(lastUpdatedUserId, dao.getUpdatedUser());

		dao.setUpdatedDate(lastUpdatedDate);
		assertEquals(lastUpdatedDate, dao.getUpdatedDate());
	}

}


com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics

	CharacteristicsConversionTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.constants.MarketSegmentationType;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.test.characteristics.FactsetMonthlyCharacteristicsTargetDAOBuilder;

public class CharacteristicsConversionTest {

	private FactsetMonthlyCharacteristicsTargetDAOBuilder targetBuilder = new FactsetMonthlyCharacteristicsTargetDAOBuilder();
	private CharacteristicsConverter converter = new CharacteristicsConverter.Impl();

	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfTargetCharacteristicsIsNull() {
		converter.convert(null, "abc");
	}

	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfCalledByUserIdIsNull() {
		converter.convert(new FactsetMonthlyCharacteristicsTargetDAO(), null);
	}
	
	@Test(expected=IllegalArgumentException.class)
	public void throwsExceptionIfCalledByUserIdIsEmpty() {
		converter.convert(new FactsetMonthlyCharacteristicsTargetDAO(), "");
	}

	@Test
	public void convertsTargetCharacteristicsIntoReportingCharacteristics() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.valueOf("COUNTRY_ALLOCATION").getTargetCode(), "A", "1.23456", "7.89012");
		Object converted = converter.convert(dao, "abc");
		assertTrue(converted instanceof Characteristics);
	}

	@Test
	public void copiesCalledByUserId() {
		String calledByUserId = "UXYZ";
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.valueOf("COUNTRY_ALLOCATION").getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, calledByUserId);
		assertEquals(calledByUserId, converted.getLastUpdatedUserId());
	}

	@Test
	public void copiesEffectiveDate() {
		Date now = new Date();
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(now, "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(now, converted.getEffectiveDate());
	}

	@Test
	public void copiesPortId() {
		String portId = "ABCDEF";
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), portId, CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(portId, converted.getPortId());
	}

	@Test
	public void copiesCharacteristicName() {
		String name = "ABCDEF";
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), name, "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(name, converted.getName());
	}

	@Test
	public void copiesPortfolioValueIfNull() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", null, "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertNull(converted.getPortfolio());
	}

	@Test
	public void roundsPortfolioValueToOneDecimalPrecision() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(new BigDecimal("1.2"), converted.getPortfolio());
	}

	@Test
	public void copiesBenchmarkValueIfNull() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", null);
		Characteristics converted = converter.convert(dao, "abc");
		assertNull(converted.getBenchmark());
	}

	@Test
	public void roundsBenchmarkValueToOneDecimalPrecision() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(new BigDecimal("7.9"), converted.getBenchmark());
	}

	@Test
	public void convertsCountryCode() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.COUNTRY_ALLOCATION.getReportingCode(), converted.getType());
	}

	@Test
	public void convertsCurencyCode() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.CURRENCY_ALLOCATION.getReportingCode(), converted.getType());
	}

	@Test
	public void convertsRegionalCode() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.REGIONAL_ALLOCATION.getReportingCode(), converted.getType());
	}

	@Test
	public void convertsSectorCode() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.SECTOR_ALLOCATION.getReportingCode(), converted.getType());
	}

	@Test
	public void convertsTopTenHoldingsCode() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.TOP_TEN_HOLDINGS.getReportingCode(), converted.getType());
	}

	@Test
	public void convertsMarketSegmentationCodeWhenNameIsIdentifiableAsMarketSegmentationName() {
		String name = MarketSegmentationType.valueOf("LARGE").getTargetName();
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), name, "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode(), converted.getType());
		assertEquals("Large", converted.getName());
		
		name = MarketSegmentationType.MEDIUM_LARGE.getTargetName();
		converted = converter.convert(targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), name, "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode(), converted.getType());
		assertEquals("Large/Medium", converted.getName());
		
		name = MarketSegmentationType.MEDIUM.getTargetName();
		converted = converter.convert(targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), name, "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode(), converted.getType());
		assertEquals("Medium", converted.getName());
		
		name = MarketSegmentationType.MEDIUM_SMALL.getTargetName();
		converted = converter.convert(targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), name, "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode(), converted.getType());
		assertEquals("Small/Medium", converted.getName());
		
		name = MarketSegmentationType.SMALL.getTargetName();
		converted = converter.convert(targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), name, "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode(), converted.getType());
		assertEquals("Small", converted.getName());
	}

	@Test
	public void convertsPortfolioCharacteristicsCodeWhenNameIsNotIdentifiableAsMarketSegmentationName() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getReportingCode(), converted.getType());
		assertEquals("A", converted.getName());
		
		converted = converter.convert(targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "", "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getReportingCode(), converted.getType());
		assertEquals("", converted.getName());
		
		converted = converter.convert(targetBuilder.build(new Date(), "1", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), null, "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getReportingCode(), converted.getType());
		assertNull(converted.getName());
	}

	@Test
	public void convertsUnrecognizedCodeIntoUnknown() {
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", null, "A", "1.23456", "7.89012");
		Characteristics converted = converter.convert(dao, "abc");
		assertEquals(CharacteristicsType.UNKNOWN.getReportingCode(), converted.getType());
		
		converted = converter.convert(targetBuilder.build(new Date(), "1", "", "", "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.UNKNOWN.getReportingCode(), converted.getType());
		
		converted = converter.convert(targetBuilder.build(new Date(), "1", "lkasdgr#$g121t2AEWFA23", "", "1.23456", "7.89012"), "abc");
		assertEquals(CharacteristicsType.UNKNOWN.getReportingCode(), converted.getType());
	}

	@Test
	public void doNotCopyTargetTablePrimaryKeyIntoReportingTablePrimaryKeyField() {
		Long id = Long.valueOf(123L);
		
		FactsetMonthlyCharacteristicsTargetDAO dao = targetBuilder.build(new Date(), "1", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "A", "1.23456", "7.89012");
		dao.setId(id);
		
		Characteristics converted = converter.convert(dao, "abc");
		assertNull(converted.getId());
		assertEquals(id, dao.getId());
	}
}


	CharacteristicsDataTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics;

import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.util.SafeCopy;
import com.vanguard.corp.ics.sdt.test.characteristics.CharacteristicsBuilder;

public class CharacteristicsDataTest {

	private Characteristics classUnderTest = new Characteristics();

	@Test
	public void characteristicsHasCharacteristicsId() {
		final Long id = Long.valueOf(123L);
		classUnderTest.setId(id);
		assertEquals(id, classUnderTest.getId());
	}
	
	@Test
	public void characteristicsHasPortId() {
		final String portId = "ABC123";
		classUnderTest.setPortId(portId);
		assertEquals(portId, classUnderTest.getPortId());
	}
	
	@Test
	public void characteristicsHasAsOfDate() {
		final Date asOfDate = new Date();
		classUnderTest.setEffectiveDate(asOfDate);
		assertEquals(asOfDate, classUnderTest.getEffectiveDate());
		assertNotSame(asOfDate, classUnderTest.getEffectiveDate());
		SafeCopy stupidCoverageThing = new SafeCopy();
		assertNotNull(stupidCoverageThing);
	}
	
	@Test
	public void characteristicsHasCharacteristicsTypeCode() {
		final String charType = "ABCDEFG";
		classUnderTest.setType(charType);
		assertEquals(charType, classUnderTest.getType());
	}
	
	@Test
	public void characteristicsHasCharacteristicsName() {
		final String name = "ABCabc123!@# asdf";
		classUnderTest.setName(name);
		assertEquals(name, classUnderTest.getName());
	}
	
	@Test
	public void characteristicsHasPortfolioValue() {
		final BigDecimal portfolioValue = new BigDecimal("1234567890.12345");
		classUnderTest.setPortfolio(portfolioValue);
		assertEquals(portfolioValue, classUnderTest.getPortfolio());
	}
	
	@Test
	public void characteristicsHasBenchmarkValue() {
		final BigDecimal benchmarkValue = new BigDecimal("9876543210.12345");
		classUnderTest.setBenchmark(benchmarkValue);
		assertEquals(benchmarkValue, classUnderTest.getBenchmark());
	}
	
	@Test
	public void characteristicsHasEffectiveBeginAndEndDates() {
		Calendar cal = Calendar.getInstance();
		final Date effectiveEnd = cal.getTime();
		cal.add(Calendar.YEAR, -1); // last year
		final Date effectiveBegin = cal.getTime();
		assertNotEquals(effectiveBegin, effectiveEnd);
		
		classUnderTest.setEffectiveBeginDate(effectiveBegin);
		classUnderTest.setEffectiveEndDate(effectiveEnd);
		assertEquals(effectiveBegin, classUnderTest.getEffectiveBeginDate());
		assertNotSame(effectiveBegin, classUnderTest.getEffectiveBeginDate());
		assertEquals(effectiveEnd, classUnderTest.getEffectiveEndDate());
		assertNotSame(effectiveEnd, classUnderTest.getEffectiveEndDate());
	}
	
	@Test
	public void characteristicsHasLastUpdatedUserAndTimestamp() {
		final Date lastUpdatedDate = new Date();
		final String lastUpdatedUser = "UGLY";
		classUnderTest.setLastUpdatedDate(lastUpdatedDate);
		classUnderTest.setLastUpdatedUserId(lastUpdatedUser);
		assertEquals(lastUpdatedDate, classUnderTest.getLastUpdatedDate());
		assertNotSame(lastUpdatedDate, classUnderTest.getLastUpdatedDate());
		assertEquals(lastUpdatedUser, classUnderTest.getLastUpdatedUserId());
	}
	
	@Test
	public void characteristicsHasDatasourceFileDao() {
		final DatasourceFileDAO datasourceFileDao = new DatasourceFileDAO();
		classUnderTest.setDatasourceFileDAO(datasourceFileDao);
		assertEquals(datasourceFileDao, classUnderTest.getDatasourceFileDAO());
	}

	@Test
	public void characteristicsOverridesEquals() {
		CharacteristicsBuilder builder = new CharacteristicsBuilder();
		
		Calendar calendar = Calendar.getInstance();
		Date date1 = calendar.getTime();
		calendar.add(Calendar.MONTH, -1);
		Date date2 = calendar.getTime();
		
		Characteristics c1 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertTrue(c1.equals(c1));
		assertFalse(c1.equals(null));
		assertFalse(c1.equals(new Object()));
		
		Characteristics c2 = builder.build(date2, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertFalse(c1.equals(c2));
		
		Characteristics c3 = builder.build(date1, "2", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertFalse(c1.equals(c3));
		
		Characteristics c4 = builder.build(date1, "1", CharacteristicsType.CURRENCY_ALLOCATION, "A", "1.1", "1.2");
		assertFalse(c1.equals(c4));
		
		Characteristics c5 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "B", "1.1", "1.2");
		assertFalse(c1.equals(c5));
		
		Characteristics c6 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "0.1", "1.2");
		assertFalse(c1.equals(c6));
		
		Characteristics c7 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "0.2");
		assertFalse(c1.equals(c7));
		
		Characteristics c8 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, null, "1.1", "1.2");
		assertFalse(c1.equals(c8));
		
		Characteristics c9 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", null, "1.2");
		assertFalse(c1.equals(c9));
		
		Characteristics c10 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", null);
		assertFalse(c1.equals(c10));
		
		Characteristics c11 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertTrue(c1.equals(c11));
	}

	@Test
	public void characteristicsOverridesHashCode() {
		CharacteristicsBuilder builder = new CharacteristicsBuilder();
		
		Calendar calendar = Calendar.getInstance();
		Date date1 = calendar.getTime();
		calendar.add(Calendar.MONTH, -1);
		Date date2 = calendar.getTime();
		
		Characteristics c1 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertTrue(c1.hashCode() == c1.hashCode());
		
		Characteristics c2 = builder.build(date2, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertFalse(c1.hashCode() == c2.hashCode());
		
		Characteristics c3 = builder.build(date1, "2", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertFalse(c1.hashCode() == c3.hashCode());
		
		Characteristics c4 = builder.build(date1, "1", CharacteristicsType.CURRENCY_ALLOCATION, "A", "1.1", "1.2");
		assertFalse(c1.hashCode() == c4.hashCode());
		
		Characteristics c5 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "B", "1.1", "1.2");
		assertFalse(c1.hashCode() == c5.hashCode());
		
		Characteristics c6 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "0.1", "1.2");
		assertFalse(c1.hashCode() == c6.hashCode());
		
		Characteristics c7 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "0.2");
		assertFalse(c1.hashCode() == c7.hashCode());
		
		Characteristics c8 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, null, "1.1", "1.2");
		assertFalse(c1.hashCode() == c8.hashCode());
		
		Characteristics c9 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", null, "1.2");
		assertFalse(c1.hashCode() == c9.hashCode());
		
		Characteristics c10 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", null);
		assertFalse(c1.hashCode() == c10.hashCode());
		
		Characteristics c11 = builder.build(date1, "1", CharacteristicsType.COUNTRY_ALLOCATION, "A", "1.1", "1.2");
		assertTrue(c1.hashCode() == c11.hashCode());
	}
}


	CharacteristicsReportingTableDataAccessTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.dao.impl.repository.CharacteristicsRepository;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsHelperService;

public class CharacteristicsReportingTableDataAccessTest {

	@InjectMocks
	private CharacteristicsHelperService classUnderTest = new CharacteristicsHelperService.Impl();

	@Mock
	private CharacteristicsRepository repo;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void systemRetrievesCharacteristicsByAsOfDate() {
		final Date asOfDate = new Date();
		final List<Characteristics> expectedList = new ArrayList<>();

		when(repo.findByEffectiveDate(asOfDate)).thenReturn(expectedList);
		
		List<Characteristics> retrieved = classUnderTest.retrieveAll(asOfDate);
		assertEquals(expectedList, retrieved);
		
		verify(repo, times(1)).findByEffectiveDate(asOfDate);
	}

	@Test
	public void systemRetrievesCharacteristicsByAsOfDateAndPortId() {
		final Date asOfDate = new Date();
		final String portId = "ABC123";
		final List<Characteristics> expectedList = new ArrayList<>();

		when(repo.findByEffectiveDateAndPortId(asOfDate, portId)).thenReturn(expectedList);
		
		List<Characteristics> retrieved = classUnderTest.retrieveAll(asOfDate, portId);
		assertEquals(expectedList, retrieved);
		
		verify(repo, times(1)).findByEffectiveDateAndPortId(asOfDate, portId);
	}

	@Test
	public void systemSavesCharacteristicsByLogicallyDeletingAndInsertingNewRows() {
		Date asOfDate = new Date();
		List<Characteristics> expectedList = buildTestCharacteristicsList(asOfDate);
		Characteristics update1 = buildTestCharacteristics(1, asOfDate); // ABC123
		Characteristics update2 = buildTestCharacteristics(2, asOfDate); // ABC123
		Characteristics update3 = buildTestCharacteristics(3, asOfDate); // ABC124
		Characteristics update4 = buildTestCharacteristics(4, asOfDate); // ABC123 (different type)
		Characteristics newchar = buildTestCharacteristics(5, asOfDate); // ABC125

		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "CHARTYPE")).thenReturn(Arrays.asList(update1, update2));
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC124", "CHARTYPE")).thenReturn(Arrays.asList(update3));
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "OTHERTYPE")).thenReturn(Arrays.asList(update4));
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC125", "ANOTHERTYPE")).thenReturn(new ArrayList<>());
		when(repo.save(expectedList)).thenReturn(expectedList);

		List<Characteristics> saved = classUnderTest.saveAll(expectedList);
		assertEquals(expectedList, saved);
		assertNotNull(update1.getEffectiveEndDate());
		assertNotNull(update2.getEffectiveEndDate());
		assertNotNull(update3.getEffectiveEndDate());
		assertNotNull(update4.getEffectiveEndDate());
		assertNull(newchar.getEffectiveEndDate());

		verify(repo, times(4)).findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(any(Date.class), any(String.class), any(String.class));
		verify(repo, times(1)).save(expectedList);
	}
	
	@Test
	public void savingAnEmptyListOfCharacteristicsDoesNotSaveAnything() {
		List<Characteristics> emptyList = new ArrayList<>();
		
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(any(Date.class), any(String.class), any(String.class))).thenThrow(new RuntimeException("should NOT happen"));
		when(repo.save(emptyList)).thenThrow(new RuntimeException("should NOT happen"));
		
		List<Characteristics> saved = classUnderTest.saveAll(emptyList);
		assertEquals(emptyList, saved);
		
		verify(repo, times(0)).findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(any(Date.class), any(String.class), any(String.class));
		verify(repo, times(0)).save(emptyList);
	}

	@Test
	public void systemDeletesCharacteristicsByLogicallyDeleting() {
		Date asOfDate = new Date();
		Characteristics update1 = buildTestCharacteristics(1, asOfDate); // ABC123
		Characteristics update2 = buildTestCharacteristics(2, asOfDate); // ABC123
		
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "CHARTYPE")).thenReturn(Arrays.asList(update1, update2));
		
		classUnderTest.logicalDelete(asOfDate, "ABC123", "CHARTYPE");
		assertNotNull(update1.getEffectiveEndDate());
		assertNotNull(update2.getEffectiveEndDate());
		
		verify(repo, times(1)).findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "CHARTYPE");
	}

	private List<Characteristics> buildTestCharacteristicsList(Date asOfDate) {
		List<Characteristics> list = new ArrayList<>();
		list.add(buildTestCharacteristics(1, asOfDate));
		list.add(buildTestCharacteristics(2, asOfDate));
		list.add(buildTestCharacteristics(3, asOfDate));
		list.add(buildTestCharacteristics(4, asOfDate));
		list.add(buildTestCharacteristics(5, asOfDate));

		return list;
	}

	private Characteristics buildTestCharacteristics(int which, Date asOfDate) {
		Characteristics c = new Characteristics();

		switch (which) {
		case 1:
			c.setName("having");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC123");
			c.setType("CHARTYPE");
			break;

		case 2:
			c.setName("fun");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC123");
			c.setType("CHARTYPE");
			break;

		case 3:
			c.setName("with");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC124");
			c.setType("CHARTYPE");
			break;

		case 4:
			c.setName("easter");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC123");
			c.setType("OTHERTYPE");
			break;

		case 5:
			c.setName("eggs");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC125");
			c.setType("ANOTHERTYPE");
			break;

		default:
		}

		return c;
	}
}


	CharacteristicsTransfersTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.mockito.junit.MockitoJUnitRunner;
import org.powermock.reflect.Whitebox;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsHelperService;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsTransferService;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MagicRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MundaneRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.TopTenHoldingsRounder;
import com.vanguard.corp.ics.sdt.test.characteristics.CharacteristicsBuilder;
import com.vanguard.corp.ics.sdt.test.characteristics.FactsetMonthlyCharacteristicsTargetDAOBuilder;

@RunWith(MockitoJUnitRunner.class)
public class CharacteristicsTransfersTest {

	@InjectMocks
	private TransferService classUnderTest = new CharacteristicsTransferService();

	@Mock
	private FactsetMonthlyCharacteristicsRepository readRepo;

	@Spy
	private CharacteristicsConverter converter = new CharacteristicsConverter.Impl();

	@Mock
	private CharacteristicsHelperService writeRepo;

	private List<CharacteristicsRounder> rounders;
	private FactsetMonthlyCharacteristicsTargetDAOBuilder targetBuilder = new FactsetMonthlyCharacteristicsTargetDAOBuilder();
	private CharacteristicsBuilder reportingBuilder = new CharacteristicsBuilder();

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		
		rounders = new ArrayList<>();
		rounders.add(new MundaneRounder());
		rounders.add(new MagicRounder());
		rounders.add(new TopTenHoldingsRounder());
		
		Whitebox.setInternalState(classUnderTest, "rounders", rounders);
	}

	@Test
	public void characteristicsServiceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, classUnderTest.getPriority());
	}

	@Test
	public void serviceWantsToHandleCharacteristicsDataSetTypeRequests() {
		String portId = null;
		Date asOfDate = null;
		DataSetType dataSetType = DataSetType.CHARACTERISTICS;
		HttpServletRequest request = null;
		
		assertTrue(classUnderTest.handles(asOfDate, portId, dataSetType, request));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		String portId = null;
		Date asOfDate = null;
		DataSetType dataSetType = null;
		HttpServletRequest request = null;
		
		assertTrue(classUnderTest.handles(asOfDate, portId, dataSetType, request));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		String portId = null;
		Date asOfDate = null;
		DataSetType dataSetType = DataSetType.PRODUCT_DATA;
		HttpServletRequest request = null;
		
		assertFalse(classUnderTest.handles(asOfDate, portId, dataSetType, request));
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfAsOfDateIsNull() {
		classUnderTest.transfer(null, null, null, null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfCalledByUserIdIsNull() {
		classUnderTest.transfer(new Date(), null, null, null);
	}
	
	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfCalledByUserIdIsEmpty() {
		classUnderTest.transfer(new Date(), null, "", null);
	}

	@Test
	public void serviceCanReadCharacteristicsByAsOfDateFromTargetTables() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		
		when(readRepo.findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate)).thenReturn(new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>());
		classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate);
	}

	@Test
	public void serviceCanReadCharacteristicsByAsOfDateAndPortIdFromTargetTables() {
		String portId = "ABC123";
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		
		when(readRepo.findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId)).thenReturn(new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>());
		classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId);
	}

	@Test
	public void serviceThrowsCharacteristicsReadExceptionWhenProblemsOccurDuringRead() {
		boolean caughtExpectedException = false;
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		Exception cause = new RuntimeException();
		
		when(readRepo.findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate)).thenThrow(cause);
		try {
			classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		}
		catch (ReadCharacteristicsException e) {
			assertEquals(cause, e.getCause());
			caughtExpectedException = true;
		}
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate);
		
		assertTrue(caughtExpectedException);
	}

	@SuppressWarnings("unchecked")
	@Test
	public void serviceSavesNothingWhenReadReturnsNull() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		
		when(readRepo.findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate)).thenReturn(null);
		classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate);
		verify(writeRepo, never()).saveAll(any(List.class));
	}

	@SuppressWarnings("unchecked")
	@Test
	public void serviceSavesNothingWhenReadReturnsEmptyList() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		
		when(readRepo.findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate)).thenReturn(new ArrayList<>());
		classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate);
		verify(writeRepo, never()).saveAll(any(List.class));
	}

	@Test
	public void serviceSavesCharacteristicsToReportingTables() {
		String portId = "ABC123";
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		readList.add(targetBuilder.build(asOfDate, portId, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "A", "2.1", "2.0"));
		readList.add(targetBuilder.build(asOfDate, portId, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "B", "5.1", "5.0"));
		
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		writeList.add(reportingBuilder.build(asOfDate, portId, CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "A", "2.1", "2.0"));
		writeList.add(reportingBuilder.build(asOfDate, portId, CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "B", "5.1", "5.0"));
		
		when(readRepo.findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId)).thenReturn(readList);
		when(writeRepo.saveAll(writeList)).thenReturn(writeList);
		classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId);
		verify(writeRepo, times(1)).saveAll(writeList);
	}

	@Test
	public void serviceThrowsCharacteristicsSaveExceptionWhenProblemsOccurDuringSave() {
		boolean caughtExpectedException = false;
		Exception cause = new RuntimeException();
		String portId = "ABC123";
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String calledByUserId = "UXYZ";
		
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		readList.add(targetBuilder.build(asOfDate, portId, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "A", "2.1", "2.0"));
		
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		writeList.add(reportingBuilder.build(asOfDate, portId, CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "A", "2.1", "2.0"));
		
		when(readRepo.findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId)).thenReturn(readList);
		when(writeRepo.saveAll(writeList)).thenThrow(cause);
		try {
			classUnderTest.transfer(asOfDate, portId, calledByUserId, request);
		}
		catch (SaveCharacteristicsException e) {
			assertEquals(cause, e.getCause());
			caughtExpectedException = true;
		}
		verify(readRepo, times(1)).findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(asOfDate, portId);
		verify(writeRepo, times(1)).saveAll(writeList);
				
		assertTrue(caughtExpectedException);
	}
}


	FullCharacteristicsDataLoadTest.java

package com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.powermock.reflect.Whitebox;
import org.springframework.boot.test.IntegrationTest;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsHelperService;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsTransferService;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MagicRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MundaneRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.TopTenHoldingsRounder;
import com.vanguard.corp.ics.sdt.test.characteristics.CharacteristicsBuilder;
import com.vanguard.corp.ics.sdt.test.characteristics.FactsetMonthlyCharacteristicsTargetDAOBuilder;

@IntegrationTest
@RunWith(MockitoJUnitRunner.class)
public class FullCharacteristicsDataLoadTest {

	@Mock
	private FactsetMonthlyCharacteristicsRepository readRepo;

	@InjectMocks
	private TransferService service = new CharacteristicsTransferService();

	private CharacteristicsBuilder charBuilder = new CharacteristicsBuilder();
	private FactsetMonthlyCharacteristicsTargetDAOBuilder targetBuilder = new FactsetMonthlyCharacteristicsTargetDAOBuilder();
	
	private CheckableCharacteristicsHelperService writeRepo;
	private List<FactsetMonthlyCharacteristicsTargetDAO> targetCharacteristics;
	private List<Characteristics> expectedCharacteristics;
	private Date asOfDate = new Date();
	private String portId = null;
	private String calledByUserId = "UXYZ";
	private HttpServletRequest request = null;

	@Before
	public void setup() {
		targetCharacteristics = new ArrayList<>();
		expectedCharacteristics = new ArrayList<>();
		
		when(readRepo.findByFactsetEffectiveDateAndExpiryDateIsNull(asOfDate)).thenReturn(targetCharacteristics);
		
		Whitebox.setInternalState(service, CharacteristicsConverter.class, new CharacteristicsConverter.Impl());
		
		List<CharacteristicsRounder> rounders = new ArrayList<>();
		rounders.add(new MundaneRounder());
		rounders.add(new MagicRounder());
		rounders.add(new TopTenHoldingsRounder());
		Whitebox.setInternalState(service, "rounders", rounders);
		
		writeRepo = new CheckableCharacteristicsHelperServiceImpl();
		Whitebox.setInternalState(service, CharacteristicsHelperService.class, writeRepo);
	}

	@Test
	public void justPortfolioCharacteristics() {
		loadPortfolioCharacteristics();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justTopTenMundaneRounding() {
		loadTopTenMundaneRounding();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justTopTenMagicRounding() {
		loadTopTenMagicRounding();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justCountryAllocations() {
		loadCountryAllocations();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justCurrencyAllocations() {
		loadCurrencyAllocations();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justRegionalAllocations() {
		loadRegionalAllocations();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justSectorAllocations() {
		loadSectorAllocations();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justMarketSegmentations() {
		loadMarketSegmentations();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justUnknowns() {
		loadUnknowns();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void justMagicRoundingWithNulls() {
		loadMagicRoundingWithNulls();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	@Test
	public void integrationTestOfFullDataLoad() {
		loadPortfolioCharacteristics();
		loadTopTenMundaneRounding();
		loadTopTenMagicRounding();
		loadCountryAllocations();
		loadCurrencyAllocations();
		loadRegionalAllocations();
		loadSectorAllocations();
		loadMarketSegmentations();
		loadUnknowns();
		loadMagicRoundingWithNulls();
		
		service.transfer(asOfDate, portId, calledByUserId, request);
		List<Characteristics> savedCharacteristics = writeRepo.getSavedCharacteristics();
		
		assertEquals(targetCharacteristics.size(), savedCharacteristics.size());
		
		for (Characteristics c : expectedCharacteristics) {
			try {
				assertTrue(savedCharacteristics.contains(c));
			}
			catch (AssertionError e) {
				System.err.println(String.format("Failed to find portId:%s type:%s name:%s portfolio:%s benchmark:%s",
						c.getPortId(), c.getType(), c.getName(), c.getPortfolio(), c.getBenchmark()));
				throw e;
			}
		}
		
		for (Characteristics c : savedCharacteristics) {
			assertEquals(calledByUserId, c.getLastUpdatedUserId());
		}
	}

	private void loadPortfolioCharacteristics() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), null, "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "B",  "30.30001", "30.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "C",  "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "D",   "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "E",   "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 null, "59.4",     "59.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "B",  "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "C",  "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "D",   "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "E",   "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "F", "54.99999", "54.99999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "G", "44.90003", "44.90003"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "H",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "I",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "F", "55.0",     "55.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "G", "44.9",     "44.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "H",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "I",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "J", "21.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "K", "20.05000", "21.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "L", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "M", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode(), "N", "18.80000", "18.80000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "J", "21.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "K", "20.1",     "21.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "L", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "M", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS,                 "N", "18.8",     "18.8"));
	}

	private void loadTopTenMundaneRounding() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), null,  "33.90002", "33.90002"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1B", "11.00000", "11.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1C", "10.00000", "10.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1D",  "9.00000",  "9.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1E",  "8.00000",  "2.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1F",  "7.00000",  "7.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1G",  "6.00000",  "6.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1H",  "5.00000",  "5.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1I",  "4.00000",  "4.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1J",  "3.00000",  "3.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1K",  "2.00000",  "8.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1L",  "1.00000",  "1.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1M",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1N",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 null,  "33.9",     "33.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1B", "11.0",     "11.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1C", "10.0",     "10.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1D",  "9.0",      "9.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1E",  "8.0",      "2.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1F",  "7.0",      "7.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1G",  "6.0",      "6.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1H",  "5.0",      "5.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1I",  "4.0",      "4.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1J",  "3.0",      "3.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1K",  "2.0",      "8.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1L",  "1.0",      "1.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1M",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1N",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1O", "33.90002", "33.90002"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1P", "11.00000", "11.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1Q", "10.00000", "10.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1R", "10.00000", "10.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1S", "10.00000", "10.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1T", "10.00000", "10.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1U", "10.00000", "10.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1V",  "5.00000",  "5.00000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1W",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T1X",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1O", "33.9",     "33.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1P", "11.0",     "11.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1Q", "10.0",     "10.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1R", "10.0",     "10.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1S", "10.0",     "10.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1T", "10.0",     "10.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1U", "10.0",     "10.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1V",  "5.0",      "5.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1W",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T1X",  "0.0",      "0.0"));
	}

	private void loadTopTenMagicRounding() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2A",  "1.05000",  "1.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2B",  "2.05000",  "2.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2C",  "3.05000",  "3.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2D",  "4.05000",  "4.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2E",  "5.05000",  "5.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2F",  "6.05000",  "6.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2G",  "7.05000",  "7.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2H",  "8.05000",  "8.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2I", "63.60000", "63.60000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2A",  "1.1",      "1.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2B",  "2.1",      "2.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2C",  "3.1",      "3.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2D",  "4.1",      "4.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2E",  "5.1",      "5.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2F",  "6.1",      "6.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2G",  "7.1",      "7.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2H",  "8.1",      "8.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2I", "63.2",     "63.2"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2Y",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T2Z",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T21", "59.40000", "39.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T22", "30.30001", "50.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T23", "10.20001", "10.20001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2Y",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T2Z",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T21", "59.5",     "39.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T22", "30.3",     "50.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T23", "10.2",     "10.2"));
	}

	private void loadCountryAllocations() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), null, "59.49999", "59.49999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "B", "30.34999", "30.34999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "C", "10.15011", "10.15011"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "D", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION,                 null, "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION,                 "B",  "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION,                 "C",  "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.COUNTRY_ALLOCATION,                 "D",   "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "E", "44.85001", "55.14999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "F", "55.14999", "44.85001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.COUNTRY_ALLOCATION,                 "E", "44.9",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.COUNTRY_ALLOCATION,                 "F", "55.1",     "44.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "G", "30.64999", "30.64999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "H", "69.35001", "69.35001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.COUNTRY_ALLOCATION,                 "G", "30.6",     "30.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.COUNTRY_ALLOCATION,                 "H", "69.4",     "69.4"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "I", "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "J", "30.30001", "30.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "K", "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "L", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "M", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION,                 "I", "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION,                 "J", "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION,                 "K", "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION,                 "L",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.COUNTRY_ALLOCATION,                 "M",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "N", "54.99999", "54.99999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "O", "44.90003", "44.90003"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "P", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "Q", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION,                 "N", "55.1",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION,                 "O", "44.9",     "44.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION,                 "P",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.COUNTRY_ALLOCATION,                 "Q",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "R", "21.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "S", "20.05000", "21.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "T", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "U", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "V", "18.80000", "18.80000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION,                 "R", "20.9",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION,                 "S", "20.1",     "20.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION,                 "T", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION,                 "U", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.COUNTRY_ALLOCATION,                 "V", "18.8",     "18.8"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "W", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "X", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "Y", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "Z", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "1", "0.00004", "0.00004"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "2", "49.90000", "49.90000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "3", "49.90000", "49.90000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "W",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "X",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "Y",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "Z",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "1",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "2", "50.1",     "50.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.COUNTRY_ALLOCATION,                 "3", "49.9",     "49.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "4", "1.21020", "5.21020"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), "5", "2.43039", "2.43039"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.COUNTRY_ALLOCATION,                 "4",  "1.2",     "97.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.COUNTRY_ALLOCATION,                 "5", "98.8",      "2.4"));
	}

	private void loadCurrencyAllocations() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), null, "59.49999", "59.49999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "B", "30.34999", "30.34999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "C", "10.15011", "10.15011"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "D", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION,                 null, "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION,                 "B",  "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION,                 "C",  "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.CURRENCY_ALLOCATION,                 "D",   "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "E", "44.85001", "55.14999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "F", "55.14999", "44.85001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.CURRENCY_ALLOCATION,                 "E", "44.9",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.CURRENCY_ALLOCATION,                 "F", "55.1",     "44.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "G", "30.64999", "30.64999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "H", "69.35001", "69.35001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.CURRENCY_ALLOCATION,                 "G", "30.6",     "30.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.CURRENCY_ALLOCATION,                 "H", "69.4",     "69.4"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "I", "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "J", "30.30001", "30.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "K", "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "L", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "M", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION,                 "I", "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION,                 "J", "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION,                 "K", "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION,                 "L",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.CURRENCY_ALLOCATION,                 "M",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "N", "54.99999", "54.99999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "O", "44.90003", "44.90003"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "P", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "Q", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION,                 "N", "55.1",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION,                 "O", "44.9",     "44.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION,                 "P",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.CURRENCY_ALLOCATION,                 "Q",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "R", "21.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "S", "20.05000", "21.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "T", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "U", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "V", "18.80000", "18.80000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION,                 "R", "20.9",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION,                 "S", "20.1",     "20.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION,                 "T", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION,                 "U", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.CURRENCY_ALLOCATION,                 "V", "18.8",     "18.8"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "W", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "X", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "Y", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "Z", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "1", "0.00004", "0.00004"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "2", "49.90000", "49.90000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "3", "49.90000", "49.90000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "W",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "X",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "Y",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "Z",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "1",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "2", "50.1",     "50.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.CURRENCY_ALLOCATION,                 "3", "49.9",     "49.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "4", "1.21020", "5.21020"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), "5", "2.43039", "2.43039"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.CURRENCY_ALLOCATION,                 "4",  "1.2",     "97.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.CURRENCY_ALLOCATION,                 "5", "98.8",      "2.4"));
	}

	private void loadRegionalAllocations() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), null, "59.49999", "59.49999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "B", "30.34999", "30.34999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "C", "10.15011", "10.15011"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "D", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION,                 null, "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION,                 "B",  "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION,                 "C",  "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.REGIONAL_ALLOCATION,                 "D",   "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "E", "44.85001", "55.14999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "F", "55.14999", "44.85001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.REGIONAL_ALLOCATION,                 "E", "44.9",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.REGIONAL_ALLOCATION,                 "F", "55.1",     "44.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "G", "30.64999", "30.64999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "H", "69.35001", "69.35001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.REGIONAL_ALLOCATION,                 "G", "30.6",     "30.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.REGIONAL_ALLOCATION,                 "H", "69.4",     "69.4"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "I", "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "J", "30.30001", "30.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "K", "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "L", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "M", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION,                 "I", "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION,                 "J", "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION,                 "K", "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION,                 "L",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.REGIONAL_ALLOCATION,                 "M",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "N", "54.99999", "54.99999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "O", "44.90003", "44.90003"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "P", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "Q", "0.04999", "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION,                 "N", "55.1",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION,                 "O", "44.9",     "44.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION,                 "P",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.REGIONAL_ALLOCATION,                 "Q",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "R", "21.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "S", "20.05000", "21.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "T", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "U", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "V", "18.80000", "18.80000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION,                 "R", "20.9",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION,                 "S", "20.1",     "20.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION,                 "T", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION,                 "U", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.REGIONAL_ALLOCATION,                 "V", "18.8",     "18.8"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "W", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "X", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "Y", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "Z", "0.04999", "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "1", "0.00004", "0.00004"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "2", "49.90000", "49.90000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "3", "49.90000", "49.90000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "W",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "X",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "Y",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "Z",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "1",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "2", "50.1",     "50.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.REGIONAL_ALLOCATION,                 "3", "49.9",     "49.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "4", "1.21020", "5.21020"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), "5", "2.43039", "2.43039"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.REGIONAL_ALLOCATION,                 "4",  "1.2",     "97.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.REGIONAL_ALLOCATION,                 "5", "98.8",      "2.4"));
	}

	private void loadSectorAllocations() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), null, "59.49999", "59.49999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "B",  "30.34999", "30.34999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "C",  "10.15011", "10.15011"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "D",   "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION,                 null, "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION,                 "B",  "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION,                 "C",  "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.SECTOR_ALLOCATION,                 "D",   "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "E", "44.85001", "55.14999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "F", "55.14999", "44.85001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.SECTOR_ALLOCATION,                 "E", "44.9",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.SECTOR_ALLOCATION,                 "F", "55.1",     "44.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "G", "30.64999", "30.64999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "H", "69.35001", "69.35001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.SECTOR_ALLOCATION,                 "G", "30.6",     "30.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.SECTOR_ALLOCATION,                 "H", "69.4",     "69.4"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "I", "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "J", "30.30001", "30.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "K", "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "L",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "M",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION,                 "I", "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION,                 "J", "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION,                 "K", "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION,                 "L",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.SECTOR_ALLOCATION,                 "M",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "N", "54.99999", "54.99999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "O", "44.90003", "44.90003"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "P",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "Q",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION,                 "N", "55.1",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION,                 "O", "44.9",     "44.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION,                 "P",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.SECTOR_ALLOCATION,                 "Q",  "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "R", "21.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "S", "20.05000", "21.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "T", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "U", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "V", "18.80000", "18.80000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION,                 "R", "20.9",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION,                 "S", "20.1",     "20.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION,                 "T", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION,                 "U", "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.SECTOR_ALLOCATION,                 "V", "18.8",     "18.8"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "W",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "X",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "Y",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "Z",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "1",  "0.00004",  "0.00004"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "2", "49.90000", "49.90000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "3", "49.90000", "49.90000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "W",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "X",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "Y",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "Z",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "1",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "2", "50.1",     "50.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.SECTOR_ALLOCATION,                 "3", "49.9",     "49.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "4",  "1.21020",  "5.21020"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), "5",  "2.43039",  "2.43039"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.SECTOR_ALLOCATION,                 "4",  "1.2",     "97.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.SECTOR_ALLOCATION,                 "5", "98.8",      "2.4"));
	}

	private void loadMarketSegmentations() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap",        "59.49999", "59.49999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Large Cap", "30.34999", "30.34999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium Cap",       "10.15011", "10.15011"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Small Cap",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",            "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION,                 "Large/Medium",     "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION,                 "Medium",           "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.MARKET_SEGMENTATION,                 "Small/Medium",      "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap", "44.85001", "55.14999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Small Cap", "55.14999", "44.85001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",     "44.9",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.MARKET_SEGMENTATION,                 "Small",     "55.1",     "44.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap", "30.64999", "30.64999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Small Cap", "69.35001", "69.35001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",     "30.6",     "30.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.MARKET_SEGMENTATION,                 "Small",     "69.4",     "69.4"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap",        "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Large Cap", "30.30001", "30.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium Cap",       "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Small Cap",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Small Cap",         "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",            "59.5",     "59.5"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION,                 "Large/Medium",     "30.3",     "30.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION,                 "Medium",           "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION,                 "Small/Medium",      "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC444", CharacteristicsType.MARKET_SEGMENTATION,                 "Small",             "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap",        "54.99999", "54.99999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Large Cap", "44.90003", "44.90003"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium Cap",        "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Small Cap",  "0.04999",  "0.04999"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",            "55.1",     "55.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION,                 "Large/Medium",     "44.9",     "44.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION,                 "Medium",            "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.MARKET_SEGMENTATION,                 "Small/Medium",      "0.0",      "0.0"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap",        "21.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Large Cap", "20.05000", "21.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium Cap",       "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Small Cap", "20.05000", "20.05000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Small Cap",        "18.80000", "18.80000"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",            "20.9",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION,                 "Large/Medium",     "20.1",     "20.9"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION,                 "Medium",           "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION,                 "Small/Medium",     "20.1",     "20.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.MARKET_SEGMENTATION,                 "Small",            "18.8",     "18.8"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap",         "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Large Cap",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium Cap",        "0.04998",  "0.04998"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Medium/Small Cap", "49.92502", "49.92502"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Small Cap",        "49.92502", "49.92502"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",             "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION,                 "Large/Medium",      "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION,                 "Medium",            "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION,                 "Small/Medium",     "50.1",     "50.1"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC777", CharacteristicsType.MARKET_SEGMENTATION,                 "Small",            "49.9",     "49.9"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Small Cap",  "1.21020",  "5.21020"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC888", CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), "Large Cap",  "2.43039",  "2.43039"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.MARKET_SEGMENTATION,                 "Small",      "1.2",     "97.6"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC888", CharacteristicsType.MARKET_SEGMENTATION,                 "Large",     "98.8",      "2.4"));
	}

	private void loadUnknowns() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.UNKNOWN.getTargetCode(), null, "59.40000", "59.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC111", CharacteristicsType.UNKNOWN.getTargetCode(),  "B", "30.30001", "30.30001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.UNKNOWN,                 null, "59.4",     "59.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC111", CharacteristicsType.UNKNOWN,                  "B", "30.3",     "30.3"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222",                        null, null, "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC222",                        null,  "B", "10.20001", "10.20001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.UNKNOWN, null, "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC222", CharacteristicsType.UNKNOWN,  "B", "10.2",     "10.2"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", "FakeTypeCode",              null, "10.20001", "10.20001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC333", "FakeTypeCode",               "B", "10.20001", "10.20001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.UNKNOWN, null, "10.2",     "10.2"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC333", CharacteristicsType.UNKNOWN,  "B", "10.2",     "10.2"));
	}

	private void loadMagicRoundingWithNulls() {
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3A",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3B",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3C", "59.40000", "39.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3D", "30.30001", "50.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3E",   null,     "10.20001"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3A",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3B",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3C", "59.4",     "39.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3D", "30.3",     "50.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC555", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3E",   null,     "10.2"));
		
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3F",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3G",  "0.04999",  "0.04999"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3H", "59.40000", "39.40000"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3I", "30.30001", "50.30001"));
		targetCharacteristics.add(targetBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), "T3J", "10.20001",   null));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3F",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3G",  "0.0",      "0.0"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3H", "59.5",     "39.4"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3I", "30.3",     "50.3"));
		expectedCharacteristics.add(charBuilder.build(asOfDate, "ABC666", CharacteristicsType.TOP_TEN_HOLDINGS,                 "T3J", "10.2",       null));
	}

	public interface CheckableCharacteristicsHelperService extends CharacteristicsHelperService {
		List<Characteristics> getSavedCharacteristics();
	}

	public static class CheckableCharacteristicsHelperServiceImpl implements CheckableCharacteristicsHelperService {

		private List<Characteristics> saved;

		@Override
		public List<Characteristics> retrieveAll(Date asOfDate) {
			return null;
		}

		@Override
		public List<Characteristics> retrieveAll(Date asOfDate, String portId) {
			return null;
		}

		@Override
		public void logicalDelete(Date asOfDate, String portId, String characteristicsType) {
		}

		@Override
		public List<Characteristics> saveAll(List<Characteristics> saveList) {
			saved = saveList;
			return saveList;
		}

		@Override
		public List<Characteristics> getSavedCharacteristics() {
			return saved;
		}
	}
}

	MagicRoundingTest.java

package com.vanguard.corp.ics.sdt.behaviors.datatransfer.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MagicRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MundaneRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.TopTenHoldingsRounder;
import com.vanguard.corp.ics.sdt.test.characteristics.CharacteristicsBuilder;

public class MagicRoundingTest {

	private CharacteristicsRounder magicRounder = new MagicRounder();
	private CharacteristicsRounder mundaneRounder = new MundaneRounder();
	private CharacteristicsRounder topTenRounder = new TopTenHoldingsRounder();
	private CharacteristicsBuilder builder = new CharacteristicsBuilder();

	@Test
	public void countryAllocationHandledByAppropriateCharacteristicsRounder() {
		assertTrue(magicRounder.handles(CharacteristicsType.valueOf("COUNTRY_ALLOCATION").getReportingCode()));
		assertFalse(mundaneRounder.handles(CharacteristicsType.COUNTRY_ALLOCATION.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.COUNTRY_ALLOCATION.getReportingCode()));
	}

	@Test
	public void currencyAllocationHandledByAppropriateCharacteristicsRounder() {
		assertTrue(magicRounder.handles(CharacteristicsType.CURRENCY_ALLOCATION.getReportingCode()));
		assertFalse(mundaneRounder.handles(CharacteristicsType.CURRENCY_ALLOCATION.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.CURRENCY_ALLOCATION.getReportingCode()));
	}

	@Test
	public void marketSegmentationByCapAllocationHandledByAppropriateCharacteristicsRounder() {
		assertTrue(magicRounder.handles(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode()));
		assertFalse(mundaneRounder.handles(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.MARKET_SEGMENTATION.getReportingCode()));
	}

	@Test
	public void portfolioCharacteristicsHandledByAppropriateCharacteristicsRounder() {
		assertFalse(magicRounder.handles(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getReportingCode()));
		assertTrue(mundaneRounder.handles(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getReportingCode()));
	}

	@Test
	public void regionalAllocationHandledByAppropriateCharacteristicsRounder() {
		assertTrue(magicRounder.handles(CharacteristicsType.REGIONAL_ALLOCATION.getReportingCode()));
		assertFalse(mundaneRounder.handles(CharacteristicsType.REGIONAL_ALLOCATION.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.REGIONAL_ALLOCATION.getReportingCode()));
	}

	@Test
	public void sectorAllocationHandledByAppropriateCharacteristicsRounder() {
		assertTrue(magicRounder.handles(CharacteristicsType.SECTOR_ALLOCATION.getReportingCode()));
		assertFalse(mundaneRounder.handles(CharacteristicsType.SECTOR_ALLOCATION.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.SECTOR_ALLOCATION.getReportingCode()));
	}

	@Test
	public void topTenHoldingsHandledByAppropriateCharacteristicsRounder() {
		assertFalse(magicRounder.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getReportingCode()));
		assertFalse(mundaneRounder.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getReportingCode()));
		assertTrue(topTenRounder.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getReportingCode()));
	}

	@Test
	public void unknownHandledByAppropriateCharacteristicsRounder() {
		assertFalse(magicRounder.handles(CharacteristicsType.UNKNOWN.getReportingCode()));
		assertTrue(mundaneRounder.handles(CharacteristicsType.UNKNOWN.getReportingCode()));
		assertFalse(topTenRounder.handles(CharacteristicsType.UNKNOWN.getReportingCode()));
	}

	@Test
	public void nullOrEmptyOrOtherUnrecognizedCharacteristicTypeCodesAreHandledByMundaneRounder() {
		assertFalse(magicRounder.handles(null));
		assertFalse(magicRounder.handles(""));
		assertFalse(magicRounder.handles("%!n64nb$&u4SGTF"));
		
		assertTrue(mundaneRounder.handles(null));
		assertTrue(mundaneRounder.handles(""));
		assertTrue(mundaneRounder.handles("?34vg2GVR@&^!asRE73"));
		
		assertFalse(topTenRounder.handles(null));
		assertFalse(topTenRounder.handles(""));
		assertFalse(topTenRounder.handles("2o8jV@#!F*$qc897"));
	}

	@Test
	public void mundaneRounderDoesNotAdjustValues() {
		Date effectiveDate = new Date();
		List<Characteristics> list = new ArrayList<>();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "A", "33.9", "33.9"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "B", "11.0", "11.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "C", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "D", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "E", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "F", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "G", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "H", "5.0", "5.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "I", "0.0", "0.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "J", "0.0", "0.0"));
		
		List<Characteristics> rounded = mundaneRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		for (Characteristics c : list) {
			assertTrue(rounded.contains(c));
		}
	}

	@Test
	public void magicRounderAdjustsValuesToForceTheSumForAnyPortIdToEqual100() {
		Date effectiveDate = new Date();
		List<Characteristics> list = new ArrayList<>();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "21.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.1", "21.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", "20.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "18.8", "18.8"));
		
		List<Characteristics> rounded = magicRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "20.9", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.1", "20.9")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", "20.1", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.1", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "18.8", "18.8")));
		
		// no need to adjust if it is already 100
		list.clear();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "20.0", "20.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.0", "20.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", "20.0", "20.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.0", "20.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "20.0", "20.0"));
		
		rounded = magicRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		for (Characteristics c : list) {
			assertTrue(rounded.contains(c));
		}
	}

	@Test
	public void magicRounderDoesNotAdjustPortfolioValuesWhenAtLeastOnePortfolioValueIsNullForPortId() {
		Date effectiveDate = new Date();
		List<Characteristics> list = new ArrayList<>();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "21.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.1", "21.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", null, "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "18.8", "18.8"));
		
		List<Characteristics> rounded = magicRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "21.1", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.1", "20.9")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", null, "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.1", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "18.8", "18.8")));
	}

	@Test
	public void magicRounderDoesNotAdjustBenchmarkValuesWhenAtLeastOneBenchmarkValueIsNullForPortId() {
		Date effectiveDate = new Date();
		List<Characteristics> list = new ArrayList<>();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "21.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.1", "21.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", "20.1", "20.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.1", null));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "18.8", "18.8"));
		
		List<Characteristics> rounded = magicRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "A", "20.9", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "B", "20.1", "21.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "C", "20.1", "20.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "D", "20.1", null)));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.SECTOR_ALLOCATION, "E", "18.8", "18.8")));
	}

	@Test
	public void topTenHoldingsRounderDoesNotAdjustValuesForAnyPortIdWithGreaterThanOrEqualToTenValues() {
		Date effectiveDate = new Date();
		List<Characteristics> list = new ArrayList<>();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "A", "33.9", "33.9"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "B", "11.0", "11.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "C", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "D", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "E", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "F", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "G", "10.0", "10.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "H", "5.0", "5.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "I", "0.0", "0.0"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "J", "0.0", "0.0"));
		
		List<Characteristics> rounded = topTenRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		for (Characteristics c : list) {
			assertTrue(rounded.contains(c));
		}
	}

	@Test
	public void topTenHoldingsRounderAdjustsValuesToForceTheSumForAnyPortIdToEqual100WhenLessThanTenValues() {
		Date effectiveDate = new Date();
		List<Characteristics> list = new ArrayList<>();

		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "A", "1.1", "1.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "B", "2.1", "2.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "C", "3.1", "3.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "D", "4.1", "4.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "E", "5.1", "5.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "F", "6.1", "6.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "G", "7.1", "7.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "H", "8.1", "8.1"));
		list.add(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "I", "63.6", "63.6"));
		
		List<Characteristics> rounded = topTenRounder.round(list);
		assertEquals(list.size(), rounded.size());
		
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "A", "1.1", "1.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "B", "2.1", "2.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "C", "3.1", "3.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "D", "4.1", "4.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "E", "5.1", "5.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "F", "6.1", "6.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "G", "7.1", "7.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "H", "8.1", "8.1")));
		assertTrue(rounded.contains(builder.build(effectiveDate, "1", CharacteristicsType.TOP_TEN_HOLDINGS, "I", "63.2", "63.2")));
	}

	@Test(expected=IllegalArgumentException.class)
	public void topTenHoldingsRounderThrowsAnExceptionIfParameterIsNull() {
		topTenRounder.round(null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void mundaneRounderThrowsAnExceptionIfParameterIsNull() {
		mundaneRounder.round(null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void magicRounderThrowsAnExceptionIfParameterIsNull() {
		magicRounder.round(null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void magicRounderThrowsAnExceptionIfListIsEmpty() {
		List<Characteristics> list = new ArrayList<>();
		magicRounder.round(list);
	}

	@Test(expected=IllegalArgumentException.class)
	public void magicRounderThrowsAnExceptionIfListContainsNull() {
		List<Characteristics> list = new ArrayList<>();
		list.add(new Characteristics());
		list.add(null);
		list.add(new Characteristics());
		magicRounder.round(list);
	}
}

com.vanguard.corp.ics.sdt.behaviors.datatransfer.performancesummary

	PerformanceSummaryTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.performancesummary;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Calendar;
import java.util.Date;

import javax.inject.Inject;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;

public class PerformanceSummaryTest {

	@Inject
	PerformanceSummary classUnderTest = new PerformanceSummary();

	@Test
	public void performanceSummaryHasPerformanceSummaryId() {
		classUnderTest.setPerformanceSummaryId(Long.valueOf(10));
		assertEquals(Long.valueOf(10), classUnderTest.getPerformanceSummaryId());
	}
	
	@Test
	public void performanceSummaryHasPortId() {
		String portId = "PORT_ID";
		classUnderTest.setPortId(portId);
		assertEquals(classUnderTest.getPortId(), portId );
	}

	@Test
	public void performanceSummaryHasEffectiveDates() {
		Calendar cal = Calendar.getInstance();
		final Date effectiveEnd = cal.getTime();
		cal.add(Calendar.YEAR, -1); // last year
		final Date effectiveBegin = cal.getTime();
		assertNotEquals(effectiveBegin, effectiveEnd);
		
		classUnderTest.setEffectiveBeginDate(effectiveBegin);
		classUnderTest.setEffectiveEndDate(effectiveEnd);
		classUnderTest.setEffectiveDate(effectiveBegin);
		assertEquals(effectiveBegin, classUnderTest.getEffectiveBeginDate());
		assertEquals(effectiveEnd, classUnderTest.getEffectiveEndDate());
		assertEquals(effectiveBegin, classUnderTest.getEffectiveDate());
	}

	@Test
	public void performanceSummaryHasName() {
		String name = "TEST_NAME";
		classUnderTest.setPerformanceTypeName(name);
		assertEquals(classUnderTest.getPerformanceTypeName(), name );
	}
	
	@Test
	public void performanceSummaryHasCode() {
		String name = "TEST_NAME";
		classUnderTest.setPerformanceTypeCode(name);
		assertEquals(classUnderTest.getPerformanceTypeCode(), name );
	}


	@Test
	public void performanceSummaryHasOneMonthValue() {
		final BigDecimal oneMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setOneMonthValue(oneMonthVal);
		assertEquals(oneMonthVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getOneMonthValue());
	}

	@Test
	public void performanceSummaryHasThreeMonthValue() {
		final BigDecimal threeMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setThreeMonthValue(threeMonthVal);
		assertEquals(threeMonthVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getThreeMonthValue());
	}

	@Test
	public void performanceSummaryHasSixMonthValue() {
		final BigDecimal sixMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setSixMonthValue(sixMonthVal);
		assertEquals(sixMonthVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getSixMonthValue());
	}

	@Test
	public void performanceSummaryHasNineMonthValue() {
		final BigDecimal nineMonthVal = new BigDecimal("1234567890.12345");
		classUnderTest.setNineMonthValue(nineMonthVal);
		assertEquals(nineMonthVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getNineMonthValue());
	}

	@Test
	public void performanceSummaryHasOneYearValue() {
		final BigDecimal oneYearVal = new BigDecimal("1234567890.12345");
		classUnderTest.setOneYearValue(oneYearVal);
		assertEquals(oneYearVal.setScale(2, RoundingMode.HALF_UP).setScale(2, RoundingMode.HALF_UP), classUnderTest.getOneYearValue());
	}
	
	@Test
	public void performanceSummaryHasThreeYearValue() {
		final BigDecimal threeYearVal = new BigDecimal("1234567890.12345");
		classUnderTest.setThreeYearValue(threeYearVal);
		assertEquals(threeYearVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getThreeYearValue());
	}
	
	@Test
	public void performanceSummaryHasFiveYearValue() {
		final BigDecimal fiveYearVal = new BigDecimal("1234567890.12345");
		classUnderTest.setFiveYearValue(fiveYearVal);
		assertEquals(fiveYearVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getFiveYearValue());
	}
	
	@Test
	public void performanceSummaryHasTenYearValue() {
		final BigDecimal tenYearVal = new BigDecimal("1234567890.12345");
		classUnderTest.setTenYearValue(tenYearVal);
		assertEquals(tenYearVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getTenYearValue());
	}

	@Test
	public void performanceSummaryHasYearToDateValue() {
		final BigDecimal yearToDate = new BigDecimal("1234567890.12345");
		classUnderTest.setYearToDateValue(yearToDate);
		assertEquals(yearToDate.setScale(2, RoundingMode.HALF_UP), classUnderTest.getYearToDateValue());
	}
	
	@Test
	public void performanceSummaryHasInceptionYearValue() {
		final BigDecimal inceptionYearVal = new BigDecimal("1234567890.12345");
		classUnderTest.setInceptionValue(inceptionYearVal);
		assertEquals(inceptionYearVal.setScale(2, RoundingMode.HALF_UP), classUnderTest.getInceptionValue());
	}

	@Test
	public void performanceSummaryHasLastUpdatedUserId() {
		String name = "TEST_NAME";
		classUnderTest.setLastUpdatedUserId(name);
		assertEquals(classUnderTest.getLastUpdatedUserId(), name );
	}

	@Test
	public void performanceSummaryHasLastUpdatedDate() {
		Calendar cal = Calendar.getInstance();
		final Date lastUpdatedDate = cal.getTime();
		classUnderTest.setLastUpdatedDate(lastUpdatedDate);
		assertEquals(lastUpdatedDate, classUnderTest.getLastUpdatedDate());
	}
	
	@Test
	public void performanceSummaryHasInceptionPaValue() {
		BigDecimal inceptionPaValue = BigDecimal.ONE;
		classUnderTest.setInceptionPerformanceAdjustedValue(inceptionPaValue);
		assertEquals(classUnderTest.getInceptionPerformanceAdjustedValue(), inceptionPaValue.setScale(2));
	}
	
	@Test
	public void performanceSummaryHasNullInceptionPaValue() {
		BigDecimal inceptionPaValue = null;
		classUnderTest.setInceptionPerformanceAdjustedValue(inceptionPaValue);
		assertEquals(classUnderTest.getInceptionPerformanceAdjustedValue(), null);
	}

	@Test
	public void performanceSummaryHasDatasourceFileDao() {
		DatasourceFileDAO datasourceFileDao = new DatasourceFileDAO();
		classUnderTest.setDatasourceFileDAO(datasourceFileDao);
		assertEquals(datasourceFileDao, classUnderTest.getDatasourceFileDAO());
	}
	
	@Test
	public void performanceSummaryHasInceptionPerformanceAdjustedValue() {
		BigDecimal inceptionPerformanceAdjustedValue = new BigDecimal("1234567890.12345");
		inceptionPerformanceAdjustedValue = inceptionPerformanceAdjustedValue.setScale(2, BigDecimal.ROUND_HALF_UP);
		classUnderTest.setInceptionPerformanceAdjustedValue(inceptionPerformanceAdjustedValue);
		assertEquals(inceptionPerformanceAdjustedValue, classUnderTest.getInceptionPerformanceAdjustedValue());
	}
	
	@Test
	public void performanceSummaryHasCurrentYearToDateValue() {
		final BigDecimal currentYearToDateValue = new BigDecimal("1234567890.12345");
		classUnderTest.setCurrentYearToDateValue(currentYearToDateValue);
		assertEquals(currentYearToDateValue, classUnderTest.getCurrentYearToDateValue());
	}
}


	PerformanceSummaryTransferServiceTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.performancesummary;

import static org.hamcrest.Matchers.anyOf;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import com.vanguard.corp.ics.dao.target.PerformanceCalculationDAO;
import com.vanguard.corp.ics.enums.CalculationPeriodEnum;
import com.vanguard.corp.ics.repository.target.PerformanceCalculationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.PerformanceSummarayRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.constants.PerformanceSummaryCode;
import com.vanguard.corp.ics.sdt.service.api.constants.PerformanceSummaryName;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadPerformanceSummaryException;
import com.vanguard.corp.ics.sdt.service.api.exception.SavePerformanceSummaryException;
import com.vanguard.corp.ics.sdt.service.impl.performancesummary.PerformanceSummaryDataConverter;
import com.vanguard.corp.ics.sdt.service.impl.performancesummary.PerformanceSummaryTransferService;

@RunWith(MockitoJUnitRunner.class)
public class PerformanceSummaryTransferServiceTest {
	private static final String PORT_ID_1 = "PORT01";
	private static final String PORT_ID_2 = "PORT02";

	@InjectMocks
	private TransferService classUnderTest = new PerformanceSummaryTransferService();

	@Mock
	private PerformanceCalculationRepository readRepo;
	
	@Mock
	private PerformanceSummarayRepository jpaRepo;

	@Mock
	private HttpServletRequest request;

	@Mock
	private PerformanceSummaryDataConverter dataConverter;

	@Before
	public void setUp() throws Exception {
	}

	@Test
	public void serviceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, classUnderTest.getPriority());
	}

	@Test
	public void serviceWantsToHandleAttributionSummaryyDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, DataSetType.PERFORMANCE_SUMMARY, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(classUnderTest.handles(null, null, DataSetType.ATTRIBUTION_SUMMARY, null));
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceDoesNotAcceptNullEffectiveDate() {
		classUnderTest.transfer(null, PORT_ID_1, "abc", request);
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceDoesNotAcceptNullCalledByUserId() {
		classUnderTest.transfer(new Date(), PORT_ID_1, null, request);
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceDoesNotAcceptEmptyCalledByUserId() {
		classUnderTest.transfer(new Date(), PORT_ID_1, "", request);
	}

	@Test
	public void serviceShouldGetDataByEffectiveDateOnlyWhenPortIdIsNull() {
		Date effectiveDate = new Date();
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(effectiveDate, null, calledByUserId, request);
		verify(readRepo, times(1)).findByCalculationDateAndLastestVersion(effectiveDate);
	}


	@Test
	public void serviceShouldGetDataByEffectiveDateAndPortIdWhenPortIdIsNotNull() {
		Date effectiveDate = new Date();
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(new Date(), PORT_ID_1, calledByUserId, request);
		verify(readRepo, times(1)).findByCalculationDateAndPortCodeAndLastestVersion(effectiveDate, PORT_ID_1);
	}

	@Test(expected = IllegalArgumentException.class)
	public void serviceShouldNotGetDataByNullEffectiveDate() {
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(null, null, calledByUserId, request);
	}

	@Test(expected = ReadPerformanceSummaryException.class)
	public void serviceShouldThrowReadExceptionWhenTargetDataReadThrowsException() {
		Date effectiveDate = new Date();
		when(readRepo.findByCalculationDateAndLastestVersion(effectiveDate)).thenThrow(Exception.class);
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(effectiveDate, null, calledByUserId, request);
	}

	@Test(expected = ReadPerformanceSummaryException.class)
	public void serviceShouldThrowReadExceptionWithInvalidPortId() {
		Date validEffectiveDate = new Date();
		String invalidPortId = "INVALID_PORT_ID";
		when(readRepo.findByCalculationDateAndPortCodeAndLastestVersion(validEffectiveDate, invalidPortId)).thenThrow(Exception.class);
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(validEffectiveDate, invalidPortId, calledByUserId, request);
	}

	@Test
	public void serviceShouldFetchDataWithvalidEffectiveDate() {
		Date validEffectiveDate = new Date();
		List<PerformanceCalculationDAO> daos = Arrays.asList(new PerformanceCalculationDAO());
		when(readRepo.findByCalculationDateAndLastestVersion(validEffectiveDate)).thenReturn(daos);
		String calledByUserId = "UXYZ";
		classUnderTest.transfer(validEffectiveDate, null, calledByUserId, request);
		verify(readRepo, times(1)).findByCalculationDateAndLastestVersion(validEffectiveDate);
	}

	@Test(expected = SavePerformanceSummaryException.class)
	public void serviceShouldThrowExceptionWhenDataWriteFails() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		PerformanceCalculationDAO dao = new PerformanceCalculationDAO();
		dao.setCalcDt(validEffectiveDate);
		dao.setPrtCd(PORT_ID_1);
		List<PerformanceCalculationDAO> daos = Arrays.asList(dao);
		when(readRepo.findByCalculationDateAndPortCodeAndLastestVersion(validEffectiveDate, PORT_ID_1)).thenReturn(daos);
		PerformanceSummary performanceSummary = new PerformanceSummary();
		performanceSummary.setEffectiveDate(validEffectiveDate);
		performanceSummary.setPortId(PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = Arrays.asList(performanceSummary);
		when(dataConverter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId)).thenReturn(performanceSummaries);
		when(jpaRepo.save(performanceSummaries)).thenThrow(Exception.class);
		classUnderTest.transfer(validEffectiveDate, PORT_ID_1, calledByUserId, request);
	}

	@Test
	public void serviceShouldCallJpaRepoToSaveMandatoryDataWhenDataListIsEmptyAndPortIdIsNotNull() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		PerformanceCalculationDAO dao = new PerformanceCalculationDAO();
		dao.setCalcDt(validEffectiveDate);
		dao.setPrtCd(PORT_ID_1);
		List<PerformanceCalculationDAO> daos = Arrays.asList(dao);
		PerformanceSummary performanceSummary = new PerformanceSummary();
		performanceSummary.setEffectiveDate(validEffectiveDate);
		performanceSummary.setPortId(PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = Arrays.asList(performanceSummary);
		when(readRepo.findByCalculationDateAndPortCodeAndLastestVersion(validEffectiveDate, PORT_ID_1)).thenReturn(daos);
		when(dataConverter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId)).thenReturn(performanceSummaries);
		classUnderTest.transfer(validEffectiveDate, PORT_ID_1, calledByUserId, request);
		verify(jpaRepo, times(1)).save(performanceSummaries);
	}

	@Test
	public void serviceShouldExecuteLogicalDelete() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		PerformanceCalculationDAO dao = new PerformanceCalculationDAO();
		dao.setCalcDt(validEffectiveDate);
		dao.setPrtCd(PORT_ID_1);
		List<PerformanceCalculationDAO> daos = Arrays.asList(dao);
		PerformanceSummary performanceSummary = new PerformanceSummary();
		performanceSummary.setEffectiveDate(validEffectiveDate);
		performanceSummary.setPortId(PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = Arrays.asList(performanceSummary);
		when(readRepo.findByCalculationDateAndPortCodeAndLastestVersion(validEffectiveDate, PORT_ID_1)).thenReturn(daos);
		when(dataConverter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId)).thenReturn(performanceSummaries);
		when(jpaRepo.findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(validEffectiveDate, PORT_ID_1)).thenReturn(performanceSummaries);
		for(PerformanceSummary data: performanceSummaries){
			assertNull(data.getEffectiveEndDate());
		}
		classUnderTest.transfer(validEffectiveDate, PORT_ID_1, calledByUserId, request);
		for (PerformanceSummary data : performanceSummaries) {
			assertNotNull(data.getEffectiveEndDate());
		}
		verify(jpaRepo, times(1)).save(performanceSummaries);
	}

	@Test
	public void serviceShouldConvertPerformanceCalculationToPerformanceSummaryForMandatoryTypes(){
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = buildPerformanceSummaryListWithRequiredPerformanceSummaryNames(validEffectiveDate, PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		
		for(PerformanceSummary summary : performanceSummaries){
			assertEquals(validEffectiveDate, summary.getEffectiveDate());
			assertEquals(summary.getPortId(), PORT_ID_1);
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.valueOf("DIFF_CODE").getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(-1.30).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(-3.60).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(0.30).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(-5.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(2.09).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(1.68).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(-2.05).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(-0.91).setScale(2, RoundingMode.HALF_UP)));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.PFT_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(2.17).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(2.10).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(4.20).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(3.79).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(6.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(1.99).setScale(2, RoundingMode.HALF_UP)));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_NET.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.BMK_NET.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(3.45).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(5.75).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(1.87).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(7.25).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(8.16).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(2.90).setScale(2, RoundingMode.HALF_UP)));
			}
			assertEquals(summary.getEffectiveBeginDate(), null);
			assertEquals(summary.getEffectiveEndDate(), null);
			assertEquals(calledByUserId, summary.getLastUpdatedUserId());
			assertEquals(summary.getLastUpdatedDate(), null);
			assertEquals(summary.getPerformanceSummaryId(), null);
		}
	}
	

	@Test
	public void serviceShouldConvertFakePerformanceSummaryToPerformanceSummaryForMultiplePortIds() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> fakePerformanceSummaries = buildPerformanceSummaryListWithRequiredPerformanceSummaryNames(validEffectiveDate,
				PORT_ID_1);
		fakePerformanceSummaries.addAll(buildPerformanceSummaryListWithRequiredPerformanceSummaryNames(validEffectiveDate, PORT_ID_2));
		List<PerformanceSummary> performanceSummaries = converter.convert(fakePerformanceSummaries, validEffectiveDate, null, calledByUserId);
		assertEquals(6, performanceSummaries.size());
		PerformanceSummary portfolioWithPORT_ID_1 = null;
		PerformanceSummary portfolioWithPORT_ID_2 = null;
		PerformanceSummary bmkNetWithPORT_ID_1 = null;
		PerformanceSummary bmkNetWithPORT_ID_2 = null;
		PerformanceSummary diffWithPORT_ID_1 = null;
		PerformanceSummary diffWithPORT_ID_2 = null;
		for (PerformanceSummary summary : performanceSummaries) {
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName()) && summary.getPortId() .equals(PORT_ID_1)){
				portfolioWithPORT_ID_1 = summary;
			} else if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName()) && summary.getPortId() .equals(PORT_ID_2)){
				portfolioWithPORT_ID_2 = summary;
			} else if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_NET.getName()) && summary.getPortId() .equals(PORT_ID_1)){
				bmkNetWithPORT_ID_1 = summary;
			} else if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_NET.getName()) && summary.getPortId() .equals(PORT_ID_2)){
				bmkNetWithPORT_ID_2 = summary;
			} else if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName()) && summary.getPortId() .equals(PORT_ID_1)){
				diffWithPORT_ID_1 = summary;
			} else if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName()) && summary.getPortId() .equals(PORT_ID_2)){
				diffWithPORT_ID_2 = summary;
			}
		}
		
		assertNotNull(portfolioWithPORT_ID_1);
		assertNotNull(portfolioWithPORT_ID_2);
		assertNotNull(bmkNetWithPORT_ID_1);
		assertNotNull(bmkNetWithPORT_ID_2);
		assertNotNull(diffWithPORT_ID_1);
		assertNotNull(diffWithPORT_ID_2);
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryListWithRequiredPerformanceSummaryNames(final Date effectiveDate, final String portId) {
		List<PerformanceCalculationDAO> performanceSummaryDAOs = new ArrayList<>();

		performanceSummaryDAOs.addAll(buildPerformanceSummaryWithBmkAndPrt(effectiveDate, portId, PerformanceSummaryName.BMK_NET.getName(), PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
		return performanceSummaryDAOs;
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryWithBmkAndPrt(final Date effectiveDate, final String portId
			, final String bmkType, String prtType) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(10);
		for(int i=0; i<10; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			c.setBmkType(bmkType);
			c.setPrtType(prtType);
			returnData.add(addValuesToPerformanceCalculationDAO(c, i));
		}
		return returnData;
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryListWithoutPortfolioGross(final Date effectiveDate, final String portId) {
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1, PerformanceSummaryName.BMK_NET.getName(), "Portfolio (Net)"));
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1, PerformanceSummaryName.BMK_NET.getName(), "Portfolio (Net)"));
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1, "Bmk (Div Return)", "Portfolio (Net)"));
		return daos;
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryListWithoutBmkNet(final Date effectiveDate, final String portId) {
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1, "Bmk (Price Return)", PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1, "Bmk (Price Return)", PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1, "Bmk (Div Return)", PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
		return daos;
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummary(final Date effectiveDate, final String portId, final String bmkType, String prtType) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(10);
		for(int i=0; i<10; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			c.setBmkType(bmkType);
			c.setPrtType(prtType);
			returnData.add(addValuesToPerformanceCalculationDAO(c, i));
		}
		return returnData;
	}
	
	private PerformanceCalculationDAO addValuesToPerformanceCalculationDAO(PerformanceCalculationDAO dao, int i){
		if (i == 0) {
			dao.setPeriod(CalculationPeriodEnum.CYTD);
			dao.setPrtVal(BigDecimal.valueOf(2.2357));
			dao.setBmkVal(BigDecimal.valueOf(1.2357));
		} else if (i == 1) {
			dao.setPeriod(CalculationPeriodEnum.P1M);
			dao.setPrtVal(BigDecimal.valueOf(2.1527));
			dao.setBmkVal(BigDecimal.valueOf(3.4527));
		} else if (i == 2) {
			dao.setPeriod(CalculationPeriodEnum.P3M);
			dao.setPrtVal(BigDecimal.valueOf(2.1527));
			dao.setBmkVal(BigDecimal.valueOf(5.7527));
		} else if (i == 3) {
			dao.setPeriod(CalculationPeriodEnum.P6M);
			dao.setPrtVal(BigDecimal.valueOf(2.167));
			dao.setBmkVal(BigDecimal.valueOf(1.867));
		} else if (i == 4) {
			dao.setPeriod(CalculationPeriodEnum.P1Y);
			dao.setPrtVal(BigDecimal.valueOf(2.1017));
			dao.setBmkVal(BigDecimal.valueOf(7.2517));
		} else if (i == 5) {
			dao.setPeriod(CalculationPeriodEnum.P3YPA);
			dao.setPrtVal(BigDecimal.valueOf(4.1997));
			dao.setBmkVal(BigDecimal.valueOf(2.1097));
		} else if (i == 6) {
			dao.setPeriod(CalculationPeriodEnum.P5YPA);
			dao.setPrtVal(BigDecimal.valueOf(3.7917));
			dao.setBmkVal(BigDecimal.valueOf(2.1117));
		} else if (i == 7) {
			dao.setPeriod(CalculationPeriodEnum.PINCP);
			dao.setPrtVal(BigDecimal.valueOf(6.1070));
			dao.setBmkVal(BigDecimal.valueOf(8.1570));
		} else if (i == 8) {
			dao.setPeriod(CalculationPeriodEnum.PINCEPPA);
			dao.setPrtVal(BigDecimal.valueOf(19.057));
			dao.setBmkVal(BigDecimal.valueOf(9.657));
		} else if (i == 9) {
			dao.setPeriod(CalculationPeriodEnum.FYTD);
			dao.setPrtVal(BigDecimal.valueOf(1.9927));
			dao.setBmkVal(BigDecimal.valueOf(2.9027));
		}
		return dao;
	}

	@Test
	public void shouldCalculateDiffAfterRoundingOffPortfolioGrossAndBmkNet() {
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		List<PerformanceSummary> performanceSummaries = converter.convert(
				buildPerformanceSummaryListWithRequiredPerformanceSummaryNames(validEffectiveDate, PORT_ID_1), validEffectiveDate, PORT_ID_1, calledByUserId);
		for (PerformanceSummary summary : performanceSummaries) {
			assertEquals(validEffectiveDate, summary.getEffectiveDate());
			assertEquals(summary.getPortId(), PORT_ID_1);
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.DIFF_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(-1.30).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(-3.60).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(0.30).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(-5.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(2.09).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(1.68).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(-2.05).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(-0.91).setScale(2, RoundingMode.HALF_UP)));
			} 
		}
	}


	@SuppressWarnings("unchecked")
	@Test
	public void serviceShouldCreatePortfolioGrossRecordsWithNullValuesWhenNotAvailableInTarget() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = buildPerformanceSummaryListWithoutPortfolioGross(validEffectiveDate, PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		
		for(PerformanceSummary summary : performanceSummaries){
			assertEquals(validEffectiveDate, summary.getEffectiveDate());
			assertEquals(summary.getPortId(), PORT_ID_1);
			assertThat(summary.getPerformanceTypeName(),
					anyOf(equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()), equalTo(PerformanceSummaryName.BMK_NET.getName()), equalTo(PerformanceSummaryName.DIFF.getName()),
							equalTo("Bmk (Div Return)"), equalTo("Portfolio (Net)"), equalTo("Bmk (Price Return)"),
							equalTo("Bmk (Gross)")));
			assertThat(summary.getPerformanceTypeCode(), anyOf(equalTo(PerformanceSummaryCode.PFT_CODE.getCode()), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()), equalTo(PerformanceSummaryCode.DIFF_CODE.getCode())));
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.DIFF_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.PFT_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_NET.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.BMK_NET.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(3.45).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(5.75).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(1.87).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(7.25).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(8.16).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(2.90).setScale(2, RoundingMode.HALF_UP)));
			}
			assertEquals(null, summary.getEffectiveBeginDate());
			assertEquals(summary.getEffectiveEndDate(), null);
			assertEquals(calledByUserId, summary.getLastUpdatedUserId());
			assertEquals(summary.getLastUpdatedDate(), null);
		}
	}

	@SuppressWarnings("unchecked")
	@Test
	public void serviceShouldCreateBmkNetRecordsWithNullValuesWhenNotAvailableInTarget() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = buildPerformanceSummaryListWithoutBmkNet(validEffectiveDate, PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		
		for(PerformanceSummary summary : performanceSummaries){
			assertEquals(summary.getEffectiveDate(), validEffectiveDate);
			assertEquals(summary.getPortId(), PORT_ID_1);
			assertThat(summary.getPerformanceTypeName(),
					anyOf(equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()),
							equalTo(PerformanceSummaryName.BMK_NET.getName()),
							equalTo(PerformanceSummaryName.DIFF.getName()),
							equalTo(PerformanceSummaryName.BMK_DIV_RETURN.getName()),
							equalTo(PerformanceSummaryName.PORTFOLIO_NET.getName()),
							equalTo(PerformanceSummaryName.BMK_PRICE_RETURN.getName()),
							equalTo(PerformanceSummaryName.BMK_GROSS.getName())));
			assertThat(summary.getPerformanceTypeCode(), anyOf(equalTo(PerformanceSummaryCode.PFT_CODE.getCode()), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()), equalTo(PerformanceSummaryName.DIFF.getName())));
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.DIFF_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName() .equals(PerformanceSummaryName.BMK_NET.getName())) {
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_DIV_RETURN.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.BMK_DIV_RETURN.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(3.45).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(5.75).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(1.87).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(7.25).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(8.16).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(2.90).setScale(2, RoundingMode.HALF_UP)));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_PRICE_RETURN.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.BMK_PRICE_RETURN.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(3.45).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(5.75).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(1.87).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(7.25).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(2.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(8.16).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(2.90).setScale(2, RoundingMode.HALF_UP)));
			}
			assertEquals(summary.getEffectiveBeginDate(), null);
			assertEquals(summary.getEffectiveEndDate(), null);
			assertEquals(calledByUserId, summary.getLastUpdatedUserId());
			assertEquals(summary.getLastUpdatedDate(), null);
		}
	}

	@Test
	public void serviceShouldDropOptionalRecordsWithNullValues() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = buildPerformanceSummaryListWithOptionalDataWithNullValues(validEffectiveDate, PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		
		for(PerformanceSummary summary : performanceSummaries){
			assertEquals(validEffectiveDate, summary.getEffectiveDate());
			assertEquals(summary.getPortId(), PORT_ID_1);
			assertThat(summary.getPerformanceTypeName(), not(anyOf(equalTo(PerformanceSummaryName.BMK_DIV_RETURN.getName()), 
					equalTo(PerformanceSummaryName.PORTFOLIO_NET.getName()), equalTo(PerformanceSummaryName.BMK_PRICE_RETURN.getName()), equalTo(PerformanceSummaryName.BMK_GROSS.getName()))));
		}
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryListWithOptionalDataWithNullValues(final Date effectiveDate, final String portId) {
		List<PerformanceCalculationDAO> daos = new ArrayList<>();

		daos.addAll(buildPerformanceSummary(effectiveDate, portId,PerformanceSummaryName.PORTFOLIO_GROSS.getName(), PerformanceSummaryName.BMK_NET.getName()));
		daos.addAll(buildPerformanceSummaryWithNullValues(effectiveDate, portId,PerformanceSummaryName.PORTFOLIO_NET.getName(), PerformanceSummaryName.BMK_DIV_RETURN.getName()));
		return daos;
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryWithNullValues(final Date effectiveDate, final String portId
			, final String bmkType, final String prtType) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(7);
		for(int i=0; i<10; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			c.setBmkType(bmkType);
			c.setPrtType(prtType);
			returnData.add(addNullToPerformanceCalculationDAO(c, i));
		}
		return returnData;
	}
	
	private PerformanceCalculationDAO addNullToPerformanceCalculationDAO(PerformanceCalculationDAO dao, int i){
		if (i == 0) {
			dao.setPeriod(CalculationPeriodEnum.CYTD);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 1) {
			dao.setPeriod(CalculationPeriodEnum.P1M);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 2) {
			dao.setPeriod(CalculationPeriodEnum.P3M);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 3) {
			dao.setPeriod(CalculationPeriodEnum.P6M);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 4) {
			dao.setPeriod(CalculationPeriodEnum.P1Y);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 5) {
			dao.setPeriod(CalculationPeriodEnum.P3YPA);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 6) {
			dao.setPeriod(CalculationPeriodEnum.P5YPA);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 7) {
			dao.setPeriod(CalculationPeriodEnum.PINCP);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 8) {
			dao.setPeriod(CalculationPeriodEnum.PINCEPPA);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 9) {
			dao.setPeriod(CalculationPeriodEnum.FYTD);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		}
		return dao;
	}

	@Test
	public void shouldRoundToTwoDecimalPlaces() {
		Date effectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		daos.addAll(buildPerformanceSummary(effectiveDate, PORT_ID_1,PerformanceSummaryName.BMK_NET.getName(),PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, effectiveDate, PORT_ID_1, calledByUserId);
		for(PerformanceSummary summary : performanceSummaries){
			if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.PFT_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(2.17).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(BigDecimal.valueOf(2.10).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeYearValue(), equalTo(BigDecimal.valueOf(4.20).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getFiveYearValue(), equalTo(BigDecimal.valueOf(3.79).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(6.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(1.99).setScale(2, RoundingMode.HALF_UP)));
			}
		}
	}

	@Test
	public void serviceShouldNotAddDataWithInvalidPerformanceSummaryName() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		daos.addAll(buildPerformanceSummary(validEffectiveDate, "PORT_ID","Portfolio (GrossSSSSS)", PerformanceSummaryName.BMK_NET.getName()));
		
		List<PerformanceSummary> testResultData = converter.convert(daos, validEffectiveDate, "PORT_ID", calledByUserId);
		PerformanceSummary portfolioGrossSSSSS = null;
		for (PerformanceSummary summary : testResultData) {
			if (summary.getPerformanceTypeName().equals("Portfolio (GrossSSSSS)")) {
				portfolioGrossSSSSS = summary;
			}
		}
		assertNull(portfolioGrossSSSSS);
		assertEquals(3, testResultData.size());
	}

	@Test
	public void serviceShouldNotCreatePortfolioGrossAndBmkNetandDiffDataWhenNoDataIsAvailableAndPortIdIsNull() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, null, calledByUserId);
		assertEquals(true, performanceSummaries.isEmpty());
	}

	@Test
	public void serviceShouldCreatePortfoliogrossAndBmkNetandDiffDataWhenNoDataIsAvailableAndPortIdIsValid() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		assertEquals(false, performanceSummaries.isEmpty());
		PerformanceSummary portfolioGross = null;
		PerformanceSummary bmkNet = null;
		PerformanceSummary diff = null;
		for (PerformanceSummary summary : performanceSummaries) {
			if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())) {
				portfolioGross = summary;
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_NET.getName())) {
				bmkNet = summary;
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				diff = summary;
			}
		}
		assertEquals(true, null != portfolioGross);
		assertEquals(true, null != bmkNet);
		assertEquals(true, null != diff);
	}

	@SuppressWarnings("unchecked")
	@Test
	public void serviceShouldNotDropOptionalRecordsWithValues() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = buildPerformanceSummaryListWithOptionalDataWithValues(validEffectiveDate, PORT_ID_1);
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		
		for(PerformanceSummary summary : performanceSummaries){
			assertEquals(validEffectiveDate, summary.getEffectiveDate());
			assertEquals(summary.getPortId(), PORT_ID_1);
			assertThat(summary.getPerformanceTypeName(),
					anyOf(equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()), equalTo(PerformanceSummaryName.BMK_NET.getName()), equalTo(PerformanceSummaryName.DIFF.getName()),
							equalTo(PerformanceSummaryName.BMK_DIV_RETURN.getName()), equalTo(PerformanceSummaryName.PORTFOLIO_NET.getName()), equalTo(PerformanceSummaryName.BMK_PRICE_RETURN.getName()),
							equalTo(PerformanceSummaryName.BMK_GROSS.getName())));
			assertThat(summary.getPerformanceTypeCode(), anyOf(equalTo(PerformanceSummaryCode.PFT_CODE.getCode()), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()), equalTo(PerformanceSummaryName.DIFF.getName())));
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.PFT_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName() .equals(PerformanceSummaryName.BMK_NET.getName())) {
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_DIV_RETURN.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.BMK_DIV_RETURN.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(2.17).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(6.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(2.90).setScale(2, RoundingMode.HALF_UP)));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.BMK_PRICE_RETURN.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.BMK_PRICE_RETURN.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getThreeMonthValue(), equalTo(BigDecimal.valueOf(2.15).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getSixMonthValue(), equalTo(BigDecimal.valueOf(2.17).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(BigDecimal.valueOf(6.11).setScale(2, RoundingMode.HALF_UP)));
				assertThat(summary.getYearToDateValue(), equalTo(BigDecimal.valueOf(2.90).setScale(2, RoundingMode.HALF_UP)));
			}
			assertEquals(summary.getEffectiveBeginDate(), null);
			assertEquals(summary.getEffectiveEndDate(), null);
			assertEquals(calledByUserId, summary.getLastUpdatedUserId());
			assertEquals(summary.getLastUpdatedDate(), null);
			assertEquals(summary.getPerformanceSummaryId(), null);
		}
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryListWithOptionalDataWithValues(final Date effectiveDate, final String portId) {
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		daos.addAll(buildPerformanceSummaryWithFewValues(effectiveDate, portId,PerformanceSummaryName.BMK_DIV_RETURN.getName(),PerformanceSummaryName.PORTFOLIO_NET.getName()));
		daos.addAll(buildPerformanceSummaryWithFewValues(effectiveDate, portId,PerformanceSummaryName.BMK_PRICE_RETURN.getName(),PerformanceSummaryName.PORTFOLIO_NET.getName()));
		daos.addAll(buildPerformanceSummaryWithFewValues(effectiveDate, portId,PerformanceSummaryName.BMK_GROSS.getName(),PerformanceSummaryName.PORTFOLIO_NET.getName()));
		daos.addAll(buildPerformanceSummaryWithFewValues(effectiveDate, portId,PerformanceSummaryName.BMK_PRICE_RETURN.getName(),PerformanceSummaryName.PORTFOLIO_NET.getName()));
		return daos;
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryWithFewValues(final Date effectiveDate, final String portId
			, final String bmkType, final String prtType) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(7);
		for(int i=0; i<7; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			c.setBmkType(bmkType);
			c.setPrtType(prtType);
			returnData.add(addFewValuesToPerformanceCalculationDAO(c, i));
		}
		return returnData;
	}
	
	private PerformanceCalculationDAO addFewValuesToPerformanceCalculationDAO(PerformanceCalculationDAO dao, int i){
		if (i == 0) {
			dao.setPeriod(CalculationPeriodEnum.CYTD);
			dao.setPrtVal(BigDecimal.valueOf(2.2357));
			dao.setBmkVal(BigDecimal.valueOf(2.2357));
		} else if (i == 1) {
			dao.setPeriod(CalculationPeriodEnum.P1M);
			dao.setPrtVal(BigDecimal.valueOf(2.1527));
			dao.setBmkVal(BigDecimal.valueOf(2.1527));
		} else if (i == 2) {
			dao.setPeriod(CalculationPeriodEnum.P3M);
			dao.setPrtVal(BigDecimal.valueOf(2.1527));
			dao.setBmkVal(BigDecimal.valueOf(2.1527));
		} else if (i == 3) {
			dao.setPeriod(CalculationPeriodEnum.P6M);
			dao.setPrtVal(BigDecimal.valueOf(2.167));
			dao.setBmkVal(BigDecimal.valueOf(2.167));
		} else if (i == 4) {
			dao.setPeriod(CalculationPeriodEnum.PINCP);
			dao.setPrtVal(BigDecimal.valueOf(6.1070));
			dao.setBmkVal(BigDecimal.valueOf(6.1070));
		} else if (i == 5) {
			dao.setPeriod(CalculationPeriodEnum.PINCEPPA);
			dao.setPrtVal(BigDecimal.valueOf(19.057));
			dao.setBmkVal(BigDecimal.valueOf(19.057));
		} else if (i == 6) {
			dao.setPeriod(CalculationPeriodEnum.FYTD);
			dao.setPrtVal(BigDecimal.valueOf(2.9027));
			dao.setBmkVal(BigDecimal.valueOf(2.9027));
		}
		return dao;
	}
	
	@Test
	public void serviceShouldCreateRequiredRecordsWithNullValuesWhenNoDataIsPresent() {
		PerformanceSummaryDataConverter converter = new PerformanceSummaryDataConverter();
		Date validEffectiveDate = new Date();
		String calledByUserId = "UXYZ";
		List<PerformanceCalculationDAO> daos = new ArrayList<>();
		List<PerformanceSummary> performanceSummaries = converter.convert(daos, validEffectiveDate, PORT_ID_1, calledByUserId);
		
		for(PerformanceSummary summary : performanceSummaries){
			assertEquals(validEffectiveDate, summary.getEffectiveDate());
			assertEquals(summary.getPortId(), PORT_ID_1);
			assertThat(summary.getPerformanceTypeName(),
					anyOf(equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()), equalTo(PerformanceSummaryName.BMK_NET.getName()), equalTo(PerformanceSummaryName.DIFF.getName())));
			assertThat(summary.getPerformanceTypeCode(), anyOf(equalTo(PerformanceSummaryCode.PFT_CODE.getCode()), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()), equalTo(PerformanceSummaryCode.DIFF_CODE.getCode())));
			if(summary.getPerformanceTypeName().equals(PerformanceSummaryName.DIFF.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryName.DIFF.getName()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName().equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())) {
				assertThat(summary.getPerformanceTypeName(), equalTo(PerformanceSummaryName.PORTFOLIO_GROSS.getName()));
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.PFT_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			} else if (summary.getPerformanceTypeName() .equals(PerformanceSummaryName.BMK_NET.getName())) {
				assertThat(summary.getPerformanceTypeCode(), equalTo(PerformanceSummaryCode.BMK_CODE.getCode()));
				assertThat(summary.getOneMonthValue(), equalTo(null));
				assertThat(summary.getThreeMonthValue(), equalTo(null));
				assertThat(summary.getSixMonthValue(), equalTo(null));
				assertThat(summary.getNineMonthValue(), equalTo(null));
				assertThat(summary.getOneYearValue(), equalTo(null));
				assertThat(summary.getThreeYearValue(), equalTo(null));
				assertThat(summary.getFiveYearValue(), equalTo(null));
				assertThat(summary.getTenYearValue(), equalTo(null));
				assertThat(summary.getInceptionValue(), equalTo(null));
				assertThat(summary.getYearToDateValue(), equalTo(null));
			}
			assertEquals(summary.getEffectiveBeginDate(), null);
			assertEquals(summary.getEffectiveEndDate(), null);
			assertEquals(calledByUserId, summary.getLastUpdatedUserId());
			assertEquals(summary.getLastUpdatedDate(), null);
			assertEquals(summary.getPerformanceSummaryId(), null);
		}
	}
	
}


com.vanguard.corp.ics.sdt.behaviors.datatransfer.risksummary

	LimitValidatorTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.risksummary;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.LimitValidator;

public class LimitValidatorTest {

	private LimitValidator classUnderTest = new LimitValidator();
	
	@Test
	public void validWhenAnalyticTypeIsNotExAnte() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.ONE_YR_EX_POST;
		BigDecimal lowerLimit = null;
		BigDecimal upperLimit = null;
		BigDecimal splitLimit = null;
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertTrue(valid);
	}

	@Test
	public void validWhenAnalyticTypeIsExAnteAndAllLimitsAreNull() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = null;
		BigDecimal upperLimit = null;
		BigDecimal splitLimit = null;
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertTrue(valid);
	}
	
	@Test
	public void validWhenAnalyticTypeIsExAnteAndOnlyLowerLimitExists() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = new BigDecimal("1");
		BigDecimal upperLimit = null;
		BigDecimal splitLimit = null;
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertTrue(valid);
	}
	
	@Test
	public void validWhenAnalyticTypeIsExAnteAndAllLimitsExist() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = new BigDecimal("1");
		BigDecimal upperLimit = new BigDecimal("2");
		BigDecimal splitLimit = new BigDecimal("50000000");
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertTrue(valid);
	}
	
	@Test
	public void invalidWhenAnalyticTypeIsExAnteAndOnlyUpperLimitExists() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = null;
		BigDecimal upperLimit = new BigDecimal("2");
		BigDecimal splitLimit = null;
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertFalse(valid);
	}
	
	@Test
	public void invalidWhenAnalyticTypeIsExAnteAndOnlySplitLimitExists() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = null;
		BigDecimal upperLimit = null;
		BigDecimal splitLimit = new BigDecimal("50000000");
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertFalse(valid);
	}
	
	@Test
	public void invalidWhenAnalyticTypeIsExAnteAndOnlyLowerAndUpperLimitsExist() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = new BigDecimal("1");
		BigDecimal upperLimit = new BigDecimal("2");
		BigDecimal splitLimit = null;
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertFalse(valid);
	}
	
	@Test
	public void invalidWhenAnalyticTypeIsExAnteAndOnlyLowerAndSplitLimitsExist() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = new BigDecimal("1");
		BigDecimal upperLimit = null;
		BigDecimal splitLimit = new BigDecimal("50000000");
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertFalse(valid);
	}
	
	@Test
	public void invalidWhenAnalyticTypeIsExAnteAndOnlyUpperAndSplitLimitsExist() {
		AnalyticsTypeCode analyticType = AnalyticsTypeCode.EX_ANTE_RISK;
		BigDecimal lowerLimit = null;
		BigDecimal upperLimit = new BigDecimal("2");
		BigDecimal splitLimit = new BigDecimal("50000000");
		
		boolean valid = classUnderTest.isValid(analyticType, lowerLimit, upperLimit, splitLimit);
		
		assertFalse(valid);
	}
}


	RiskSummaryTransfersTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.behaviors.datatransfer.risksummary;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestPortfolioLimitRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.GenerateLimitException;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadProductPortalException;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.LimitValidator;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.RiskSummaryServiceImpl;


public class RiskSummaryTransfersTest {

	private static final String PORT_ID_1 = "PORT01";
	private static final String PORT_ID_2 = "PORT02";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final BigDecimal hundred = new BigDecimal("100");

	@InjectMocks
	private TransferService classUnderTest = new RiskSummaryServiceImpl();

	@Mock
	private ProductPortalService productPortalService;

	@Spy
	private TestPortfolioLimitRepository repo = new TestPortfolioLimitRepository();

	@Mock
	private HttpServletRequest request;
	
	@Mock
	private LimitValidator limitValidator;
	
	private List<PortalProduct> portalProducts;
	
	private List<Limit> limitList;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		
		portalProducts = new ArrayList<>();
		limitList = new ArrayList<>();
		
		when(repo.findByPortfolioCodeAndEffectiveEndDateIsNull(any(String.class))).thenReturn(limitList);
	}

	@Test
	public void serviceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, classUnderTest.getPriority());
	}

	@Test
	public void serviceWantsToHandleRiskSummaryDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, DataSetType.RISK_SUMMARY, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(classUnderTest.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsExceptionWhenCalledByUserIdIsNull() {
		classUnderTest.transfer(null, null, null, null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsExceptionWhenCalledByUserIdIsEmpty() {
		classUnderTest.transfer(null, null, "", null);
	}

	@Test(expected=ReadProductPortalException.class)
	public void serviceThrowsExceptionWhenPortIdIsNull() {
		classUnderTest.transfer(null, null, CURRENT_USERNAME, null);
	}

	@Test
	public void serviceTransfersNoLimitsForGivenPortId() {
		PortalProduct product = new PortalProduct();
		
		product.setProductCode(PORT_ID_1);
		
		portalProducts.add(product);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, CURRENT_USERNAME, request);
		
		Limit limit = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertNull(limit.getLowerLimitValue());
		assertNull(limit.getUpperLimitValue());
		assertNull(limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
	}

	@Test
	public void serviceTransfersExAnteRiskForGivenPortId() {
		PortalProduct product = new PortalProduct();
		BigDecimal portalLowerLimit = new BigDecimal("123.45678");
		BigDecimal tableLowerLimit = portalLowerLimit.divide(hundred);
		
		product.setProductCode(PORT_ID_1);
		product.setExAnteMaxBreachIMA(portalLowerLimit);
		portalProducts.add(product);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, CURRENT_USERNAME, request);
		
		Limit limit = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertEquals(tableLowerLimit, limit.getLowerLimitValue());
		assertNull(limit.getUpperLimitValue());
		assertNull(limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		

		Limit limit3 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
	}
	
	@Test
	public void serviceTranfersExAnteRiskWithUpperAndSplitLimitForGivenPortId() {
		PortalProduct product = new PortalProduct();
		BigDecimal portalLowerLimit = new BigDecimal("123.45678");
		BigDecimal tableLowerLimit = portalLowerLimit.divide(hundred);
		BigDecimal portalUpperLimit = new BigDecimal("246.91356");
		BigDecimal tableUpperLimit = portalUpperLimit.divide(hundred);
		BigDecimal fumSplitLimit = new BigDecimal("50000000");
		
		product.setProductCode(PORT_ID_1);
		product.setExAnteMaxBreachIMA(portalLowerLimit);
		product.setExAnteMaxBreachIMAAbove(portalUpperLimit);
		product.setFumLimitexAnte(fumSplitLimit);

		portalProducts.add(product);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, CURRENT_USERNAME, request);
		
		Limit limit = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertEquals(tableLowerLimit, limit.getLowerLimitValue());
		assertEquals(tableUpperLimit, limit.getUpperLimitValue());
		assertEquals(fumSplitLimit, limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
	}
	
	@Test
	public void serviceTransfersExPostRiskForGivenPortId() {
		PortalProduct product = new PortalProduct();
		BigDecimal portalLowerLimit = new BigDecimal("123.45678");
		BigDecimal tableLowerLimit = portalLowerLimit.divide(hundred);
		
		product.setProductCode(PORT_ID_1);
		product.setExPostMaxBreachIMA(portalLowerLimit);
		
		portalProducts.add(product);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, CURRENT_USERNAME, request);
		
		Limit limit = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertNull(limit.getLowerLimitValue());
		assertNull(limit.getUpperLimitValue());
		assertNull(limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertEquals(tableLowerLimit, limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertEquals(tableLowerLimit, limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
	}
	
	@Test
	public void serviceTransfersExAnteRiskForAllPortIds() {
		PortalProduct product = new PortalProduct();
		BigDecimal portalLowerLimit = new BigDecimal("123.45678");
		BigDecimal tableLowerLimit = portalLowerLimit.divide(hundred);
		product.setProductCode(PORT_ID_1);
		product.setExAnteMaxBreachIMA(portalLowerLimit);
		portalProducts.add(product);
		
		PortalProduct product2 = new PortalProduct();
		BigDecimal portalLowerLimit2 = new BigDecimal("246.91356");
		BigDecimal tableLowerLimit2 = portalLowerLimit2.divide(hundred);
		product2.setProductCode(PORT_ID_2);
		product2.setExAnteMaxBreachIMA(portalLowerLimit2);
		portalProducts.add(product2);
			
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		
		classUnderTest.transfer(null, null, CURRENT_USERNAME, request);
		
		Limit firstPortLimit = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(firstPortLimit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), firstPortLimit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), firstPortLimit.getLimitTypeCode());
		assertEquals(tableLowerLimit, firstPortLimit.getLowerLimitValue());
		assertNull(firstPortLimit.getUpperLimitValue());
		assertNull(firstPortLimit.getFumSplitLimitValue());
		
		Limit firstPortLimit2 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(firstPortLimit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), firstPortLimit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), firstPortLimit2.getLimitTypeCode());
		assertNull(firstPortLimit2.getLowerLimitValue());
		assertNull(firstPortLimit2.getUpperLimitValue());
		assertNull(firstPortLimit2.getFumSplitLimitValue());
		
		Limit firstPortLimit3 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(firstPortLimit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), firstPortLimit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), firstPortLimit3.getLimitTypeCode());
		assertNull(firstPortLimit3.getLowerLimitValue());
		assertNull(firstPortLimit3.getUpperLimitValue());
		assertNull(firstPortLimit3.getFumSplitLimitValue());
		
		Limit secondPortLimit = repo.dataMap.get(PORT_ID_2 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(secondPortLimit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), secondPortLimit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), secondPortLimit.getLimitTypeCode());
		assertEquals(tableLowerLimit2, secondPortLimit.getLowerLimitValue());
		assertNull(secondPortLimit.getUpperLimitValue());
		assertNull(secondPortLimit.getFumSplitLimitValue());
		
		Limit secondPortLimit2 = repo.dataMap.get(PORT_ID_2 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(secondPortLimit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), secondPortLimit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), secondPortLimit2.getLimitTypeCode());
		assertNull(secondPortLimit2.getLowerLimitValue());
		assertNull(secondPortLimit2.getUpperLimitValue());
		assertNull(secondPortLimit2.getFumSplitLimitValue());
		
		Limit secondPortLimit3 = repo.dataMap.get(PORT_ID_2 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(secondPortLimit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), secondPortLimit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), secondPortLimit3.getLimitTypeCode());
		assertNull(secondPortLimit3.getLowerLimitValue());
		assertNull(secondPortLimit3.getUpperLimitValue());
		assertNull(secondPortLimit3.getFumSplitLimitValue());
	}
	
	@Test
	public void serviceThrowsGenerateLimitExceptionForInvalidExAnteRisk() {
		PortalProduct product = new PortalProduct();
		BigDecimal portalLowerLimit = new BigDecimal("123.45678");
		BigDecimal portalUpperLimit = new BigDecimal("246.91356");
		BigDecimal fumSplitLimit = null;
		
		product.setProductCode(PORT_ID_1);
		product.setExAnteMaxBreachIMA(portalLowerLimit);
		product.setExAnteMaxBreachIMAAbove(portalUpperLimit);
		product.setFumLimitexAnte(fumSplitLimit);
		
		portalProducts.add(product);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(false);
		
		try {
			classUnderTest.transfer(null, PORT_ID_1, CURRENT_USERNAME, request);
		}
		catch (GenerateLimitException e){
			assertEquals("Received invalid limits for " + PORT_ID_1 + " portfolio", e.getMessage());
		}
	}
	
	@Test
	public void serviceEndDatesExistingRecordsForGivenPortId() {
		PortalProduct product = new PortalProduct();
		
		product.setProductCode(PORT_ID_1);
		
		portalProducts.add(product);
		
		Limit existingLimit = new Limit();
		existingLimit.setPortfolioCode(PORT_ID_2);
		existingLimit.setLimitTypeCode(AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		existingLimit.setLimitName(AnalyticsTypeCode.EX_ANTE_RISK.getName());
		
		limitList.add(existingLimit);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, CURRENT_USERNAME, request);
		
		Limit endDatedExistingLimit = repo.dataMap.get(PORT_ID_2 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(endDatedExistingLimit.getEffectiveEndDate());
		
		Limit limit = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertNull(limit.getLowerLimitValue());
		assertNull(limit.getUpperLimitValue());
		assertNull(limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(PORT_ID_1 + AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
	}
	
	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsExceptionIfProductCodeIsNotInProductPortal() {
		PortalProduct product = new PortalProduct();
		product.setProductCode(PORT_ID_1);
		portalProducts.add(product);
		
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
		classUnderTest.transfer(null, PORT_ID_2, CURRENT_USERNAME, request);
	}
	
	@Test(expected=ReadProductPortalException.class)
	public void serviceThrowsExceptionIfProductPortalMalfunctions() {
		when(productPortalService.getProducts(request)).thenThrow(new RuntimeException("Test Exception"));
		classUnderTest.transfer(new Date(), null, CURRENT_USERNAME, request);
	}
	
	@Test(expected=ReadProductPortalException.class)
	public void serviceThrowsExceptionIfProductPortalIsEmpty() {
		when(productPortalService.getProducts(request)).thenReturn(new ArrayList<>());
		classUnderTest.transfer(null, null, CURRENT_USERNAME, request);
	}
}

com.vanguard.corp.ics.sdt.dao.api.constants

	RestServiceConstantsTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class RestServiceConstantsTest {

	@Test
	public void testConstants() {
		assertEquals("dd-MMM-yyyy", RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT);
	}
	
}

com.vanguard.corp.ics.sdt.dao.api.domain.portal

	CurrencyTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class CurrencyTest {

	@Test
	public void shouldGetAndSetValues() {
		Currency currency = new Currency();
		
		Long currencyId = Long.valueOf(1);
		String currencyCode = "AUD";
		String currencyName = "Australian Dollar123";
		
		currency.setCurrencyId(currencyId);
		currency.setCurrencyCode(currencyCode);
		currency.setCurrencyName(currencyName);
		
		assertEquals(currency.getCurrencyId(), currencyId);
		assertEquals(currency.getCurrencyCode(), currencyCode);
		assertEquals(currency.getCurrencyName(), currencyName);
	}
	
	@Test
	public void shouldGetAndSetValuesWithNull() {
		Currency currency = new Currency();
		
		currency.setCurrencyId(null);
		currency.setCurrencyCode(null);
		currency.setCurrencyName(null);
		
		assertNull(currency.getCurrencyId());
		assertNull(currency.getCurrencyCode());
		assertNull(currency.getCurrencyName());
	}
}

	InvestmentGroupTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class InvestmentGroupTest {
	
	public static final String INVSTMNT_GRP_CODE = "Test Investment Group Code";
	public static final String INVSTMNT_GRP_NAME = "Test Investment Group Name";

	/**
	 * Test getters and setters
	 */
	@Test
	public void shouldGetAndSetValues(){
		InvestmentGroup investmentGroup = new InvestmentGroup();
		
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupCode(INVSTMNT_GRP_CODE);
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);
		
		assertEquals(investmentGroup.getInvestmentGroupId(), Long.valueOf(1));
		assertEquals(investmentGroup.getInvestmentGroupCode(), INVSTMNT_GRP_CODE);
		assertEquals(investmentGroup.getInvestmentGroupName(), INVSTMNT_GRP_NAME);
	}
}



	PortalProductTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import static org.junit.Assert.assertEquals;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class PortalProductTest {
	
	@Test
	public void shouldGetAndSetValues() {
		PortalProduct portalProduct = new PortalProduct();
		
		Long productId = Long.valueOf(1);
		Long productTypeId = Long.valueOf(2);
		String productName = "ProductName";
		String clientId = "ClientID";
		String productCode = "ProductCode";
		String investmentStyleId = "InvestmentStyleID";
		String investmentObjective = "InvestmentObjective";
		Long assetClassId = Long.valueOf(3);
		Long investmentMarketId = Long.valueOf(4);
		Long investmentGroupId = Long.valueOf(5);
		Long baseCurrencyId = Long.valueOf(6);
		Long hedgeTypeId = Long.valueOf(7);
		Double hedgePercentage = 1.1;
		Long hedgeCurrencyId = Long.valueOf(8);
		Long benchmarkProviderId = Long.valueOf(9);
		String benchmarkName = "BenchmarkName";
		Long custodianId = Long.valueOf(10);
		Long futuresClearingAgentId = Long.valueOf(11);
		Double initialAum = 1.2;
		Long initialAumCurrencyId = Long.valueOf(12);
		Long productFundingTypeId = Long.valueOf(13);
		Long investmentManagementEntityId = Long.valueOf(14);
		Long contactingEntityId = Long.valueOf(15);
		Long salesTeamEntityId = Long.valueOf(16);
		String targetLaunchDate = "TargetLaunchDate";
		String inceptionDate = "InceptionDate";
		String terminationDate = "TerminationDate";
		String perfInceptionDate = "PerfInceptionDate";
		String perfTerminationDate = "PerfTemrinationDate";
		String targetTrackingRequiredFlag = "TargetTrackingRequiredFlag";
		Long portfolioReturnCalcID = Long.valueOf(17);
		Long cashFlowAssumpID = Long.valueOf(18);
		Long benchMarkCalcID = Long.valueOf(19);
		String fumBasedSplitTrackingFlag = "FumBasedSplitTrackingFlag";
		BigDecimal fumLimitexAnte = new BigDecimal(0.1);
		BigDecimal exAnteMaxBreachIMAAbove = new BigDecimal(0.2);
		BigDecimal exAnteMaxTriggernotificationAbove = new BigDecimal(0.3);
		BigDecimal exAnteMaxBreachIMA = new BigDecimal(0.4);
		BigDecimal exAnteMaxTriggernotification = new BigDecimal(0.5);
		BigDecimal exPostMaxBreachIMA = new BigDecimal(0.6);
		BigDecimal exPostMaxTriggernotification = new BigDecimal(0.7);
		Long statusId = Long.valueOf(17);
		String modifiedBy = "ModifiedBy";
		String modifiedDate = "2000-01-01";
		LocalDate modifiedLocalDate = LocalDate.parse(modifiedDate, DateTimeFormatter.ISO_LOCAL_DATE);
		Currency currency = new Currency();
		InvestmentGroup investmentGroup = new InvestmentGroup();
		
		portalProduct.setProductID(productId);
		portalProduct.setProductTypeID(productTypeId);
		portalProduct.setProductName(productName);
		portalProduct.setClientID(clientId);
		portalProduct.setProductCode(productCode);
		portalProduct.setInvestmentStyleID(investmentStyleId);
		portalProduct.setInvestmentObjective(investmentObjective);
		portalProduct.setAssetClassID(assetClassId);
		portalProduct.setInvestmentMarketID(investmentMarketId);
		portalProduct.setInvestmentGroupID(investmentGroupId);
		portalProduct.setBaseCurrencyID(baseCurrencyId);
		portalProduct.setHedgeTypeID(hedgeTypeId);
		portalProduct.setHedgePercentage(hedgePercentage);
		portalProduct.setHedgeCurrencyID(hedgeCurrencyId);
		portalProduct.setBenchMarkProviderID(benchmarkProviderId);
		portalProduct.setBenchMarkName(benchmarkName);
		portalProduct.setCustodianID(custodianId);
		portalProduct.setFuturesClearingAgentID(futuresClearingAgentId);
		portalProduct.setInitialAUM(initialAum);
		portalProduct.setInitialAUMCurrencyID(initialAumCurrencyId);
		portalProduct.setProductFundingTypeID(productFundingTypeId);
		portalProduct.setInvestmentManagementEntityID(investmentManagementEntityId);
		portalProduct.setContactingEntityID(contactingEntityId);
		portalProduct.setSalesTeamEntityID(salesTeamEntityId);
		portalProduct.setTargetLaunchDate(targetLaunchDate);
		portalProduct.setInceptionDate(inceptionDate);
		portalProduct.setTerminationDate(terminationDate);
		portalProduct.setPerfInceptionDate(perfInceptionDate);
		portalProduct.setPerfTerminationDate(perfTerminationDate);
		portalProduct.setTargetTrackingRequiredFlag(targetTrackingRequiredFlag);
		portalProduct.setPortfolioReturnCalcID(portfolioReturnCalcID);
		portalProduct.setCashFlowAssumpID(cashFlowAssumpID);
		portalProduct.setBenchMarkCalcID(benchMarkCalcID);
		portalProduct.setFumBasedSplitTrackingFlag(fumBasedSplitTrackingFlag);
		portalProduct.setFumLimitexAnte(fumLimitexAnte);
		portalProduct.setExAnteMaxBreachIMAAbove(exAnteMaxBreachIMAAbove);
		portalProduct.setExAnteMaxTriggernotificationAbove(exAnteMaxTriggernotificationAbove);
		portalProduct.setExAnteMaxBreachIMA(exAnteMaxBreachIMA);
		portalProduct.setExAnteMaxTriggernotification(exAnteMaxTriggernotification);
		portalProduct.setExPostMaxBreachIMA(exPostMaxBreachIMA);
		portalProduct.setExPostMaxTriggernotification(exPostMaxTriggernotification);
		portalProduct.setStatusID(statusId);
		portalProduct.setModifiedBy(modifiedBy);
		portalProduct.setModifiedDate(modifiedDate);
		portalProduct.setCurrency(currency);
		portalProduct.setInvestmentGroup(investmentGroup);
		
		assertEquals(portalProduct.getProductID(), productId);
		assertEquals(portalProduct.getProductTypeID(), productTypeId);
		assertEquals(portalProduct.getProductName(), productName);
		assertEquals(portalProduct.getClientID(), clientId);
		assertEquals(portalProduct.getProductCode(), productCode);
		assertEquals(portalProduct.getInvestmentStyleID(), investmentStyleId);
		assertEquals(portalProduct.getInvestmentObjective(), investmentObjective);
		assertEquals(portalProduct.getAssetClassID(), assetClassId);
		assertEquals(portalProduct.getInvestmentMarketID(), investmentMarketId);
		assertEquals(portalProduct.getInvestmentGroupID(), investmentGroupId);
		assertEquals(portalProduct.getBaseCurrencyID(), baseCurrencyId);
		assertEquals(portalProduct.getHedgeTypeID(), hedgeTypeId);
		assertEquals(portalProduct.getHedgePercentage(), hedgePercentage, 0);
		assertEquals(portalProduct.getHedgeCurrencyID(), hedgeCurrencyId);
		assertEquals(portalProduct.getBenchMarkProviderID(), benchmarkProviderId);
		assertEquals(portalProduct.getBenchMarkName(), benchmarkName);
		assertEquals(portalProduct.getCustodianID(), custodianId);
		assertEquals(portalProduct.getFuturesClearingAgentID(), futuresClearingAgentId);
		assertEquals(portalProduct.getInitialAUM(), initialAum, 0);
		assertEquals(portalProduct.getInitialAUMCurrencyID(), initialAumCurrencyId);
		assertEquals(portalProduct.getProductFundingTypeID(), productFundingTypeId);
		assertEquals(portalProduct.getInvestmentManagementEntityID(), investmentManagementEntityId);
		assertEquals(portalProduct.getContactingEntityID(), contactingEntityId);
		assertEquals(portalProduct.getSalesTeamEntityID(), salesTeamEntityId);
		assertEquals(portalProduct.getTargetLaunchDate(), targetLaunchDate);
		assertEquals(portalProduct.getInceptionDate(), inceptionDate);
		assertEquals(portalProduct.getTerminationDate(), terminationDate);
		assertEquals(portalProduct.getPerfInceptionDate(), perfInceptionDate);
		assertEquals(portalProduct.getPerfTerminationDate(), perfTerminationDate);
		assertEquals(portalProduct.getTargetTrackingRequiredFlag(), targetTrackingRequiredFlag);
		assertEquals(portalProduct.getPortfolioReturnCalcID(), portfolioReturnCalcID);
		assertEquals(portalProduct.getCashFlowAssumpID(), cashFlowAssumpID);
		assertEquals(portalProduct.getBenchMarkCalcID(), benchMarkCalcID);
		assertEquals(portalProduct.getFumBasedSplitTrackingFlag(), fumBasedSplitTrackingFlag);
		assertEquals(portalProduct.getFumLimitexAnte(), fumLimitexAnte);
		assertEquals(portalProduct.getExAnteMaxBreachIMAAbove(), exAnteMaxBreachIMAAbove);
		assertEquals(portalProduct.getExAnteMaxTriggernotificationAbove(), exAnteMaxTriggernotificationAbove);
		assertEquals(portalProduct.getExAnteMaxBreachIMA(), exAnteMaxBreachIMA);
		assertEquals(portalProduct.getExAnteMaxTriggernotification(), exAnteMaxTriggernotification);
		assertEquals(portalProduct.getExPostMaxBreachIMA(), exPostMaxBreachIMA);
		assertEquals(portalProduct.getExPostMaxTriggernotification(), exPostMaxTriggernotification);
		assertEquals(portalProduct.getStatusID(), statusId);
		assertEquals(portalProduct.getModifiedBy(), modifiedBy);
		assertEquals(modifiedLocalDate, portalProduct.getModifiedDate());
		assertEquals(portalProduct.getCurrency(), currency);
		assertEquals(portalProduct.getInvestmentGroup(), investmentGroup);
	}
}

com.vanguard.corp.ics.sdt.dao.impl.config
	PortalConfigurationTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.config;

import static org.junit.Assert.*;

import org.junit.Test;

public class PortalConfigurationTest {

	@Test
	public void testGettersAndSetters() {
		PortalConfiguration configuration = new PortalConfiguration();
		
		String anyPortalProductEndpoint = "TestPortalProductEndpoint";
		String anyPortalReferenceEndpoint = "TestPortalRefereceEndpoint";
		int anyRetryCount = 5;
		
		configuration.setPortalProductEndpoint(anyPortalProductEndpoint);
		configuration.setPortalReferenceEndpoint(anyPortalReferenceEndpoint);
		configuration.setMaxConnectionAttempts(anyRetryCount);
		
		assertEquals(anyPortalProductEndpoint, configuration.getPortalProductEndpoint());
		assertEquals(anyPortalReferenceEndpoint, configuration.getPortalReferenceEndpoint());
		assertEquals(anyRetryCount, configuration.getMaxConnectionAttempts());
	}

}

	ReportingDatabaseConfigurationTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.config;

import static org.junit.Assert.*;

import java.util.Map;

import org.apache.tomcat.jdbc.pool.DataSource;
import org.apache.tomcat.jdbc.pool.PoolConfiguration;
import org.apache.tomcat.jdbc.pool.PoolProperties;
import org.junit.Before;
import org.junit.Test;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.PlatformTransactionManager;

public class ReportingDatabaseConfigurationTest {

	private ReportingDatabaseConfiguration reportingDatabaseConfiguration;
	
	private String datasourceUsername = "testUser";
	private String datasourcePassword = "testPassword";
	private String datasourceUrl = "testUrl";
	
	@Before
	public void init() {
		reportingDatabaseConfiguration = new ReportingDatabaseConfiguration();
		
		ReflectionTestUtils.setField(reportingDatabaseConfiguration, "sdtDataSourceReportingUsername", datasourceUsername);
		ReflectionTestUtils.setField(reportingDatabaseConfiguration, "sdtDataSourceReportingPassword", datasourcePassword);
		ReflectionTestUtils.setField(reportingDatabaseConfiguration, "sdtReportingConnectionUrl", datasourceUrl);
	}
	
	@Test
	public void testDataSource() {
		DataSource testDataSource = reportingDatabaseConfiguration.dataSource();
		
		PoolProperties poolProperties = new PoolProperties();
		poolProperties.setUrl(datasourceUrl);
		poolProperties.setDriverClassName("oracle.jdbc.OracleDriver");
		poolProperties.setUsername(datasourceUsername);
		poolProperties.setPassword(datasourcePassword);
		poolProperties.setDefaultAutoCommit(false);
		poolProperties.setDefaultReadOnly(false);
		poolProperties.setDefaultTransactionIsolation(2);
		poolProperties.setJmxEnabled(false);
		poolProperties.setTestWhileIdle(true);
		poolProperties.setTestOnBorrow(true);
		poolProperties.setValidationQuery("SELECT 1 FROM DUAL");
		poolProperties.setTestOnReturn(false);
		poolProperties.setValidationInterval(30000);
		poolProperties.setTimeBetweenEvictionRunsMillis(30000);
		poolProperties.setMaxActive(1000);
		poolProperties.setInitialSize(5);
		poolProperties.setMaxWait(10000);
		poolProperties.setRemoveAbandonedTimeout(30);
		poolProperties.setMinEvictableIdleTimeMillis(30000);
		poolProperties.setMinIdle(10);
		poolProperties.setLogAbandoned(true);
		poolProperties.setRemoveAbandoned(true);
		poolProperties.setJdbcInterceptors("org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;"
				+ "org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");

		PoolConfiguration actualProperties = testDataSource.getPoolProperties();
		
		assertEquals(poolProperties.getUrl(), actualProperties.getUrl());
		assertEquals(poolProperties.getDriverClassName(), actualProperties.getDriverClassName());
		assertEquals(poolProperties.getUsername(), actualProperties.getUsername());
		assertEquals(poolProperties.getPassword(), actualProperties.getPassword());
		assertEquals(poolProperties.getDefaultAutoCommit(), actualProperties.getDefaultAutoCommit());
		assertEquals(poolProperties.getDefaultReadOnly(), actualProperties.getDefaultReadOnly());
		assertEquals(poolProperties.getDefaultTransactionIsolation(), actualProperties.getDefaultTransactionIsolation());
		assertEquals(poolProperties.isJmxEnabled(), actualProperties.isJmxEnabled());
		assertEquals(poolProperties.isTestWhileIdle(), actualProperties.isTestWhileIdle());
		assertEquals(poolProperties.isTestOnBorrow(), actualProperties.isTestOnBorrow());
		assertEquals(poolProperties.getValidationQuery(), actualProperties.getValidationQuery());
		assertEquals(poolProperties.isTestOnReturn(), actualProperties.isTestOnReturn());
		assertEquals(poolProperties.getValidationInterval(), actualProperties.getValidationInterval());
		assertEquals(poolProperties.getTimeBetweenEvictionRunsMillis(), actualProperties.getTimeBetweenEvictionRunsMillis());
		assertEquals(poolProperties.getMaxActive(), actualProperties.getMaxActive());
		assertEquals(poolProperties.getInitialSize(), actualProperties.getInitialSize());
		assertEquals(poolProperties.getMaxWait(), actualProperties.getMaxWait());
		assertEquals(poolProperties.getRemoveAbandonedTimeout(), actualProperties.getRemoveAbandonedTimeout());
		assertEquals(poolProperties.getMinEvictableIdleTimeMillis(), actualProperties.getMinEvictableIdleTimeMillis());
		assertEquals(poolProperties.getMinIdle(), actualProperties.getMinIdle());
		assertEquals(poolProperties.isLogAbandoned(), actualProperties.isLogAbandoned());
		assertEquals(poolProperties.isRemoveAbandoned(), actualProperties.isRemoveAbandoned());
		assertEquals(poolProperties.getJdbcInterceptors(), actualProperties.getJdbcInterceptors());
	}
	
	@Test
	public void testGetReportingEntityManagerFactory() {
		String testPersistenceUnitName = "GRMDB";
		String testHibernateDialect = "org.hibernate.dialect.Oracle10gDialect";
		boolean testHibernateShowSql = Boolean.FALSE;
		boolean testHibernateFormatSql = Boolean.FALSE;
		boolean testUseSqlComments = Boolean.FALSE;
		String testEnableLazyLoadNoTrans = "true";
	
		LocalContainerEntityManagerFactoryBean factory = reportingDatabaseConfiguration.getReportingEntityManagerFactory();
		
		Map<String, Object> properties = factory.getJpaPropertyMap();

		assertEquals(testPersistenceUnitName, factory.getPersistenceUnitName());
		assertEquals(testHibernateDialect, properties.get("hibernate.dialect"));
		assertEquals(testHibernateShowSql, properties.get("hibernate.show_sql"));
		assertEquals(testHibernateFormatSql, properties.get("hibernate.format_sql"));
		assertEquals(testUseSqlComments, properties.get("hibernate.use_sql_comments"));
		assertEquals(testEnableLazyLoadNoTrans, properties.get("hibernate.enable_lazy_load_no_trans"));
	}

	@Test
	public void testTransactionManager() {
		PlatformTransactionManager transactionManager = reportingDatabaseConfiguration.transactionManager();
		assertNotNull(transactionManager);
		assertTrue(transactionManager instanceof JpaTransactionManager);
	}
}


	SecurityMasterAccessConfigTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.config;

import static org.junit.Assert.assertNotNull;

import org.junit.Before;
import org.junit.Test;
import org.springframework.test.util.ReflectionTestUtils;

public class SecurityMasterAccessConfigTest {
	SecurityMasterAccessConfig unitUnderTest;

	@Before
	public void init() {
		unitUnderTest = new SecurityMasterAccessConfig();

		ReflectionTestUtils.setField(unitUnderTest, "sdlConnectionUrl", "testURL");
		ReflectionTestUtils.setField(unitUnderTest, "sdlDataSourceUsername", "testUserName");
		ReflectionTestUtils.setField(unitUnderTest, "sdlDataSourcePassword", "testPassword");
		ReflectionTestUtils.setField(unitUnderTest, "driverClassName", "testDriver");
		ReflectionTestUtils.setField(unitUnderTest, "showSQL", true);
	}

	@Test
	public void TestGetEntityManagerFactory() {
		assertNotNull(unitUnderTest.getEntityManagerFactory());
	}

}


com.vanguard.corp.ics.sdt.dao.impl.entity.report
	AccountBenchmarkAssociationTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.assertEquals;

import java.text.ParseException;
import java.util.Date;

import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class AccountBenchmarkAssociationTest {
	
	public static final String PORTFOLIO_ID = "Test Portfolio Id";
	public static final String BENCHMARK_EIP_ID = "Test Benchmark EIP ID";
	public static final String BENCHMARK_ASSOC_TYPE = "Test Benchmark Association Type";
	public static final String LAST_UPDATED_USER = "Test Last Updated User";
	public static final String BENCHMARK_NAME = "Test Benchmark Name";
	public static final Date EFFECTIVE_BEGIN_DATE = new Date(1);
	public static final Date EFFECTIVE_END_DATE = new Date(2);
	
	@InjectMocks
	private AccountBenchmarkAssociation accountBenchmarkAssociation, accountBenchmarkAssociation2;
	
	@Before
	public void init() throws ParseException {
		MockitoAnnotations.initMocks(this);
		
		accountBenchmarkAssociation.setId(Long.valueOf(1));
		accountBenchmarkAssociation.setPortfolioId(PORTFOLIO_ID);
		accountBenchmarkAssociation.setBenchmarkEipId(BENCHMARK_EIP_ID);
		accountBenchmarkAssociation.setBenchmarkAssociationType(BENCHMARK_ASSOC_TYPE);
		accountBenchmarkAssociation.setLastUpdatedUserId(LAST_UPDATED_USER);
		accountBenchmarkAssociation.setLastUpdatedDate(new Date(1));
		accountBenchmarkAssociation.setBenchmarkName(BENCHMARK_NAME);
		accountBenchmarkAssociation.setEffectiveBeginDate(EFFECTIVE_BEGIN_DATE);
		accountBenchmarkAssociation.setEffectiveEndDate(EFFECTIVE_END_DATE);
	}
	
	/**
	 * Test getters and setters 
	 */
	@Test
	public void shouldTestGettersAndSetters(){

		assertEquals(accountBenchmarkAssociation.getId(), Long.valueOf(1));
		assertEquals(accountBenchmarkAssociation.getPortfolioId(), PORTFOLIO_ID);
		assertEquals(accountBenchmarkAssociation.getBenchmarkEipId(), BENCHMARK_EIP_ID);
		assertEquals(accountBenchmarkAssociation.getBenchmarkAssociationType(), BENCHMARK_ASSOC_TYPE);
		assertEquals(accountBenchmarkAssociation.getLastUpdatedUserId(), LAST_UPDATED_USER);
		assertEquals(accountBenchmarkAssociation.getLastUpdatedDate(), new Date(1));
		assertEquals(accountBenchmarkAssociation.getBenchmarkName(), BENCHMARK_NAME);
		assertEquals(accountBenchmarkAssociation.getEffectiveBeginDate(), EFFECTIVE_BEGIN_DATE);
		assertEquals(accountBenchmarkAssociation.getEffectiveEndDate(), EFFECTIVE_END_DATE);
		
	}
}



	AccountFundTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.assertEquals;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class AccountFundTest {
	private final Long TEST_ID = Long.valueOf(1);
	private final String TEST_PORTFOLIO_ID = "Portfolio ID1";
	private final String TEST_ACCOUNT_SHORT_NAME = "Account Short Name";
	private final String TEST_ACCOUNT_NAME = "Account Name1";
	private final String TEST_ACCOUNT_TYPE = "Account Type1";
	private final Long TEST_ASSET_CLASSIFICATION_ID = Long.valueOf(2);
	private final Long TEST_PRODUCT_EIP_ID = Long.valueOf(3);
	private final String TEST_PORTFOLIO_MANAGER = "Portfolio Manager1";
	private final String TEST_MANAGEMENT_STRATEGY = "Management Stategy1";
	private final String TEST_PORTFOLIO_BASE_CURRENCY = "Portfolio Base Currency1";
	private final String TEST_UPDATED_USER = "Updated User1";
	private final Long TEST_PORTFOLIO_SIZE = Long.valueOf(4);
	private final Long TEST_PORTFOLIO_MANAGER_ID = Long.valueOf(5);
	private final String TEST_INVESTMENT_OBJECTIVE = "Investment Objective1";
	private final Date TEST_EFFECTIVE_BEGIN_DATE = new Date(1);
	private final Date TEST_EFFECTIVE_END_DATE = new Date(2);

	private Calendar cal;
	private SimpleDateFormat formatter;
	private String InceptionDateInString;
	private Date inceptionDate;
	private String UpdatedDateInString;
	private Date updatedDate;

	@InjectMocks
	private AccountFund accountFund, accountFund2, accountFund3;

	@Before
	public void init() throws ParseException {
		MockitoAnnotations.initMocks(this);

		cal = Calendar.getInstance();
		formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss");
		InceptionDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		inceptionDate = formatter.parse(InceptionDateInString);
		UpdatedDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		updatedDate = formatter.parse(UpdatedDateInString);

		accountFund.setId(TEST_ID);
		accountFund.setPortfolioId(TEST_PORTFOLIO_ID);
		accountFund.setAccountShortName(TEST_ACCOUNT_SHORT_NAME);
		accountFund.setAccountName(TEST_ACCOUNT_NAME);
		accountFund.setAccountType(TEST_ACCOUNT_TYPE);
		accountFund.setAssetClassificationId(TEST_ASSET_CLASSIFICATION_ID);
		accountFund.setProductEipID(TEST_PRODUCT_EIP_ID);
		accountFund.setManagementStrategy(TEST_MANAGEMENT_STRATEGY);
		accountFund.setPortfolioBaseCurrency(TEST_PORTFOLIO_BASE_CURRENCY);
		accountFund.setInceptionDate(inceptionDate);
		accountFund.setLastUpdatedUserId(TEST_UPDATED_USER);
		accountFund.setLastUpdatedDate(updatedDate);
		accountFund.setPortfolioSize(TEST_PORTFOLIO_SIZE);
		accountFund.setPortfolioManagerId(TEST_PORTFOLIO_MANAGER_ID);
		accountFund.setInvestmentObjective(TEST_INVESTMENT_OBJECTIVE);
		accountFund.setPortfolioManager(TEST_PORTFOLIO_MANAGER);
		accountFund.setEffectiveBeginDate(TEST_EFFECTIVE_BEGIN_DATE);
		accountFund.setEffectiveEndDate(TEST_EFFECTIVE_END_DATE);
	}

	@Test
	public void shouldTestGettersAndSetters() {

		assertEquals(TEST_ID, accountFund.getId());
		assertEquals(TEST_PORTFOLIO_ID, accountFund.getPortfolioId());
		assertEquals(TEST_ACCOUNT_SHORT_NAME, accountFund.getAccountShortName());
		assertEquals(TEST_ACCOUNT_NAME, accountFund.getAccountName());
		assertEquals(TEST_ACCOUNT_TYPE, accountFund.getAccountType());
		assertEquals(TEST_ASSET_CLASSIFICATION_ID, accountFund.getAssetClassificationId());
		assertEquals(TEST_PRODUCT_EIP_ID, accountFund.getProductEipID(), 0.0);
		assertEquals(TEST_MANAGEMENT_STRATEGY, accountFund.getManagementStrategy());
		assertEquals(TEST_PORTFOLIO_BASE_CURRENCY, accountFund.getPortfolioBaseCurrency());
		assertEquals(inceptionDate, accountFund.getInceptionDate());
		assertEquals(TEST_UPDATED_USER, accountFund.getLastUpdatedUserId());
		assertEquals(updatedDate, accountFund.getLastUpdatedDate());
		assertEquals(TEST_PORTFOLIO_SIZE, accountFund.getPortfolioSize());
		assertEquals(TEST_PORTFOLIO_MANAGER_ID, accountFund.getPortfolioManagerId());
		assertEquals(TEST_INVESTMENT_OBJECTIVE, accountFund.getInvestmentObjective());
		assertEquals(TEST_PORTFOLIO_MANAGER, accountFund.getPortfolioManager());
		assertEquals(TEST_EFFECTIVE_BEGIN_DATE, accountFund.getEffectiveBeginDate());
		assertEquals(TEST_EFFECTIVE_END_DATE, accountFund.getEffectiveEndDate());

	}

}


	AccountSetupTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import java.util.Calendar;

@RunWith(MockitoJUnitRunner.class)
public class AccountSetupTest {

	private final Long TEST_ID = Long.valueOf(1);
	private final String TEST_PORTFOLIO_ID = "Portfolio ID1";
	private final String TEST_ACCOUNT_CLIENT_NAME = "Account Client Name1";
	private final String TEST_ADDRESS_LINE_ONE = " Address Line1";
	private final String TEST_ADDRESS_LINE_TWO = " address Line2";
	private final String TEST_ADDRESS_LINE_THREE = "Address Line3";
	private final String TEST_COUNTRY_NAME = "Country Name1";
	private final String TEST_POSTAL_CODE = "Postal Code1";
	private final String TEST_STATUS_CODE = "Status Code1";
	private final String TEST_UPDATED_USER = "Updated User1";
	private final Date TEST_EFECTIVE_BEGIN_DATE = new Date(1);
	private final Date TEST_EFFECTIVE_END_DATE = new Date(2);

	private Calendar cal;
	private SimpleDateFormat formatter;
	private String BeginDateInString;
	private Date beginDate;
	private String EndDateInString;
	private Date endDate;
	private String UpdatedDateInString;
	private Date updatedDate;

	@InjectMocks
	private AccountSetup accountSetup, accountSetup2, accountSetup3;

	@Before
	public void init() throws ParseException {
		MockitoAnnotations.initMocks(this);

		cal = Calendar.getInstance();
		formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss");
		BeginDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		beginDate = formatter.parse(BeginDateInString);
		EndDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		endDate = formatter.parse(EndDateInString);
		UpdatedDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		updatedDate = formatter.parse(UpdatedDateInString);

		accountSetup.setId(TEST_ID);
		accountSetup.setPortfolioId(TEST_PORTFOLIO_ID);
		accountSetup.setAccountClientName(TEST_ACCOUNT_CLIENT_NAME);
		accountSetup.setAddressLineOne(TEST_ADDRESS_LINE_ONE);
		accountSetup.setAddressLineTwo(TEST_ADDRESS_LINE_TWO);
		accountSetup.setAddressLineThree(TEST_ADDRESS_LINE_THREE);
		accountSetup.setCountryName(TEST_COUNTRY_NAME);
		accountSetup.setPostalCode(TEST_POSTAL_CODE);
		accountSetup.setAgreementBeginDate(beginDate);
		accountSetup.setAgreementEndDate(endDate);
		accountSetup.setStatusCode(TEST_STATUS_CODE);
		accountSetup.setLastUpdatedUserId(TEST_UPDATED_USER);
		accountSetup.setLastUpdatedDate(updatedDate);
		accountSetup.setEffectiveBeginDate(TEST_EFECTIVE_BEGIN_DATE);
		accountSetup.setEffectiveEndDate(TEST_EFFECTIVE_END_DATE);
	}

	@Test
	public void shouldTestGettersAndSetters() {

		assertEquals(TEST_ID, accountSetup.getId());
		assertEquals(TEST_PORTFOLIO_ID, accountSetup.getPortfolioId());
		assertEquals(TEST_ACCOUNT_CLIENT_NAME, accountSetup.getAccountClientName());
		assertEquals(TEST_ADDRESS_LINE_ONE, accountSetup.getAddressLineOne());
		assertEquals(TEST_ADDRESS_LINE_TWO, accountSetup.getAddressLineTwo());
		assertEquals(TEST_ADDRESS_LINE_THREE, accountSetup.getAddressLineThree());
		assertEquals(TEST_COUNTRY_NAME, accountSetup.getCountryName());
		assertEquals(TEST_POSTAL_CODE, accountSetup.getPostalCode());
		assertEquals(beginDate, accountSetup.getAgreementBeginDate());
		assertEquals(beginDate, accountSetup.getAgreementEndDate());
		assertEquals(TEST_STATUS_CODE, accountSetup.getStatusCode());
		assertEquals(TEST_UPDATED_USER, accountSetup.getLastUpdatedUserId());
		assertEquals(updatedDate, accountSetup.getLastUpdatedDate());
		assertEquals(TEST_EFECTIVE_BEGIN_DATE, accountSetup.getEffectiveBeginDate());
		assertEquals(TEST_EFFECTIVE_END_DATE, accountSetup.getEffectiveEndDate());
	}

}


	BrokerageAndTaxesTargetDAOTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.dao.impl.entity.target.BrokerageAndTaxesTargetDAO;

public class BrokerageAndTaxesTargetDAOTest {
	
	public static final String TEST_PORT_ID = "TEST01";
	public static final Date TEST_EFFTV_DT = new Date(1);
	public static final String TEST_FUND_CHARGE_TYPE = "TAXES";
	public static final String TEST_FUND_CHARGE_CURRENCY = "AUD";
	public static final String TEST_FUND_CHARGE_FREQUENCY = "1MO";
	public static final BigDecimal TEST_FUND_CHARGE_AMOUNT = new BigDecimal(1);
	public static final Date TEST_EFFECTIVE_BEGIN = new Date(2);
	public static final Date TEST_EFFECTIVE_END = new Date(3);
	public static final String TEST_LAST_UPDATED_USER = "Test user";
	public static final Date TEST_LAST_UPDATED_TIMESTAMP = new Date(4);

	@Test
	public void shouldTestGettersAndSetters() {
		BrokerageAndTaxesTargetDAO brokerageTaxesDao = new BrokerageAndTaxesTargetDAO();
		
		brokerageTaxesDao.setId(1L);
		brokerageTaxesDao.setPortfolioCode(TEST_PORT_ID);
		brokerageTaxesDao.setAsOfDate(TEST_EFFTV_DT);
		brokerageTaxesDao.setFundChargeType(TEST_FUND_CHARGE_TYPE);
		brokerageTaxesDao.setFundChargeCurrency(TEST_FUND_CHARGE_CURRENCY);
		brokerageTaxesDao.setFundChargeFrequency(TEST_FUND_CHARGE_FREQUENCY);
		brokerageTaxesDao.setFundChargeAmount(TEST_FUND_CHARGE_AMOUNT);
		brokerageTaxesDao.setEffectiveBeginDate(TEST_EFFECTIVE_BEGIN);
		brokerageTaxesDao.setEffectiveEndDate(TEST_EFFECTIVE_END);
		brokerageTaxesDao.setUpdatedUser(TEST_LAST_UPDATED_USER);
		brokerageTaxesDao.setUpdatedDate(TEST_LAST_UPDATED_TIMESTAMP);
		
		assertEquals(Long.valueOf(1), brokerageTaxesDao.getId());
		assertEquals(TEST_PORT_ID, brokerageTaxesDao.getPortfolioCode());
		assertEquals(TEST_EFFTV_DT, brokerageTaxesDao.getAsOfDate());
		assertEquals(TEST_FUND_CHARGE_TYPE, brokerageTaxesDao.getFundChargeType());
		assertEquals(TEST_FUND_CHARGE_CURRENCY, brokerageTaxesDao.getFundChargeCurrency());
		assertEquals(TEST_FUND_CHARGE_FREQUENCY, brokerageTaxesDao.getFundChargeFrequency());
		assertEquals(TEST_FUND_CHARGE_AMOUNT, brokerageTaxesDao.getFundChargeAmount());
		assertEquals(TEST_EFFECTIVE_BEGIN, brokerageTaxesDao.getEffectiveBeginDate());
		assertEquals(TEST_EFFECTIVE_END, brokerageTaxesDao.getEffectiveEndDate());
		assertEquals(TEST_LAST_UPDATED_USER, brokerageTaxesDao.getUpdatedUser());
		assertEquals(TEST_LAST_UPDATED_TIMESTAMP, brokerageTaxesDao.getUpdatedDate());
	}

}


	BrokerageAndTaxesTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;

public class BrokerageAndTaxesTest {

	public static final String TEST_PORT_ID = "TEST01";
	public static final Date TEST_EFFTV_DT = new Date(1);
	public static final String TEST_FUND_CHARGE_TYPE = "TAXES";
	public static final String TEST_FUND_CHARGE_CURRENCY = "AUD";
	public static final String TEST_FUND_CHARGE_FREQUENCY = "1MO";
	public static final BigDecimal TEST_FUND_CHARGE_AMOUNT = new BigDecimal(1);
	public static final Date TEST_EFFECTIVE_BEGIN = new Date(2);
	public static final Date TEST_EFFECTIVE_END = new Date(3);
	public static final String TEST_LAST_UPDATED_USER = "Test user";
	public static final Date TEST_LAST_UPDATED_TIMESTAMP = new Date(4);
	public static final DatasourceFileDAO DATASOURCE_FILE_DAO = new DatasourceFileDAO();
	
	
	@Test
	public void shouldTestGettersAndSetters() {
		BrokerageAndTaxes brokerageAndTaxes = new BrokerageAndTaxes();
		
		brokerageAndTaxes.setId(1L);
		brokerageAndTaxes.setPortfolioId(TEST_PORT_ID);
		brokerageAndTaxes.setAsOfDate(TEST_EFFTV_DT);
		brokerageAndTaxes.setFundChargeType(TEST_FUND_CHARGE_TYPE);
		brokerageAndTaxes.setFundChargeCurrency(TEST_FUND_CHARGE_CURRENCY);
		brokerageAndTaxes.setFundChargeFrequency(TEST_FUND_CHARGE_FREQUENCY);
		brokerageAndTaxes.setFundChargeAmount(TEST_FUND_CHARGE_AMOUNT);
		brokerageAndTaxes.setEffectiveBeginDate(TEST_EFFECTIVE_BEGIN);
		brokerageAndTaxes.setEffectiveEndDate(TEST_EFFECTIVE_END);
		brokerageAndTaxes.setLastUpdatedUserId(TEST_LAST_UPDATED_USER);
		brokerageAndTaxes.setLastUpdatedDate(TEST_LAST_UPDATED_TIMESTAMP);
		brokerageAndTaxes.setDatasourceFileDAO(DATASOURCE_FILE_DAO);
		
		assertEquals(Long.valueOf(1), brokerageAndTaxes.getId());
		assertEquals(TEST_PORT_ID, brokerageAndTaxes.getPortfolioId());
		assertEquals(TEST_EFFTV_DT, brokerageAndTaxes.getAsOfDate());
		assertEquals(TEST_FUND_CHARGE_TYPE, brokerageAndTaxes.getFundChargeType());
		assertEquals(TEST_FUND_CHARGE_CURRENCY, brokerageAndTaxes.getFundChargeCurrency());
		assertEquals(TEST_FUND_CHARGE_FREQUENCY, brokerageAndTaxes.getFundChargeFrequency());
		assertEquals(TEST_FUND_CHARGE_AMOUNT, brokerageAndTaxes.getFundChargeAmount());
		assertEquals(TEST_EFFECTIVE_BEGIN, brokerageAndTaxes.getEffectiveBeginDate());
		assertEquals(TEST_EFFECTIVE_END, brokerageAndTaxes.getEffectiveEndDate());
		assertEquals(TEST_LAST_UPDATED_USER, brokerageAndTaxes.getLastUpdatedUserId());
		assertEquals(TEST_LAST_UPDATED_TIMESTAMP, brokerageAndTaxes.getLastUpdatedDate());
		assertEquals(DATASOURCE_FILE_DAO, brokerageAndTaxes.getDatasourceFileDAO());
	}

}
	LimitTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.assertEquals;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class LimitTest {
	
	private DateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);

	@Test
	public void shouldGetAndSetValues() throws Exception {
		Limit limit = new Limit();
		
		Long anyId = new Long(3);
		String uniquePortId = "TEST";
		Date anyEffectiveBeginDate = df.parse("2017-07-31");
		Date anyEffectiveEndDate = df.parse("2017-09-01");
		String anyLimitTypeCode = "TYPE";
		String anyLimitName = "Limit Name";
		BigDecimal anyLowerLimitValue = new BigDecimal(0.1);
		BigDecimal anyUpperLimitValue = new BigDecimal(0.2);
		BigDecimal anyFumSplitLimitValue = new BigDecimal(0.3);
		String anyUpdatedUser = "XXXX";
		Date anyUpdatedDate = df.parse("2017-08-03");
		
		limit.setId(anyId);
		limit.setPortfolioCode(uniquePortId);
		limit.setEffectiveBeginDate(anyEffectiveBeginDate);
		limit.setEffectiveEndDate(anyEffectiveEndDate);
		limit.setLimitTypeCode(anyLimitTypeCode);
		limit.setLimitName(anyLimitName);
		limit.setLowerLimitValue(anyLowerLimitValue);
		limit.setUpperLimitValue(anyUpperLimitValue);
		limit.setFumSplitLimitValue(anyFumSplitLimitValue);		
		limit.setLastUpdatedUserId(anyUpdatedUser);
		limit.setLastUpdatedDate(anyUpdatedDate);

		assertEquals(limit.getId(), anyId);
		assertEquals(limit.getPortfolioCode(), uniquePortId);
		assertEquals(limit.getEffectiveBeginDate(), anyEffectiveBeginDate);
		assertEquals(limit.getEffectiveEndDate(), anyEffectiveEndDate);
		assertEquals(limit.getLimitTypeCode(), anyLimitTypeCode);
		assertEquals(limit.getLimitName(), anyLimitName);
		assertEquals(limit.getLowerLimitValue(), anyLowerLimitValue);
		assertEquals(limit.getUpperLimitValue(), anyUpperLimitValue);
		assertEquals(limit.getFumSplitLimitValue(), anyFumSplitLimitValue);
		assertEquals(limit.getLastUpdatedUserId(), anyUpdatedUser);
		assertEquals(limit.getLastUpdatedDate(), anyUpdatedDate);
	}
}


	ValuationsReportTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import static org.junit.Assert.assertEquals;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class ValuationsReportTest {

	private static final Long Id = Long.valueOf(1);
	private static final String testPortfolioCode = "One90";
	private static final Date testEffectiveDate = new Date();
	private static final String testSecurityTypeCode = "Equity";
	private static final BigDecimal testValuationValue = new BigDecimal(100.00);
	private static final BigDecimal testValuationPercent = new BigDecimal(50.00);
	private static final BigDecimal testTotalValue = new BigDecimal(2100.00);
	private static final String testCreatedUser = "UXXX";
	private static final Date testCreatedDate = new Date();
	private static final Date testEffectiveBeginDate = new Date();
	private static final Date testEffectiveEndDate = new Date();
	private static final String testUpdatedUser = "UYYY";
	private static final Date testUpdatedDate = new Date();
	private static final DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
	
	@Test
	public void gettersAndSetters(){
		ValuationsReport dao = new ValuationsReport();
		dao.setId(Id);
		dao.setPortfolioCode(testPortfolioCode);
		dao.setEffectiveDate(testEffectiveDate);
		dao.setSecurityTypeCode(testSecurityTypeCode);
		dao.setValuationValue(testValuationValue);
		dao.setValuationPercent(testValuationPercent);
		dao.setTotalValue(testTotalValue);
		dao.setCreatedUser(testCreatedUser);
		dao.setCreatedDate(testCreatedDate);
		dao.setEffectiveBeginDate(testEffectiveBeginDate);
		dao.setEffectiveEndDate(testEffectiveEndDate);
		dao.setLastUpdatedUserId(testUpdatedUser);
		dao.setLastUpdatedDate(testUpdatedDate);
		dao.setDatasourceFileDAO(datasourceFileDAO);
		
		assertEquals(dao.getId(), Id);
		assertEquals(dao.getPortfolioCode(), testPortfolioCode);
		assertEquals(dao.getEffectiveDate(), testEffectiveDate);
		assertEquals(dao.getSecurityTypeCode(), testSecurityTypeCode);
		assertEquals(dao.getValuationValue(), testValuationValue);
		assertEquals(dao.getValuationPercent(), testValuationPercent);
		assertEquals(dao.getTotalValue(), testTotalValue);
		assertEquals(dao.getCreatedUser(), testCreatedUser);
		assertEquals(dao.getCreatedDate(), testCreatedDate);
		assertEquals(dao.getEffectiveBeginDate(), testEffectiveBeginDate);
		assertEquals(dao.getEffectiveEndDate(), testEffectiveEndDate);
		assertEquals(dao.getLastUpdatedUserId(), testUpdatedUser);
		assertEquals(dao.getLastUpdatedDate(), testUpdatedDate);
		assertEquals(datasourceFileDAO, dao.getDatasourceFileDAO());
	}
	
}


com.vanguard.corp.ics.sdt.dao.impl.portal

	ProductPortalHelperTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.portal;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.MediaType;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.powermock.reflect.Whitebox;

import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;


public class ProductPortalHelperTest {

	@Mock
	private Client mockClient;

	@Mock
	private WebTarget mockWebTarget;

	@Mock
	private Builder mockBuilder;

	@Mock
	private HttpServletRequest mockRequest;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testGetClient() {
		ProductPortalHelper pph = new ProductPortalHelper();
		assertNotNull(pph.getClient());
	}

	@Test
	public void testGetRequestMakesSuccessfulConnection() {
		when(mockClient.register(SecureClientRequestFeature.class)).thenReturn(mockClient);
		when(mockClient.target(any(String.class))).thenReturn(mockWebTarget);
		when(mockWebTarget.request(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.property(SecureClientRequestFeature.FORWARD_HTTP_SERVLET_REQUEST, mockRequest)).thenReturn(mockBuilder);
		when(mockBuilder.accept(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.get(String.class)).thenReturn("hi there!");
		
		PortalConfiguration config = new PortalConfiguration();
		config.setMaxConnectionAttempts(1);
		
		ProductPortalHelper pph = new ProductPortalHelper() {
			@Override
			protected Client getClient() {
				return mockClient;
			}
		};
		Whitebox.setInternalState(pph, PortalConfiguration.class, config);
		
		String response = pph.getRequest("blah", String.class, mockRequest);
		assertEquals("hi there!", response);
	}

	@Test
	public void testGetRequestMakesUnsuccessfulConnection() {
		when(mockClient.register(SecureClientRequestFeature.class)).thenReturn(mockClient);
		when(mockClient.target(any(String.class))).thenReturn(mockWebTarget);
		when(mockWebTarget.request(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.property(SecureClientRequestFeature.FORWARD_HTTP_SERVLET_REQUEST, mockRequest)).thenReturn(mockBuilder);
		when(mockBuilder.accept(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.get(String.class)).thenThrow(new RuntimeException());
		
		PortalConfiguration config = new PortalConfiguration();
		config.setMaxConnectionAttempts(2);
		
		ProductPortalHelper pph = new ProductPortalHelper() {
			@Override
			protected Client getClient() {
				return mockClient;
			}
		};
		Whitebox.setInternalState(pph, PortalConfiguration.class, config);
		
		String response = pph.getRequest("blah", String.class, mockRequest);
		assertNull(response);
	}

}


	ProductPortalServiceImplTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.portal;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.eq;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;

public class ProductPortalServiceImplTest {

	@InjectMocks
	ProductPortalServiceImpl productPortalService;
	
	@Mock
	PortalConfiguration portalConfiguration;
	
	@Mock
	ProductPortalHelper productPortalHelper;

	private PortalProduct[] portalProducts;
	
	private PortalProduct portalProduct;
	private PortalProduct secondPortalProduct;

	private static final String PRODUCT_CODE = "ONE90";
	private static final String PRODUCT_CODE2 = "ONE91";
	private static final String PRODUCT_NAME = "OnePath Australian Listed Property Index Pool";
	private static final String PRODUCT_NAME2 = "OnePath Australian Bonds Index Pool";
	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final Long INVSTMNT_GRP_ID2 = Long.valueOf(2);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String INVSTMNT_GRP_NAME2 = "Fixed Income Group";
	private static final String CURRENCY_CODE = "AUD";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String INVSTMNT_OBJ2 = "Investment Objective 2";
	private static final String CLIENT_ID = "ANZ OnePath";
	private static final String CLIENT_ID2 = "ANZ OnePath2";
	private static final String BENCHMARK_NAME = "test";
	private static final String BENCHMARK_NAME2 = "Bloomberg AusBond Composite 0+ Years Index";
	
	private Currency currency;
	private InvestmentGroup investmentGroup;
	private InvestmentGroup secondInvestmentGroup;
	
	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		
		portalProduct = new PortalProduct();
		secondPortalProduct = new PortalProduct();
		
		portalProduct.setBaseCurrencyID(Long.valueOf(1));
		portalProduct.setBenchMarkName(BENCHMARK_NAME);
		portalProduct.setClientID(CLIENT_ID);
		portalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct.setProductCode(PRODUCT_CODE);
		portalProduct.setProductName(PRODUCT_NAME);
		portalProduct.setInvestmentObjective(INVSTMNT_OBJ);

		currency = new Currency();
		currency.setCurrencyCode(CURRENCY_CODE);
		currency.setCurrencyId(Long.valueOf(1));
		currency.setCurrencyName("Australian Dollar123");

		investmentGroup = new InvestmentGroup();
		investmentGroup.setInvestmentGroupCode("EIG");
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);
		
		secondPortalProduct.setBaseCurrencyID(Long.valueOf(1));
		secondPortalProduct.setBenchMarkName(BENCHMARK_NAME2);
		secondPortalProduct.setClientID(CLIENT_ID2);
		secondPortalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID2);
		secondPortalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		secondPortalProduct.setProductCode(PRODUCT_CODE2);
		secondPortalProduct.setProductName(PRODUCT_NAME2);
		secondPortalProduct.setInvestmentObjective(INVSTMNT_OBJ2);

		secondInvestmentGroup = new InvestmentGroup();
		secondInvestmentGroup.setInvestmentGroupCode("FIG");
		secondInvestmentGroup.setInvestmentGroupId(Long.valueOf(2));
		secondInvestmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME2);

		portalProducts = new PortalProduct[]{portalProduct, secondPortalProduct};
		
		when(portalConfiguration.getPortalProductEndpoint()).thenReturn("testString");
		when(portalConfiguration.getPortalReferenceEndpoint()).thenReturn("testString");
		when(productPortalHelper.getRequest(eq("testString/currency/1"), eq(Currency.class), any(HttpServletRequest.class))).thenReturn(currency);
		when(productPortalHelper.getRequest(eq("testString/investmentGroup/1"), eq(InvestmentGroup.class), any(HttpServletRequest.class)))
				.thenReturn(investmentGroup);
		when(productPortalHelper.getRequest(eq("testString/investmentGroup/2"), eq(InvestmentGroup.class), any(HttpServletRequest.class)))
				.thenReturn(secondInvestmentGroup);
		when(productPortalHelper.getRequest(eq("testString"), eq(PortalProduct[].class), any(HttpServletRequest.class))).thenReturn(portalProducts);
	}
	
	@Test
	public void testRetrieveInvestmentGroup() {
		HttpServletRequest mockRequest = Mockito.mock(HttpServletRequest.class);
		InvestmentGroup group = productPortalService.getInvestmentGroup(portalProduct, mockRequest);
		
		assertEquals(investmentGroup.getInvestmentGroupCode(), group.getInvestmentGroupCode());
		assertEquals(investmentGroup.getInvestmentGroupId(), group.getInvestmentGroupId());
		assertEquals(investmentGroup.getInvestmentGroupName(), group.getInvestmentGroupName());
	}
	
	@Test
	public void testRetrieveCurrencyCode() {
		HttpServletRequest mockRequest = Mockito.mock(HttpServletRequest.class);
		Currency curr = productPortalService.getProductCurrency(portalProduct, mockRequest);
		
		assertEquals(currency.getCurrencyCode(), curr.getCurrencyCode());
		assertEquals(currency.getCurrencyId(), curr.getCurrencyId());
		assertEquals(currency.getCurrencyName(), curr.getCurrencyName());
	}

	@Test
	public void testRetrieveSpecificProduct() {
		PortalProduct product = productPortalService.getProduct(Arrays.asList(portalProducts), portalProduct.getProductCode());
		
		compareProducts(portalProduct, product);
	}
	
	@Test
	public void testRetrieveAllProducts() {
		HttpServletRequest mockRequest = Mockito.mock(HttpServletRequest.class);
		List<PortalProduct> products = productPortalService.getProducts(mockRequest);
		
		for (PortalProduct product : products) {
			if (product.getProductCode().equals(portalProduct.getProductCode())) {
				compareProducts(portalProduct, product);
			} else {
				compareProducts(secondPortalProduct, product);
			}
		}
	}

	private void compareProducts(PortalProduct expected, PortalProduct actual) {
		assertEquals(expected.getAssetClassID(), actual.getAssetClassID());
		assertEquals(expected.getBaseCurrencyID(), actual.getBaseCurrencyID());
		assertEquals(expected.getBenchMarkName(), actual.getBenchMarkName());
		assertEquals(expected.getBenchMarkProviderID(), actual.getBenchMarkProviderID());
		assertEquals(expected.getClientID(), actual.getClientID());
		assertEquals(expected.getContactingEntityID(), actual.getContactingEntityID());
		assertEquals(expected.getCurrency(), actual.getCurrency());
		assertEquals(expected.getCustodianID(), actual.getCustodianID());
		assertEquals(expected.getExAnteMaxBreachIMA(), actual.getExAnteMaxBreachIMA());
		assertEquals(expected.getExPostMaxBreachIMA(), actual.getExPostMaxBreachIMA());
		assertEquals(expected.getFuturesClearingAgentID(), actual.getFuturesClearingAgentID());
		assertEquals(expected.getHedgeCurrencyID(), actual.getHedgeCurrencyID());
		assertEquals(expected.getHedgePercentage(), actual.getHedgePercentage());
		assertEquals(expected.getHedgeTypeID(), actual.getHedgeTypeID());
		assertEquals(expected.getInitialAUM(), actual.getInitialAUM());
		assertEquals(expected.getInitialAUMCurrencyID(), actual.getInitialAUMCurrencyID());
		assertEquals(expected.getInvestmentGroup(), actual.getInvestmentGroup());
		assertEquals(expected.getInvestmentGroupID(), actual.getInvestmentGroupID());
		assertEquals(expected.getInvestmentManagementEntityID(), actual.getInvestmentManagementEntityID());
		assertEquals(expected.getInvestmentMarketID(), actual.getInvestmentMarketID());
		assertEquals(expected.getInvestmentObjective(), actual.getInvestmentObjective());
		assertEquals(expected.getInvestmentStyleID(), actual.getInvestmentStyleID());
		assertEquals(expected.getModifiedBy(), actual.getModifiedBy());
		assertEquals(expected.getModifiedDate(), actual.getModifiedDate());
		assertEquals(expected.getPerfInceptionDate(), actual.getPerfInceptionDate());
		assertEquals(expected.getProductCode(), actual.getProductCode());
		assertEquals(expected.getProductFundingTypeID(), actual.getProductFundingTypeID());
		assertEquals(expected.getProductID(), actual.getProductID());
		assertEquals(expected.getProductName(), actual.getProductName());
		assertEquals(expected.getProductTypeID(), actual.getProductTypeID());
		assertEquals(expected.getSalesTeamEntityID(), actual.getSalesTeamEntityID());
		assertEquals(expected.getStatusID(), actual.getStatusID());
		assertEquals(expected.getTargetLaunchDate(), actual.getTargetLaunchDate());
	}
}

com.vanguard.corp.ics.sdt.dao.impl.repository

		TestAccountBenchmarkAssociationRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;

public class TestAccountBenchmarkAssociationRepository implements AccountBenchmarkAssociationRepository {
	
	public List<AccountBenchmarkAssociation> accountBenchmarkAssociationList = new ArrayList<>();
	public Map<String, AccountBenchmarkAssociation> accountBenchmarkAssociationMap = new HashMap<>();
	
	@Override
	public List<AccountBenchmarkAssociation> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountBenchmarkAssociation> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountBenchmarkAssociation> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends AccountBenchmarkAssociation> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends AccountBenchmarkAssociation> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<AccountBenchmarkAssociation> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public AccountBenchmarkAssociation getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<AccountBenchmarkAssociation> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(AccountBenchmarkAssociation arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends AccountBenchmarkAssociation> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public AccountBenchmarkAssociation findOne(Long arg0) {
		return accountBenchmarkAssociationMap.get(arg0.toString());
	}

	@Override
	public <S extends AccountBenchmarkAssociation> S save(S accountBenchmarkAssociation) {
		// TODO Auto-generated method stub
		accountBenchmarkAssociationList.add(accountBenchmarkAssociation);
		
		return accountBenchmarkAssociation;
	}

	@Override
	public AccountBenchmarkAssociation findByPortfolioIdIs(String portfolioId) {
		return accountBenchmarkAssociationMap.get(portfolioId);
	}
	
	@Override
	public AccountBenchmarkAssociation findByPortfolioIdAndEffectiveEndDateIsNull(String portfolioId) {

		if (accountBenchmarkAssociationMap.get(portfolioId) != null) {

			if (accountBenchmarkAssociationMap.get(portfolioId).getEffectiveEndDate() == null)
				return accountBenchmarkAssociationMap.get(portfolioId);
			else
				System.out.println("BENCHMARK: Record with portId: " + portfolioId + " had an effective end date that was not null.");
				return null;
		}else
			System.out.println("BENCHMARK: Could not find record with the port id: " + portfolioId);
			return null;

	}
	
}

	TestAccountFundRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;

public class TestAccountFundRepository implements AccountFundRepository {
	
	public List<AccountFund> accountFunds = new ArrayList<>();
	public Map<String, AccountFund> accountFundMap = new HashMap<>();

	@Override
	public List<AccountFund> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountFund> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountFund> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends AccountFund> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends AccountFund> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<AccountFund> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public AccountFund getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<AccountFund> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(AccountFund arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends AccountFund> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public AccountFund findOne(Long arg0) {
		return accountFundMap.get(arg0.toString());
	}

	@Override
	public <S extends AccountFund> S save(S accountFund) {
		// TODO Auto-generated method stub
		accountFunds.add(accountFund);
		//this.accountFund= accountFund;
		
		return accountFund;
	}

	@Override
	public AccountFund findByPortfolioIdIs(String portfolioId) {
		return accountFundMap.get(portfolioId);
	}
	
	@Override
	public AccountFund findByPortfolioIdAndEffectiveEndDateIsNull(String portfolioId) {
		if (accountFundMap.get(portfolioId) != null) {

			if (accountFundMap.get(portfolioId).getEffectiveEndDate() == null)
				return accountFundMap.get(portfolioId);
			else
				System.out.println("FUND: Record with portId: " + portfolioId + " had an effective end date that was not null.");
				return null;
		}else
			System.out.println("FUND: Could not find record with the port id: " + portfolioId);
			return null;
	}
	



}

	TestAccountSetupRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;

public class TestAccountSetupRepository implements AccountSetupRepository {
	
	public List<AccountSetup> accountSetupList = new ArrayList<>();
	public Map<String, AccountSetup> accountSetupMap = new HashMap<>();

	@Override
	public <S extends AccountSetup> S save(S accountSetup) {
		accountSetupList.add(accountSetup);

		return accountSetup;
	}


	@Override
	public List<AccountSetup> findAll() {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public List<AccountSetup> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public List<AccountSetup> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public <S extends AccountSetup> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public <S extends AccountSetup> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public void deleteInBatch(Iterable<AccountSetup> entities) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public AccountSetup getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Page<AccountSetup> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}


	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void delete(AccountSetup arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void delete(Iterable<? extends AccountSetup> arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}


	@Override
	public AccountSetup findOne(Long arg0) {
		return accountSetupMap.get(arg0.toString());
	}


	@Override
	public AccountSetup findByPortfolioIdIs(String portfolioId) {
		return accountSetupMap.get(portfolioId);
	}

	@Override
	public AccountSetup findByPortfolioIdAndEffectiveEndDateIsNull(String portfolioId) {
		if (accountSetupMap.get(portfolioId) != null) {

			if (accountSetupMap.get(portfolioId).getEffectiveEndDate() == null)
				return accountSetupMap.get(portfolioId);
			else
				System.out.println("ACCOUNT: Record with portId: " + portfolioId + " had an effective end date that was not null.");
				return null;
		}else
			System.out.println("ACCOUNT: Could not find record with the port id: " + portfolioId);
			return null;
	}
}

		TestBrokerageAndTaxesRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.BrokerageAndTaxes;

public class TestBrokerageAndTaxesRepository implements BrokerageAndTaxesRepository {

	public Map<String, BrokerageAndTaxes> brokerageAndTaxesMap = new HashMap<String, BrokerageAndTaxes>();

	@Override
	public List<BrokerageAndTaxes> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<BrokerageAndTaxes> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<BrokerageAndTaxes> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends BrokerageAndTaxes> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub

	}

	@Override
	public <S extends BrokerageAndTaxes> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<BrokerageAndTaxes> entities) {
		// TODO Auto-generated method stub

	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub

	}

	@Override
	public BrokerageAndTaxes getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<BrokerageAndTaxes> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void delete(BrokerageAndTaxes arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void delete(Iterable<? extends BrokerageAndTaxes> arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public BrokerageAndTaxes findOne(Long arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends BrokerageAndTaxes> S save(S brokerageAndTaxesRecord) {
		// for the string of the map, concatenate the portId and the AsOfDate
		brokerageAndTaxesMap.put(brokerageAndTaxesRecord.getPortfolioId() + brokerageAndTaxesRecord.getAsOfDate(),
				(BrokerageAndTaxes) brokerageAndTaxesRecord);

		return brokerageAndTaxesRecord;
	}

	@Override
	public List<BrokerageAndTaxes> findByPortfolioIdIs(String portfolioId) {
		return null;
	}

	@Override
	public BrokerageAndTaxes findByAsOfDateAndPortfolioId(Date asOfDate, String portfolioId) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public BrokerageAndTaxes findByAsOfDateAndPortfolioIdAndEffectiveEndDateIsNull(Date asOfDate, String portfolioId) {
		BrokerageAndTaxes foundRecord = brokerageAndTaxesMap.get(portfolioId + asOfDate);

		if (foundRecord != null) {
			if (foundRecord.getEffectiveEndDate() == null) {
				return foundRecord;
			} else {
				return null;
			}
		}else{
			return null;
		}
	}

}


	TestBrokerageAndTaxesTargetRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.target.BrokerageAndTaxesTargetDAO;

public class TestBrokerageAndTaxesTargetRepository implements BrokerageAndTaxesTargetRepository {
	
	public Map<String, BrokerageAndTaxesTargetDAO> brokerageAndTaxesTargetMap = new HashMap<String, BrokerageAndTaxesTargetDAO>();
	public List<String> portIdList = new ArrayList<>();

	@Override
	public List<BrokerageAndTaxesTargetDAO> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<BrokerageAndTaxesTargetDAO> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<BrokerageAndTaxesTargetDAO> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends BrokerageAndTaxesTargetDAO> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends BrokerageAndTaxesTargetDAO> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<BrokerageAndTaxesTargetDAO> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public BrokerageAndTaxesTargetDAO getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<BrokerageAndTaxesTargetDAO> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(BrokerageAndTaxesTargetDAO arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends BrokerageAndTaxesTargetDAO> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public BrokerageAndTaxesTargetDAO findOne(Long arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends BrokerageAndTaxesTargetDAO> S save(S arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public BrokerageAndTaxesTargetDAO findByPortfolioCodeAndAsOfDate(String portfolioId, Date asOfDate) {
		return brokerageAndTaxesTargetMap.get(portfolioId + asOfDate);
	}


	@Override
	public List<BrokerageAndTaxesTargetDAO> findByAsOfDate(Date asOfDate) {
		List<BrokerageAndTaxesTargetDAO> targetRecordList = new ArrayList<>();

		//iterate through map and store each record in targetRecordList
		for(Map.Entry<String, BrokerageAndTaxesTargetDAO> record : brokerageAndTaxesTargetMap.entrySet()){
			if(record.getKey().contains(asOfDate.toString())){
				targetRecordList.add(record.getValue());
			}
		}
		
		return targetRecordList;
	}

}

	TestCommentaryRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;

public class TestCommentaryRepository implements CommentaryRepository{

	public Commentary testCommentaryEntity = new Commentary();
	
	@Override
	public List<Commentary> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Commentary> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Commentary> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Commentary> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends Commentary> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<Commentary> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Commentary getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<Commentary> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Commentary arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends Commentary> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Commentary findOne(Long arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Commentary> S save(S commentary) {
		this.testCommentaryEntity = commentary;
		
		return commentary;
	}
	

	@Override
	public Commentary findByAsOfDateAndPortId(Date asOfDate, String portfolioId) {
		return testCommentaryEntity;
	}

}


		TestPortfolioLimitRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;

public class TestPortfolioLimitRepository implements PortfolioLimitRepository {
	
	public Map<String, Limit> dataMap = new HashMap<String, Limit>();

	@Override
	public List<Limit> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Limit> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Limit> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Limit> List<S> save(Iterable<S> limits) {
		for(Limit limit : limits) {
			dataMap.put(limit.getPortfolioCode() + limit.getLimitTypeCode(), limit);
		}
		
		return (List<S>) limits;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends Limit> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<Limit> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Limit getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<Limit> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Limit arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends Limit> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Limit findOne(Long arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Limit> S save(S limit) {
		dataMap.put(limit.getPortfolioCode() + limit.getLimitTypeCode(), limit);
		
		return limit;
	}

	@Override
	public Limit findOneById(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Limit> findByPortfolioCodeAndEffectiveEndDateIsNull(String portfolioCode) {
		// TODO Auto-generated method stub
		return null;
	}
	
	
}


	TestValuationReportRepository.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;

public class TestValuationReportRepository implements ValuationsReportRepository {
	
	public Map<String, ValuationsReport> dataMap = new HashMap<String, ValuationsReport>();
	public ValuationsReport report = null;

	@Override
	public List<ValuationsReport> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<ValuationsReport> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<ValuationsReport> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends ValuationsReport> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends ValuationsReport> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<ValuationsReport> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ValuationsReport getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<ValuationsReport> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(ValuationsReport arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends ValuationsReport> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public ValuationsReport findOne(Long arg0) {
		return report;
	}

	@Override
	public <S extends ValuationsReport> S save(S valReport) {
		dataMap.put(valReport.getPortfolioCode() + valReport.getEffectiveDate().toString() + valReport.getSecurityTypeCode(), (ValuationsReport) valReport);
		
		return valReport;
	}

	@Override
	public ValuationsReport findOneById(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ValuationsReport findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(String portfolioCode,
			String securityTypeCode, Date effectiveDate) {
		return report;
	}

}


com.vanguard.corp.ics.sdt.service.api.constants
	AnalyticsTypeCodeTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class AnalyticsTypeCodeTest {

	@Test
	public void testEnumValues() {
		// Names
		assertEquals("Ex Ante- Tracking Error", AnalyticsTypeCode.EX_ANTE_RISK.getName());
		assertEquals("1 yr Ex-Post Tracking Error", AnalyticsTypeCode.ONE_YR_EX_POST.getName());
		assertEquals("3 yr Ex-Post Tracking Error", AnalyticsTypeCode.THREE_YR_EX_POST.getName());
		assertEquals("1 yr Standard Deviation", AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName());
		assertEquals("3 yr Standard Deviation", AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName());
		
		// Codes
		assertEquals("EATE", AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertEquals("1YEP", AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertEquals("3YEP", AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertEquals("1YSD", AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getCode());
		assertEquals("3YSD", AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getCode());

		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK, AnalyticsTypeCode.valueOf("EX_ANTE_RISK"));
	}
}


	AttributionSummaryOrderTypeTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class AttributionSummaryOrderTypeTest {

	@Test
	public void testAttributionSummaryOrderTypeTest() {
		assertEquals("Stock Selection Impact", AttributionSummaryOrderType.STOCK_SELECTION_IMPACT.getAttributionName());
		assertEquals("Futures Impact", AttributionSummaryOrderType.FUTURES_IMPACT.getAttributionName());
		assertEquals("Liquidity Management Impact", AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT.getAttributionName());
		assertEquals("Security Price Execution", AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION.getAttributionName());
		assertEquals("Trading Cost", AttributionSummaryOrderType.TRADING_COST.getAttributionName());
		assertEquals("Currency Price Execution", AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION.getAttributionName());
		assertEquals("Dividend Withholding Impact", AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT.getAttributionName());
		assertEquals("Security Lending Income", AttributionSummaryOrderType.SECURITY_LENDING_INCOME.getAttributionName());
		assertEquals("Mgmt & Custody Fees", AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES.getAttributionName());
		assertEquals("Substitutes Impact", AttributionSummaryOrderType.SUBSTITUTES_IMPACT.getAttributionName());
		assertEquals("Restrictions Impact", AttributionSummaryOrderType.RESTRICTIONS_IMPACT.getAttributionName());
		assertEquals("Internal Liquidity", AttributionSummaryOrderType.INTERNAL_LIQUIDITY.getAttributionName());
		assertEquals("Residual", AttributionSummaryOrderType.RESIDUAL.getAttributionName());
		
		assertEquals(AttributionSummaryOrderType.valueOf("STOCK_SELECTION_IMPACT"), AttributionSummaryOrderType.STOCK_SELECTION_IMPACT);
		assertEquals(AttributionSummaryOrderType.valueOf("FUTURES_IMPACT"), AttributionSummaryOrderType.FUTURES_IMPACT);
		assertEquals(AttributionSummaryOrderType.valueOf("LIQUIDITY_MANAGEMENT_IMPACT"), AttributionSummaryOrderType.LIQUIDITY_MANAGEMENT_IMPACT);
		assertEquals(AttributionSummaryOrderType.valueOf("SECURITY_PRICE_EXECUTION"), AttributionSummaryOrderType.SECURITY_PRICE_EXECUTION);
		assertEquals(AttributionSummaryOrderType.valueOf("TRADING_COST"), AttributionSummaryOrderType.TRADING_COST);
		assertEquals(AttributionSummaryOrderType.valueOf("CURRENCY_PRICE_EXECUTION"), AttributionSummaryOrderType.CURRENCY_PRICE_EXECUTION);
		assertEquals(AttributionSummaryOrderType.valueOf("DIVIDEND_WITHOLDING_IMPACT"), AttributionSummaryOrderType.DIVIDEND_WITHOLDING_IMPACT);
		assertEquals(AttributionSummaryOrderType.valueOf("SECURITY_LENDING_INCOME"), AttributionSummaryOrderType.SECURITY_LENDING_INCOME);
		assertEquals(AttributionSummaryOrderType.valueOf("MGMT_AND_CUSTODY_FEES"), AttributionSummaryOrderType.MGMT_AND_CUSTODY_FEES);
		assertEquals(AttributionSummaryOrderType.valueOf("SUBSTITUTES_IMPACT"), AttributionSummaryOrderType.SUBSTITUTES_IMPACT);
		assertEquals(AttributionSummaryOrderType.valueOf("RESTRICTIONS_IMPACT"), AttributionSummaryOrderType.RESTRICTIONS_IMPACT);
		assertEquals(AttributionSummaryOrderType.valueOf("INTERNAL_LIQUIDITY"), AttributionSummaryOrderType.INTERNAL_LIQUIDITY);
		assertEquals(AttributionSummaryOrderType.valueOf("RESIDUAL"), AttributionSummaryOrderType.RESIDUAL);
	}

}


	PerformanceSummaryNameTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class PerformanceSummaryNameTest {

	@Test
	public void testEnumValues() {
		assertEquals("Bmk (Div Return)", PerformanceSummaryName.BMK_DIV_RETURN.getName());
		assertEquals("Bmk (Gross)", PerformanceSummaryName.BMK_GROSS.getName());
		assertEquals("Bmk (Net)", PerformanceSummaryName.BMK_NET.getName());
		assertEquals("Bmk (Price Return)", PerformanceSummaryName.BMK_PRICE_RETURN.getName());
		assertEquals("Diff", PerformanceSummaryName.DIFF.getName());
		assertEquals("Portfolio (Gross)", PerformanceSummaryName.PORTFOLIO_GROSS.getName());
		assertEquals("Portfolio (Net)", PerformanceSummaryName.PORTFOLIO_NET.getName());
		
		assertEquals(PerformanceSummaryName.valueOf("BMK_DIV_RETURN"), PerformanceSummaryName.BMK_DIV_RETURN);
		assertEquals(PerformanceSummaryName.valueOf("BMK_GROSS"),PerformanceSummaryName.BMK_GROSS);
		assertEquals(PerformanceSummaryName.valueOf("BMK_NET"),PerformanceSummaryName.BMK_NET);
		assertEquals(PerformanceSummaryName.valueOf("BMK_PRICE_RETURN"),PerformanceSummaryName.BMK_PRICE_RETURN);
		assertEquals(PerformanceSummaryName.valueOf("DIFF"),PerformanceSummaryName.DIFF);
		assertEquals(PerformanceSummaryName.valueOf("PORTFOLIO_GROSS"),PerformanceSummaryName.PORTFOLIO_GROSS);
		assertEquals(PerformanceSummaryName.valueOf("PORTFOLIO_NET"),PerformanceSummaryName.PORTFOLIO_NET);
	}

}


	SecurityTypeCodeTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class SecurityTypeCodeTest {

	@Test
	public void testEnumValues() {
		// Names
		assertEquals("Derivatives", SecurityTypeCode.DERIVATIVES.getName());
		assertEquals("Equity", SecurityTypeCode.EQUITY.getName());
		assertEquals("Futures", SecurityTypeCode.FUTURES.getName());
		assertEquals("Forward Forex", SecurityTypeCode.FORWARD_FOREX.getName());
		assertEquals("Liquidity", SecurityTypeCode.LIQUIDITY.getName());
		assertEquals("Securities", SecurityTypeCode.FIXED_INTEREST.getName());
		
		// Codes
		assertEquals("DERI", SecurityTypeCode.DERIVATIVES.getCode());
		assertEquals("EQUI", SecurityTypeCode.EQUITY.getCode());
		assertEquals("FUTU", SecurityTypeCode.FUTURES.getCode());
		assertEquals("FWFX", SecurityTypeCode.FORWARD_FOREX.getCode());
		assertEquals("LIQU", SecurityTypeCode.LIQUIDITY.getCode());
		assertEquals("SECU", SecurityTypeCode.FIXED_INTEREST.getCode());

		assertEquals(SecurityTypeCode.EQUITY, SecurityTypeCode.valueOf("EQUITY"));
	}
}


com.vanguard.corp.ics.sdt.service.api.util
	DateParserTest.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.util;

import org.junit.Test;


public class DateParserTest {

	private DateParser classUnderTest = new DateParser();

	@Test(expected=DateParser.DateParserException.class)
	public void testForCoverageBecauseLessThan100PercentIsBad() {
		classUnderTest.parse("ABCD");
	}

}

	UtilitiesTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;

import org.junit.Test;
import org.springframework.security.core.GrantedAuthority;

import com.vanguard.services.suds.entity.VGUser;
import com.vanguard.services.suds.entity.VGUserDetailsServiceRequest;


public class UtilitiesTest {

	private Utilities classUnderTest = new Utilities();

	private DateParser dateParser = new DateParser();

	@Test
	public void testGetPreviousMonthEnd() {
		Date date = dateParser.parse("2016-01-01");
		
		Date previousMonthEnd = classUnderTest.getPreviousMonthEnd(date);
		
		assertNotNull(previousMonthEnd);
		assertEquals(dateParser.parse("2015-12-31"), previousMonthEnd);
	}

	@Test
	public void testGenerateDateFromString() {
		Date generatedDate = classUnderTest.generateDateFromString("2016-01-01", "yyyy-MM-dd");
		
		assertEquals(dateParser.parse("2016-01-01"), generatedDate);
	}

	@Test
	public void testBadDateStringBecomesToday() {
		Date generatedDate = classUnderTest.generateDateFromString("blah blah blah", "yyyy-MM-dd");
		
		Calendar now = Calendar.getInstance();
		Calendar cal = Calendar.getInstance();
		cal.setTime(generatedDate);
		
		assertEquals(now.get(Calendar.YEAR), cal.get(Calendar.YEAR));
		assertEquals(now.get(Calendar.MONTH), cal.get(Calendar.MONTH));
		assertEquals(now.get(Calendar.DATE), cal.get(Calendar.DATE));
	}

	@Test
	public void testGetAuthenticatedUser() {
		classUnderTest.getAuthenticatedUser();
	}

	@Test
	public void testGetCurrentUserName() {
		Utilities util = new Utilities() {
			@Override
			protected VGUser getAuthenticatedUser() {
				Collection<? extends GrantedAuthority> authorities = new ArrayList<>();
				VGUserDetailsServiceRequest vGUserDetailsServiceRequest = new VGUserDetailsServiceRequest();
				return new VGUser("username", authorities, vGUserDetailsServiceRequest);
			}
		};
		
		String currentUsername = util.getCurrentUsername();
		assertEquals("username", currentUsername);
	}
}


com.vanguard.corp.ics.sdt.service.impl

	BrokerageAndTaxesServiceImplTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.text.ParseException;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.BrokerageAndTaxes;
import com.vanguard.corp.ics.sdt.dao.impl.entity.target.BrokerageAndTaxesTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestBrokerageAndTaxesRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestBrokerageAndTaxesTargetRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;

public class BrokerageAndTaxesServiceImplTest {

	@Mock
	HttpServletRequest request;

	@Spy
	TestBrokerageAndTaxesTargetRepository testBrokerageAndTaxesTargetRepo = new TestBrokerageAndTaxesTargetRepository();

	@Spy
	TestBrokerageAndTaxesRepository testBrokerageAndTaxesRepo = new TestBrokerageAndTaxesRepository();

	@InjectMocks
	private BrokerageAndTaxesServiceImpl brokerageAndTaxesService;

	BrokerageAndTaxesTargetDAO brokerageAndTaxesTargetRecord, brokerageAndTaxesTargetRecord2,
			brokerageAndTaxesTargetRecord3, brokerageAndTaxesTargetRecord4, brokerageAndTaxesTargetRecord5,
			brokerageAndTaxesTargetRecord6, brokerageAndTaxesTargetRecord7, brokerageAndTaxesTargetRecord8;

	BrokerageAndTaxes existingReportRecord;

	private static final Long ID = Long.valueOf(1);
	private static final String PORT_ID = "ONE88";
	private static final String PORT_ID_2 = "ONE89";
	private static final String PORT_ID_3 = "ONE90";
	private static final String PORT_ID_4 = "ONE91";
	private static final String PORT_ID_5 = "ONE92";
	private static final String PORT_ID_6 = "ONE93";
	private static final String PORT_ID_7 = "ONE94";
	private static final Date AS_OF_DATE = new Date(1);
	private static final Date AS_OF_DATE_2 = new Date(50000000);
	private static final String FUND_CHARGE_TYPE = "Taxes";
	private static final String FUND_CHARGE_CURRENCY = "AUD";
	private static final String FUND_CHARGE_FREQUENCY = "1MO";
	private static final BigDecimal NEGATIVE_FUND_CHARGE_AMOUNT = new BigDecimal(-100);
	private static final BigDecimal FUND_CHARGE_AMOUNT = new BigDecimal(100);
	private static final String LAST_UPDATED_USER = "UXXX";
	private static final String CALLED_BY_USER_ID = "UXYZ";

	@Before
	public void init() throws ParseException {
		MockitoAnnotations.initMocks(this);

		brokerageAndTaxesTargetRecord = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord2 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord3 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord4 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord5 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord6 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord7 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord8 = null; // null record for testing

		brokerageAndTaxesTargetRecord.setId(ID);
		brokerageAndTaxesTargetRecord.setPortfolioCode(PORT_ID);
		brokerageAndTaxesTargetRecord.setAsOfDate(AS_OF_DATE);
		brokerageAndTaxesTargetRecord.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord.setUpdatedUser(LAST_UPDATED_USER);

		brokerageAndTaxesTargetRecord2.setId(Long.valueOf(2));
		brokerageAndTaxesTargetRecord2.setPortfolioCode(PORT_ID_2);
		brokerageAndTaxesTargetRecord2.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord2.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord2.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord2.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord2.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord2.setUpdatedUser(LAST_UPDATED_USER);

		brokerageAndTaxesTargetRecord3.setId(Long.valueOf(3));
		brokerageAndTaxesTargetRecord3.setPortfolioCode(PORT_ID_3);
		brokerageAndTaxesTargetRecord3.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord3.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord3.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord3.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord3.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord3.setUpdatedUser(LAST_UPDATED_USER);

		// negative fund charge amount record
		brokerageAndTaxesTargetRecord4.setId(Long.valueOf(4));
		brokerageAndTaxesTargetRecord4.setPortfolioCode(PORT_ID_4);
		brokerageAndTaxesTargetRecord4.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord4.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord4.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeAmount(NEGATIVE_FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord4.setUpdatedUser(LAST_UPDATED_USER);

		// 0.5 fund charge amount record
		brokerageAndTaxesTargetRecord5.setId(Long.valueOf(5));
		brokerageAndTaxesTargetRecord5.setPortfolioCode(PORT_ID_5);
		brokerageAndTaxesTargetRecord5.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord5.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord5.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord5.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord5.setFundChargeAmount(new BigDecimal(0.50));
		brokerageAndTaxesTargetRecord5.setUpdatedUser(LAST_UPDATED_USER);

		// 0.49 fund charge amount record
		brokerageAndTaxesTargetRecord6.setId(Long.valueOf(5));
		brokerageAndTaxesTargetRecord6.setPortfolioCode(PORT_ID_6);
		brokerageAndTaxesTargetRecord6.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord6.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord6.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord6.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord6.setFundChargeAmount(new BigDecimal(0.49));
		brokerageAndTaxesTargetRecord6.setUpdatedUser(LAST_UPDATED_USER);

		// empty fund charge amount record
		brokerageAndTaxesTargetRecord7.setId(Long.valueOf(5));
		brokerageAndTaxesTargetRecord7.setPortfolioCode(PORT_ID_7);
		brokerageAndTaxesTargetRecord7.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord7.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord7.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord7.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord7.setFundChargeAmount(null);
		brokerageAndTaxesTargetRecord7.setUpdatedUser(LAST_UPDATED_USER);

		// put target records into map field
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate(),
				brokerageAndTaxesTargetRecord);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord2.getPortfolioCode() + brokerageAndTaxesTargetRecord2.getAsOfDate(),
				brokerageAndTaxesTargetRecord2);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord3.getPortfolioCode() + brokerageAndTaxesTargetRecord3.getAsOfDate(),
				brokerageAndTaxesTargetRecord3);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord4.getPortfolioCode() + brokerageAndTaxesTargetRecord4.getAsOfDate(),
				brokerageAndTaxesTargetRecord4);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord5.getPortfolioCode() + brokerageAndTaxesTargetRecord5.getAsOfDate(),
				brokerageAndTaxesTargetRecord5);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord6.getPortfolioCode() + brokerageAndTaxesTargetRecord6.getAsOfDate(),
				brokerageAndTaxesTargetRecord6);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord7.getPortfolioCode() + brokerageAndTaxesTargetRecord7.getAsOfDate(),
				brokerageAndTaxesTargetRecord7);
	}

	@Test
	public void valuationsServiceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, brokerageAndTaxesService.getPriority());
	}

	@Test
	public void serviceWantsToHandleValuationsDataSetTypeRequests() {
		assertTrue(brokerageAndTaxesService.handles(null, null, DataSetType.BROKERAGE_TAXES, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(brokerageAndTaxesService.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(brokerageAndTaxesService.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	@Test
	public void moveOneRecordFromTargetToReportWithPortIdAndAsOfDate() {

		// pass in both as of date and port id
		brokerageAndTaxesService.transfer(AS_OF_DATE, PORT_ID, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate());

		assertEquals(PORT_ID, brokerageAndTaxesReportRecord.getPortfolioId());
		assertEquals(AS_OF_DATE, brokerageAndTaxesReportRecord.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord.getLastUpdatedUserId());

	}

	@Test
	public void moveRecordsFromTargetToReportWithAsOfDate() {
		// don't pass in a port id
		brokerageAndTaxesService.transfer(AS_OF_DATE_2, null, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord2 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord2.getPortfolioCode() + brokerageAndTaxesTargetRecord2.getAsOfDate());

		BrokerageAndTaxes brokerageAndTaxesReportRecord3 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord3.getPortfolioCode() + brokerageAndTaxesTargetRecord3.getAsOfDate());

		assertEquals(PORT_ID_2, brokerageAndTaxesReportRecord2.getPortfolioId());
		assertEquals(AS_OF_DATE_2, brokerageAndTaxesReportRecord2.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord2.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord2.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord2.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord2.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord2.getLastUpdatedUserId());

		assertEquals(PORT_ID_3, brokerageAndTaxesReportRecord3.getPortfolioId());
		assertEquals(AS_OF_DATE_2, brokerageAndTaxesReportRecord3.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord3.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord3.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord3.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord3.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord3.getLastUpdatedUserId());
	}

	@Test
	public void serviceSavesToReportTableIfNegativeValueInTarget() {

		brokerageAndTaxesService.transfer(AS_OF_DATE_2, PORT_ID_4, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord4 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord4.getPortfolioCode() + brokerageAndTaxesTargetRecord4.getAsOfDate());

		assertEquals(PORT_ID_4, brokerageAndTaxesReportRecord4.getPortfolioId());
		assertEquals(AS_OF_DATE_2, brokerageAndTaxesReportRecord4.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord4.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord4.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord4.getFundChargeFrequency());
		assertEquals(NEGATIVE_FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord4.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord4.getLastUpdatedUserId());

	}

	@Test
	public void serviceShouldRoundUpIfDecimalInTargetTable() {

		BigDecimal expectedRoundedVal = BigDecimal.ONE;

		brokerageAndTaxesService.transfer(AS_OF_DATE_2, PORT_ID_5, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord5 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord5.getPortfolioCode() + brokerageAndTaxesTargetRecord5.getAsOfDate());

		assertEquals(expectedRoundedVal, brokerageAndTaxesReportRecord5.getFundChargeAmount());
	}

	@Test
	public void serviceShouldRoundDownIfDecimalInTargetTable() {

		BigDecimal expectedRoundedVal = BigDecimal.ZERO;

		brokerageAndTaxesService.transfer(AS_OF_DATE_2, PORT_ID_6, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord6 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord6.getPortfolioCode() + brokerageAndTaxesTargetRecord6.getAsOfDate());

		assertEquals(expectedRoundedVal, brokerageAndTaxesReportRecord6.getFundChargeAmount());
	}

	@Test
	public void serviceSavesNothingIfNoDataInTargetRepository() {
		when(testBrokerageAndTaxesTargetRepo.findByPortfolioCodeAndAsOfDate(
				brokerageAndTaxesTargetRecord.getPortfolioCode(), brokerageAndTaxesTargetRecord.getAsOfDate()))
						.thenReturn(null);

		brokerageAndTaxesService.transfer(AS_OF_DATE, PORT_ID, CALLED_BY_USER_ID, request);

		assertEquals(0, testBrokerageAndTaxesRepo.brokerageAndTaxesMap.size());

	}

	@Test
	public void serviceSavesNothingIfTargetRecordListIsNull() {
		when(testBrokerageAndTaxesTargetRepo.findByAsOfDate(AS_OF_DATE_2)).thenReturn(null);

		brokerageAndTaxesService.transfer(AS_OF_DATE_2, null, CALLED_BY_USER_ID, request);

		assertEquals(0, testBrokerageAndTaxesRepo.brokerageAndTaxesMap.size());
	}

	@Test
	public void serviceSavesNothingIfTargetRecordIsNull() {
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(AS_OF_DATE_2.toString(),
				brokerageAndTaxesTargetRecord8);

		brokerageAndTaxesService.transfer(AS_OF_DATE_2, null, CALLED_BY_USER_ID, request);

		// should have 6 records in report repo, one was not put in because
		// brokerageAndTaxesTargetRecord8 was null
		assertEquals(6, testBrokerageAndTaxesRepo.brokerageAndTaxesMap.size());
	}

	@Test
	public void chargeAmountReturnsNullIfChargeAmountFromTargetIsNull() {

		brokerageAndTaxesService.transfer(AS_OF_DATE_2, PORT_ID_7, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord7 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord7.getPortfolioCode() + brokerageAndTaxesTargetRecord7.getAsOfDate());

		assertNull(brokerageAndTaxesReportRecord7.getFundChargeAmount());
	}

	@Test
	public void existingRecordShouldBeEndDatedWhenUpdateOccurs() {

		existingReportRecord = new BrokerageAndTaxes();

		existingReportRecord.setId(ID);
		existingReportRecord.setPortfolioId(PORT_ID);
		existingReportRecord.setAsOfDate(AS_OF_DATE);
		existingReportRecord.setFundChargeType("OLD FUND CHARGE TYPE");
		existingReportRecord.setFundChargeCurrency("OLD	CURRENCY");
		existingReportRecord.setFundChargeFrequency("OLD FREQUENCY");
		existingReportRecord.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		existingReportRecord.setLastUpdatedUserId(LAST_UPDATED_USER);

		// put an old record into report table for update testing
		testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.put(existingReportRecord.getPortfolioId() + existingReportRecord.getAsOfDate(), existingReportRecord);

		// pass in both as of date and port id
		brokerageAndTaxesService.transfer(AS_OF_DATE, PORT_ID, CALLED_BY_USER_ID, request);

		BrokerageAndTaxes brokerageAndTaxesReportRecord = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate());

		// check that old record was end dated
		assertNotNull(existingReportRecord.getEffectiveEndDate());

		// assert that the new record was saved to the reporting table too
		assertEquals(PORT_ID, brokerageAndTaxesReportRecord.getPortfolioId());
		assertEquals(AS_OF_DATE, brokerageAndTaxesReportRecord.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord.getLastUpdatedUserId());
	}

}


	ProductDataServiceImplTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadProductPortalException;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;

public class ProductDataServiceImplTest {

	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();

	@InjectMocks
	private ProductDataServiceImpl productDataService;
	
	@Mock
	private Utilities utilities;
	
	private PortalProduct portalProduct1, portalProduct2, portalProduct3, portalProduct4, portalProduct6;

	private Currency currency1, currency2, currency3, currency4, currency6;

	private InvestmentGroup investmentGroup1, investmentGroup2, investmentGroup3, investmentGroup4, investmentGroup6;

	private List<PortalProduct> portalProducts, portalProducts2;

	public Map<String, Limit> dataMap = new HashMap<String, Limit>();
	
	private AccountFund existingAccountFund;
	private AccountSetup existingAccountSetup;
	private AccountBenchmarkAssociation existingAccountBenchmarkAssociation;
	
	private static final String PRODUCT_CODE = "ONE90";
	private static final String PRODUCT_CODE2 = "ONE91";
	private static final String PRODUCT_CODE3 = "CODE03";
	private static final String PRODUCT_CODE4 = "CODE04";
	private static final String PRODUCT_CODE5 = "CODE05";
	private static final String PRODUCT_CODE6 = "CODE06";
	private static final String PRODUCT_NAME = "OnePath Australian Listed Property Index Pool";
	private static final String PRODUCT_NAME2 = "OnePath Australian Bonds Index Pool";
	private static final String PRODUCT_NAME3 = "Product Three";
	private static final String PRODUCT_NAME4 = "Product Four";
	private static final String PRODUCT_NAME6 = "Product Six";
	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final Long INVSTMNT_GRP_ID2 = Long.valueOf(2);
	private static final Long INVSTMNT_GRP_ID3 = Long.valueOf(3);
	private static final Long INVSTMNT_GRP_ID4 = Long.valueOf(4);
	private static final Long INVSTMNT_GRP_ID6 = Long.valueOf(6);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String INVSTMNT_GRP_NAME2 = "Fixed Income Group";
	private static final String INVSTMNT_GRP_NAME3 = "Group Three";
	private static final String INVSTMNT_GRP_NAME4 = "Group Four";
	private static final String INVSTMNT_GRP_NAME6 = "Group Six";
	private static final String CURRENCY_CODE = "AUD";
	private static final String CURRENCY_CODE2 = "USD";
	private static final String CURRENCY_CODE3 = "DSD";
	private static final String CURRENCY_CODE4 = "DDT";
	private static final String CURRENCY_CODE6 = "XXX";
	private static final String CURRENCY_CODE_NOT_FOUND = "N/A";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String INVSTMNT_OBJ2 = "Investment Objective 2";
	private static final String INVSTMNT_OBJ3 = "Investment Objective 3";
	private static final String INVSTMNT_OBJ4 = "Investment Objective 4";
	private static final String INVSTMNT_OBJ6 = "Investment Objective 6";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final String CLIENT_ID = "ANZ OnePath";
	private static final String CLIENT_ID2 = "ANZ OnePath2";
	private static final String CLIENT_ID3 = "ANZ OnePath3";
	private static final String CLIENT_ID4 = "ANZ OnePath4";
	private static final String CLIENT_ID6 = "ANZ OnePath6";
	private static final String BENCHMARK_NAME = "test";
	private static final String BENCHMARK_NAME2 = "Bloomberg AusBond Composite 0+ Years Index";
	private static final String BENCHMARK_NAME3 = "Benchmark Three";
	private static final String BENCHMARK_NAME4 = "Benchmark Four";
	private static final String BENCHMARK_NAME6 = "Benchmark Six";
	
	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);

		portalProducts = new ArrayList<>();
		portalProducts2 = new ArrayList<>();
		
		portalProduct1 = new PortalProduct();
		portalProduct2 = new PortalProduct();
		portalProduct3 = new PortalProduct();
		portalProduct4 = new PortalProduct();
		portalProduct6 = new PortalProduct();

		currency1 = new Currency();
		currency2 = new Currency();
		currency3 = new Currency();
		currency4 = new Currency();
		currency6 = new Currency();

		investmentGroup1 = new InvestmentGroup();
		investmentGroup2 = new InvestmentGroup();
		investmentGroup3 = new InvestmentGroup();
		investmentGroup4 = new InvestmentGroup();
		investmentGroup6 = new InvestmentGroup();

		portalProduct1.setBaseCurrencyID(Long.valueOf(1));
		portalProduct1.setBenchMarkName(BENCHMARK_NAME);
		portalProduct1.setClientID(CLIENT_ID);
		portalProduct1.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct1.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct1.setProductCode(PRODUCT_CODE);
		portalProduct1.setProductName(PRODUCT_NAME);
		portalProduct1.setInvestmentObjective(INVSTMNT_OBJ);

		
		currency1.setCurrencyCode(CURRENCY_CODE);
		currency1.setCurrencyId(Long.valueOf(1));
		currency1.setCurrencyName("Australian Dollar123");

		investmentGroup1.setInvestmentGroupCode("EIG");
		investmentGroup1.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup1.setInvestmentGroupName(INVSTMNT_GRP_NAME);

		portalProduct1.setCurrency(currency1);
		portalProduct1.setInvestmentGroup(investmentGroup1);

		portalProducts.add(portalProduct1);
		
		portalProduct2.setBaseCurrencyID(Long.valueOf(2));
		portalProduct2.setBenchMarkName(BENCHMARK_NAME2);
		portalProduct2.setClientID(CLIENT_ID2);
		portalProduct2.setInvestmentGroupID(INVSTMNT_GRP_ID2);
		portalProduct2.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct2.setProductCode(PRODUCT_CODE2);
		portalProduct2.setProductName(PRODUCT_NAME2);
		portalProduct2.setInvestmentObjective(INVSTMNT_OBJ2);

		currency2.setCurrencyCode(CURRENCY_CODE2);
		currency2.setCurrencyId(Long.valueOf(2));
		currency2.setCurrencyName("Australian Dollar123");

		investmentGroup2.setInvestmentGroupCode("FIG");
		investmentGroup2.setInvestmentGroupId(Long.valueOf(2));
		investmentGroup2.setInvestmentGroupName(INVSTMNT_GRP_NAME2);

		portalProduct2.setCurrency(currency2);
		portalProduct2.setInvestmentGroup(investmentGroup2);

		portalProducts.add(portalProduct2);
		
		portalProduct3.setBaseCurrencyID(Long.valueOf(3));
		portalProduct3.setBenchMarkName(BENCHMARK_NAME3);
		portalProduct3.setClientID(CLIENT_ID3);
		portalProduct3.setInvestmentGroupID(INVSTMNT_GRP_ID3);
		portalProduct3.setPerfInceptionDate("");
		portalProduct3.setProductCode(PRODUCT_CODE3);
		portalProduct3.setProductName(PRODUCT_NAME3);
		portalProduct3.setInvestmentObjective(INVSTMNT_OBJ3);
		
		currency3.setCurrencyCode(CURRENCY_CODE3);
		currency3.setCurrencyId(Long.valueOf(4));
		currency3.setCurrencyName("Australian Dollar333");
		
		investmentGroup3.setInvestmentGroupCode("GIG");
		investmentGroup3.setInvestmentGroupId(Long.valueOf(3));
		investmentGroup3.setInvestmentGroupName(INVSTMNT_GRP_NAME3);
		
		portalProduct3.setCurrency(currency3);
		portalProduct3.setInvestmentGroup(investmentGroup3);
		
		portalProducts.add(portalProduct3);
		
		portalProduct4.setBaseCurrencyID(Long.valueOf(4));
		portalProduct4.setBenchMarkName(BENCHMARK_NAME4);
		portalProduct4.setClientID(CLIENT_ID4);
		portalProduct4.setInvestmentGroupID(INVSTMNT_GRP_ID4);
		portalProduct4.setPerfInceptionDate(null);
		portalProduct4.setProductCode(PRODUCT_CODE4);
		portalProduct4.setProductName(PRODUCT_NAME4);
		portalProduct4.setInvestmentObjective(INVSTMNT_OBJ4);
		
		currency4.setCurrencyCode(CURRENCY_CODE4);
		currency4.setCurrencyId(Long.valueOf(4));
		currency4.setCurrencyName("Australian Dollar444");
		
		investmentGroup4.setInvestmentGroupCode("HIG");
		investmentGroup4.setInvestmentGroupId(Long.valueOf(4));
		investmentGroup4.setInvestmentGroupName(INVSTMNT_GRP_NAME4);
		
		portalProduct4.setCurrency(currency4);
		portalProduct4.setInvestmentGroup(investmentGroup4);
		
		portalProducts.add(portalProduct4);
		
		portalProduct6.setBaseCurrencyID(Long.valueOf(1));
		portalProduct6.setBenchMarkName(BENCHMARK_NAME6);
		portalProduct6.setClientID(CLIENT_ID6);
		portalProduct6.setInvestmentGroupID(INVSTMNT_GRP_ID6);
		portalProduct6.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct6.setProductCode(PRODUCT_CODE6);
		portalProduct6.setProductName(PRODUCT_NAME6);
		portalProduct6.setInvestmentObjective(INVSTMNT_OBJ6);
		
		currency6.setCurrencyCode(CURRENCY_CODE6);
		currency6.setCurrencyId(Long.valueOf(6));
		currency6.setCurrencyName("Australian Dollar666");
		
		investmentGroup6.setInvestmentGroupCode("IIG");
		investmentGroup6.setInvestmentGroupId(Long.valueOf(6));
		investmentGroup6.setInvestmentGroupName(INVSTMNT_GRP_NAME6);
		
		portalProduct6.setCurrency(currency6);
		portalProduct6.setInvestmentGroup(investmentGroup6);
		
		portalProducts2.add(portalProduct6);
		
		
		when(utilities.generateDateFromString(portalProduct1.getPerfInceptionDate(), RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT)).thenReturn(PERF_INCEPT_DATE);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE)).thenReturn(this.portalProduct1);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE2)).thenReturn(this.portalProduct2);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE3)).thenReturn(this.portalProduct3);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE4)).thenReturn(this.portalProduct4);
		when(productPortalService.getProductCurrency(portalProduct1, request)).thenReturn(currency1);
		when(productPortalService.getInvestmentGroup(portalProduct1, request)).thenReturn(investmentGroup1);
		when(productPortalService.getProductCurrency(portalProduct2, request)).thenReturn(currency2);
		when(productPortalService.getInvestmentGroup(portalProduct2, request)).thenReturn(investmentGroup2);
		when(productPortalService.getProductCurrency(portalProduct3, request)).thenReturn(currency3);
		when(productPortalService.getInvestmentGroup(portalProduct3, request)).thenReturn(investmentGroup3);
		when(productPortalService.getProductCurrency(portalProduct4, request)).thenReturn(currency4);
		when(productPortalService.getInvestmentGroup(portalProduct4, request)).thenReturn(investmentGroup4);
		
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE5)).thenReturn(null);
		when(productPortalService.getProduct(portalProducts2, PRODUCT_CODE6)).thenReturn(portalProduct6);
		when(productPortalService.getProductCurrency(portalProduct6, request)).thenReturn(currency6);
		when(productPortalService.getInvestmentGroup(portalProduct6, request)).thenReturn(investmentGroup6);
		
		existingAccountFund = new AccountFund();
		existingAccountFund.setId(987654321L);
		existingAccountFund.setPortfolioId(PRODUCT_CODE6);
		existingAccountFund.setAccountName("old account name");
		existingAccountFund.setPortfolioManagerId(123L);
		existingAccountFund.setPortfolioManager("old portfolio manager");
		existingAccountFund.setPortfolioBaseCurrency("old base currency");
		existingAccountFund.setInvestmentObjective("old objective");
		existingAccountFund.setLastUpdatedUserId("old user");
		existingAccountFund.setAccountType("old account type");
		existingAccountFund.setAssetClassificationId(0L);
		existingAccountFund.setProductEipID(999L);
		
		existingAccountSetup = new AccountSetup();
		existingAccountSetup.setId(345698345L);
		existingAccountSetup.setPortfolioId(PRODUCT_CODE6);
		existingAccountSetup.setAccountClientName("old client name");
		existingAccountSetup.setLastUpdatedUserId("old user");
		existingAccountSetup.setStatusCode("old status code");
		
		existingAccountBenchmarkAssociation = new AccountBenchmarkAssociation();
		existingAccountBenchmarkAssociation.setId(1234876541L);
		existingAccountBenchmarkAssociation.setPortfolioId(PRODUCT_CODE6);
		existingAccountBenchmarkAssociation.setBenchmarkName("old benchmark name");
		existingAccountBenchmarkAssociation.setLastUpdatedUserId("old user");
		
		testAccountFundRepository.accountFundMap.put(PRODUCT_CODE6, existingAccountFund);
		testAccountFundRepository.accountFundMap.put(existingAccountFund.getId().toString(), existingAccountFund);
		testAccountSetupRepository.accountSetupMap.put(PRODUCT_CODE6, existingAccountSetup);
		testAccountSetupRepository.accountSetupMap.put(existingAccountSetup.getId().toString(), existingAccountSetup);
		testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationMap.put(PRODUCT_CODE6, existingAccountBenchmarkAssociation);
		testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationMap.put(existingAccountBenchmarkAssociation.getId().toString(), existingAccountBenchmarkAssociation);
	}

	@Test
	public void valuationsServiceHasHighestPriority() {
		assertEquals(TransferService.Priority.HIGHEST, productDataService.getPriority());
	}

	@Test
	public void serviceWantsToHandleValuationsDataSetTypeRequests() {
		assertTrue(productDataService.handles(null, null, DataSetType.PRODUCT_DATA, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(productDataService.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(productDataService.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	@Test
	public void testMoveProductPortalDataToReport() {
		
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		productDataService.transfer(null, "ONE90", CURRENT_USERNAME, request);
		
		assertEquals(PRODUCT_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioId());
		
		assertEquals(PRODUCT_NAME, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(INVSTMNT_GRP_ID, testAccountFundRepository.accountFunds.get(0).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME, testAccountFundRepository.accountFunds.get(0).getPortfolioManager());
		assertEquals(CURRENCY_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(0).getInceptionDate());
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(0).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE, testAccountSetupRepository.accountSetupList.get(0).getPortfolioId());
		assertEquals(CLIENT_ID, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(0).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getPortfolioId());
		assertEquals(BENCHMARK_NAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getLastUpdatedUserId());
	}

	

	@Test
	public void testMoveAllProductPortalDataToReport() {
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		productDataService.transfer(null, null, CURRENT_USERNAME, request);
			
		assertEquals(PRODUCT_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioId());	
		assertEquals(PRODUCT_NAME, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(INVSTMNT_GRP_ID, testAccountFundRepository.accountFunds.get(0).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME, testAccountFundRepository.accountFunds.get(0).getPortfolioManager());
		assertEquals(CURRENCY_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(0).getInceptionDate());
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(0).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE, testAccountSetupRepository.accountSetupList.get(0).getPortfolioId());
		assertEquals(CLIENT_ID, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(0).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getPortfolioId());
		assertEquals(BENCHMARK_NAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE2, testAccountFundRepository.accountFunds.get(1).getPortfolioId());
		assertEquals(PRODUCT_NAME2, testAccountFundRepository.accountFunds.get(1).getAccountName());
		assertEquals(INVSTMNT_GRP_ID2, testAccountFundRepository.accountFunds.get(1).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME2, testAccountFundRepository.accountFunds.get(1).getPortfolioManager());
		assertEquals(CURRENCY_CODE2, testAccountFundRepository.accountFunds.get(1).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(1).getInceptionDate());
		assertEquals(INVSTMNT_OBJ2, testAccountFundRepository.accountFunds.get(1).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(1).getLastUpdatedUserId());
		
		assertEquals(PRODUCT_CODE2, testAccountSetupRepository.accountSetupList.get(1).getPortfolioId());
		assertEquals(CLIENT_ID2, testAccountSetupRepository.accountSetupList.get(1).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(1).getLastUpdatedUserId());
		
		assertEquals(PRODUCT_CODE2, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(1).getPortfolioId());
		assertEquals(BENCHMARK_NAME2, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(1).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(1).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE3, testAccountFundRepository.accountFunds.get(2).getPortfolioId());
		assertEquals(PRODUCT_NAME3, testAccountFundRepository.accountFunds.get(2).getAccountName());
		assertEquals(INVSTMNT_GRP_ID3, testAccountFundRepository.accountFunds.get(2).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME3, testAccountFundRepository.accountFunds.get(2).getPortfolioManager());
		assertEquals(CURRENCY_CODE3, testAccountFundRepository.accountFunds.get(2).getPortfolioBaseCurrency());
		SimpleDateFormat formatter = new SimpleDateFormat("yyy-MM-dd");
		assertEquals(formatter.format(new Date()), formatter.format(testAccountFundRepository.accountFunds.get(2).getInceptionDate()));
		assertEquals(INVSTMNT_OBJ3, testAccountFundRepository.accountFunds.get(2).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(2).getLastUpdatedUserId());
		
		assertEquals(PRODUCT_CODE3, testAccountSetupRepository.accountSetupList.get(2).getPortfolioId());
		assertEquals(CLIENT_ID3, testAccountSetupRepository.accountSetupList.get(2).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(2).getLastUpdatedUserId());
		
		assertEquals(PRODUCT_CODE3, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(2).getPortfolioId());
		assertEquals(BENCHMARK_NAME3, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(2).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(2).getLastUpdatedUserId());
		
		
		assertEquals(PRODUCT_CODE4, testAccountFundRepository.accountFunds.get(3).getPortfolioId());
		assertEquals(PRODUCT_NAME4, testAccountFundRepository.accountFunds.get(3).getAccountName());
		assertEquals(INVSTMNT_GRP_ID4, testAccountFundRepository.accountFunds.get(3).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME4, testAccountFundRepository.accountFunds.get(3).getPortfolioManager());
		assertEquals(CURRENCY_CODE_NOT_FOUND, testAccountFundRepository.accountFunds.get(3).getPortfolioBaseCurrency());
		assertEquals(formatter.format(new Date()), formatter.format(testAccountFundRepository.accountFunds.get(3).getInceptionDate()));
		assertEquals(INVSTMNT_OBJ4, testAccountFundRepository.accountFunds.get(3).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(3).getLastUpdatedUserId());
		
		assertEquals(PRODUCT_CODE4, testAccountSetupRepository.accountSetupList.get(3).getPortfolioId());
		assertEquals(CLIENT_ID4, testAccountSetupRepository.accountSetupList.get(3).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(3).getLastUpdatedUserId());
		
		assertEquals(PRODUCT_CODE4, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(3).getPortfolioId());
		assertEquals(BENCHMARK_NAME4, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(3).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(3).getLastUpdatedUserId());
	}

	@Test(expected=ReadProductPortalException.class)
	public void serviceThrowsExceptionIfProductCodeIsNotInProductPortal() {
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		productDataService.transfer(null, PRODUCT_CODE5, CURRENT_USERNAME, request);
	}
	
	@Test(expected=ReadProductPortalException.class)
	public void serviceThrowsExceptionIfProductPortalMalfunctions() {
		when(productPortalService.getProducts(request)).thenThrow(new RuntimeException("Test Exception"));
		productDataService.transfer(new Date(), null, CURRENT_USERNAME, request);
	}
	
	@Test(expected=ReadProductPortalException.class)
	public void serviceThrowsExceptionIfProductPortalIsEmpty() {
		when(productPortalService.getProducts(request)).thenReturn(new ArrayList<>());
		productDataService.transfer(null, null, CURRENT_USERNAME, request);
	}
	

	/**
	 * When doing an update, service should check if record with portId exists
	 * 		If it does exist, end date the old record
	 */
	@Test
	public void serviceDoesLogicalUpdateWithSettingEndDate() {
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts2);
		productDataService.transfer(null, PRODUCT_CODE6, CURRENT_USERNAME, request);

		// check that service end-dated existing records in table
		assertNotNull(existingAccountFund.getEffectiveEndDate());
		assertNotNull(existingAccountSetup.getEffectiveEndDate());
		assertNotNull(existingAccountBenchmarkAssociation.getEffectiveEndDate());

		// check new record was added to table
		assertEquals(PRODUCT_CODE6, testAccountFundRepository.accountFunds.get(0).getPortfolioId());
		assertEquals(PRODUCT_NAME6, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(INVSTMNT_GRP_ID6, testAccountFundRepository.accountFunds.get(0).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME6, testAccountFundRepository.accountFunds.get(0).getPortfolioManager());
		assertEquals(CURRENCY_CODE6, testAccountFundRepository.accountFunds.get(0).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(0).getInceptionDate());
		assertEquals(INVSTMNT_OBJ6, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(0).getLastUpdatedUserId());
		assertEquals("TEST", testAccountFundRepository.accountFunds.get(0).getAccountType());
		assertEquals(Long.valueOf(3L), testAccountFundRepository.accountFunds.get(0).getAssetClassificationId());

		assertEquals(PRODUCT_CODE6, testAccountSetupRepository.accountSetupList.get(0).getPortfolioId());
		assertEquals(CLIENT_ID6, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(0).getLastUpdatedUserId());
		assertEquals("ACTIVE", testAccountSetupRepository.accountSetupList.get(0).getStatusCode());

		assertEquals(PRODUCT_CODE6,
				testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getPortfolioId());
		assertEquals(BENCHMARK_NAME6,
				testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getBenchmarkName());
		assertEquals(CURRENT_USERNAME,
				testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getLastUpdatedUserId());
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsExceptionIfCalledByUserIdIsNull() {
		productDataService.transfer(null, PRODUCT_CODE5, null, request);
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsExceptionIfCalledByUserIdIsEmpty() {
		productDataService.transfer(null, PRODUCT_CODE5, "", request);
	}
}


	ValuationsServiceImplTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.mockito.junit.MockitoJUnitRunner;

import com.vanguard.corp.ics.dao.target.ValuationsTargetDAO;
import com.vanguard.corp.ics.repository.target.ValuationsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestValuationReportRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.constants.SecurityTypeCode;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadValuationsException;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;

@RunWith(MockitoJUnitRunner.class)
public class ValuationsServiceImplTest {
	@Spy
	TestValuationReportRepository valReportRepo = new TestValuationReportRepository();
	
	@InjectMocks
	ValuationsServiceImpl valService = new ValuationsServiceImpl();
	
	@Mock
	ValuationsRepository valuationsTargetRepository;
	
	@Mock
	Utilities utilities;
	
	ValuationsTargetDAO valTargetRecord;
	ValuationsReport valReportRecord1;
	ValuationsReport valReportRecord2;
	ValuationsReport valReportRecord3;
	ValuationsReport valReportRecord4;
	ValuationsReport valReportRecord5;
	ValuationsReport valReportRecord6;
	List<ValuationsTargetDAO> TargetRecords = new ArrayList<>();
	Date valuationDate;
	SimpleDateFormat df = new SimpleDateFormat("dd-MMM-yy");

	
	private static final Long id = Long.valueOf(1);
	private static final Long id3 = Long.valueOf(3);
	private static final Long id4 = Long.valueOf(4);
	private static final Long id5 = Long.valueOf(5);
	private static final Long id6 = Long.valueOf(6);
	private static final Long id7 = Long.valueOf(7);
	private static final Long id8 = Long.valueOf(8);
	private static final String portCode = "Test Port Code";
	private static final String currencyCode = "USD";
	private static final String currencyCode2 = "AUD";
	private static final BigDecimal equityValue = new BigDecimal(100.0);
	private static final BigDecimal equityValue2 = new BigDecimal(500.0);
	private static final BigDecimal futuresValue = new BigDecimal(200.0);
	private static final BigDecimal fixedInterestValue = new BigDecimal(300.0);
	private static final BigDecimal ffxValue = new BigDecimal(400.0);
	private static final BigDecimal liquidityValue = new BigDecimal(500.0);
	private static final BigDecimal derivitivesValue = new BigDecimal(600.0);
	private static final BigDecimal totalValue = new BigDecimal(2100.0);
	private static final BigDecimal totalValue2 = new BigDecimal(2500.0);
	private static final String createdUser = "UBUG";
	private static final String updatedUser = "UBUG";
	private static final String calledByUserId = "UXYZ";
	
	
	@Before
	public void init() throws ParseException {
		MockitoAnnotations.initMocks(this);
		
		
		valTargetRecord = new ValuationsTargetDAO();
		valTargetRecord.setId(id);
		valTargetRecord.setValueDate(df.parse("31-jul-17"));
		valTargetRecord.setPortfolioCode(portCode);
		valTargetRecord.setCurrencyCode(currencyCode);
		valTargetRecord.setEquityValue(equityValue);
		valTargetRecord.setFuturesValue(futuresValue);
		valTargetRecord.setFixedInterestValue(fixedInterestValue);
		valTargetRecord.setForwardForiegnExchangeValue(ffxValue);
		valTargetRecord.setLiquidityValue(liquidityValue);
		valTargetRecord.setDerivitivesValue(derivitivesValue);
		valTargetRecord.setTotalValue(totalValue);
		valTargetRecord.setCreatedUser(createdUser);
		valTargetRecord.setCreatedDate(df.parse("4-jul-17"));
		valTargetRecord.setUpdatedUser(updatedUser);
		valTargetRecord.setUpdatedDate(df.parse("17-jul-17"));
		
		valReportRecord1 = new ValuationsReport();
		valReportRecord1.setId(id3);
		valReportRecord1.setPortfolioCode(portCode);
		valReportRecord1.setEffectiveDate(df.parse("30-Oct-17"));
		valReportRecord1.setSecurityTypeCode("EQUI");
		valReportRecord1.setValuationValue(equityValue);
		valReportRecord1.setTotalValue(totalValue);
		valReportRecord1.setCreatedUser(createdUser);
		valReportRecord1.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord1.setLastUpdatedUserId(updatedUser);
		valReportRecord1.setEffectiveBeginDate(new Date());
		valReportRecord1.setEffectiveEndDate(null);
		
		valReportRecord2 = new ValuationsReport();
		valReportRecord2.setId(id4);
		valReportRecord2.setPortfolioCode(portCode);
		valReportRecord2.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord2.setSecurityTypeCode("FUTU");
		valReportRecord2.setValuationValue(futuresValue);
		valReportRecord2.setTotalValue(totalValue);
		valReportRecord2.setCreatedUser(createdUser);
		valReportRecord2.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord2.setLastUpdatedUserId(updatedUser);
		valReportRecord2.setEffectiveBeginDate(new Date());
		valReportRecord2.setEffectiveEndDate(null);
		
		valReportRecord3 = new ValuationsReport();
		valReportRecord3.setId(id5);
		valReportRecord3.setPortfolioCode(portCode);
		valReportRecord3.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord3.setSecurityTypeCode("SECU");
		valReportRecord3.setValuationValue(fixedInterestValue);
		valReportRecord3.setTotalValue(totalValue);
		valReportRecord3.setCreatedUser(createdUser);
		valReportRecord3.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord3.setLastUpdatedUserId(updatedUser);
		valReportRecord3.setEffectiveBeginDate(new Date());
		valReportRecord3.setEffectiveEndDate(null);
		
		valReportRecord4 = new ValuationsReport();
		valReportRecord4.setId(id6);
		valReportRecord4.setPortfolioCode(portCode);
		valReportRecord4.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord4.setSecurityTypeCode("FWFX");
		valReportRecord4.setValuationValue(ffxValue);
		valReportRecord4.setTotalValue(totalValue);
		valReportRecord4.setCreatedUser(createdUser);
		valReportRecord4.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord4.setLastUpdatedUserId(updatedUser);
		valReportRecord4.setEffectiveBeginDate(new Date());
		valReportRecord4.setEffectiveEndDate(null);
		
		valReportRecord5 = new ValuationsReport();
		valReportRecord5.setId(id7);
		valReportRecord5.setPortfolioCode(portCode);
		valReportRecord5.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord5.setSecurityTypeCode("LIQU");
		valReportRecord5.setValuationValue(liquidityValue);
		valReportRecord5.setTotalValue(totalValue);
		valReportRecord5.setCreatedUser(createdUser);
		valReportRecord5.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord5.setLastUpdatedUserId(updatedUser);
		valReportRecord5.setEffectiveBeginDate(new Date());
		valReportRecord5.setEffectiveEndDate(null);
		
		valReportRecord6 = new ValuationsReport();
		valReportRecord6.setId(id8);
		valReportRecord6.setPortfolioCode(portCode);
		valReportRecord6.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord6.setSecurityTypeCode("DERI");
		valReportRecord6.setValuationValue(derivitivesValue);
		valReportRecord6.setTotalValue(totalValue);
		valReportRecord6.setCreatedUser(createdUser);
		valReportRecord6.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord6.setLastUpdatedUserId(updatedUser);
		valReportRecord6.setEffectiveBeginDate(new Date());
		valReportRecord6.setEffectiveEndDate(null);
		
		TargetRecords.add(valTargetRecord);
		List<String> portCodes = new ArrayList<>();
		portCodes.add(portCode);
		
		when(valuationsTargetRepository.findPortIdByDate(valTargetRecord.getValueDate())).thenReturn(portCodes);
	}

	@Test
	public void valuationsServiceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, valService.getPriority());
	}

	@Test
	public void serviceWantsToHandleValuationsDataSetTypeRequests() {
		assertTrue(valService.handles(null, null, DataSetType.VALUATIONS, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(valService.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(valService.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}
	
	@Test
	public void moveValuationsFromTargetToReportTest() throws ParseException{
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		valService.transfer(valTargetRecord.getValueDate(), "Test Port Code", calledByUserId, null);
		
		
		for (SecurityTypeCode value : SecurityTypeCode.values()){
		
			ValuationsReport valReportRecord = valReportRepo.dataMap.get(valTargetRecord.getPortfolioCode() + valTargetRecord.getValueDate().toString() + value.getCode());
			
			switch(value){
				case DERIVATIVES :
					assertEquals(valTargetRecord.getDerivitivesValue(), valReportRecord.getValuationValue());
					
					break;
				case EQUITY : 
					assertEquals(valTargetRecord.getEquityValue(), valReportRecord.getValuationValue());
					
					break;
				case FUTURES : 
					assertEquals(valTargetRecord.getFuturesValue(), valReportRecord.getValuationValue());
					
					break;
				case FORWARD_FOREX :
					assertEquals(valTargetRecord.getForwardForiegnExchangeValue(), valReportRecord.getValuationValue());
					
					break;
				case LIQUIDITY : 
					assertEquals(valTargetRecord.getLiquidityValue(), valReportRecord.getValuationValue());
					
					break;
				case FIXED_INTEREST :
					assertEquals(valTargetRecord.getFixedInterestValue(), valReportRecord.getValuationValue());
					
					break;
			}
			
			assertEquals(portCode, valReportRecord.getPortfolioCode());
			assertEquals(valTargetRecord.getValueDate(), valReportRecord.getEffectiveDate());
			assertEquals(totalValue, valReportRecord.getTotalValue());
			assertEquals(calledByUserId, valReportRecord.getCreatedUser());
			assertEquals(valTargetRecord.getCreatedDate(), valReportRecord.getCreatedDate());
			assertEquals(calledByUserId, valReportRecord.getLastUpdatedUserId());
			assertNull(valReportRecord.getEffectiveEndDate());
			assertEquals(calledByUserId, valReportRecord.getLastUpdatedUserId());
		}
		

	}
	
	@Test
	public void moveAllValuationsFromTargetToReportTest() throws ParseException{
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		valService.transfer(valTargetRecord.getValueDate(), null, calledByUserId, null);
		
		
		for (SecurityTypeCode value : SecurityTypeCode.values()){
		
			ValuationsReport valReportRecord = valReportRepo.dataMap.get(valTargetRecord.getPortfolioCode() + valTargetRecord.getValueDate().toString() + value.getCode());
			
			switch(value){
				case DERIVATIVES :
					assertEquals(valTargetRecord.getDerivitivesValue(), valReportRecord.getValuationValue());
					
					break;
				case EQUITY : 
					assertEquals(valTargetRecord.getEquityValue(), valReportRecord.getValuationValue());
					
					break;
				case FUTURES : 
					assertEquals(valTargetRecord.getFuturesValue(), valReportRecord.getValuationValue());
					
					break;
				case FORWARD_FOREX :
					assertEquals(valTargetRecord.getForwardForiegnExchangeValue(), valReportRecord.getValuationValue());
					
					break;
				case LIQUIDITY : 
					assertEquals(valTargetRecord.getLiquidityValue(), valReportRecord.getValuationValue());
					
					break;
				case FIXED_INTEREST :
					assertEquals(valTargetRecord.getFixedInterestValue(), valReportRecord.getValuationValue());
					
					break;
			}
			
			assertEquals(portCode, valReportRecord.getPortfolioCode());
			assertEquals(valTargetRecord.getValueDate(), valReportRecord.getEffectiveDate());
			assertEquals(totalValue, valReportRecord.getTotalValue());
			assertEquals(calledByUserId, valReportRecord.getCreatedUser());
			assertEquals(valTargetRecord.getCreatedDate(), valReportRecord.getCreatedDate());
			assertNull(valReportRecord.getEffectiveEndDate());
			assertEquals(calledByUserId, valReportRecord.getLastUpdatedUserId());
		}
		

	}
	
	@Test
	public void getValuationTargetRecordTest(){
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		ValuationsTargetDAO testTargetRecord = valService.getValuationTargetRecord(portCode, valTargetRecord.getValueDate());
		
		assertEquals(valTargetRecord.getPortfolioCode(), testTargetRecord.getPortfolioCode());
		assertEquals(valTargetRecord.getValueDate(), testTargetRecord.getValueDate());
		assertEquals(valTargetRecord.getCurrencyCode(), testTargetRecord.getCurrencyCode());
		assertEquals(valTargetRecord.getEquityValue(), testTargetRecord.getEquityValue());
		assertEquals(valTargetRecord.getFuturesValue(), testTargetRecord.getFuturesValue());
		assertEquals(valTargetRecord.getFixedInterestValue(), testTargetRecord.getFixedInterestValue());
		assertEquals(valTargetRecord.getForwardForiegnExchangeValue(), testTargetRecord.getForwardForiegnExchangeValue());
		assertEquals(valTargetRecord.getDerivitivesValue(), testTargetRecord.getDerivitivesValue());
		assertEquals(valTargetRecord.getLiquidityValue(), testTargetRecord.getLiquidityValue());
		assertEquals(valTargetRecord.getTotalValue(), testTargetRecord.getTotalValue());
		assertEquals(valTargetRecord.getCreatedUser(), testTargetRecord.getCreatedUser());
		assertEquals(valTargetRecord.getCreatedDate(), testTargetRecord.getCreatedDate());
		assertEquals(valTargetRecord.getUpdatedUser(), testTargetRecord.getUpdatedUser());
		assertEquals(valTargetRecord.getUpdatedDate(), testTargetRecord.getUpdatedDate());
	}
	
	@Test
	public void serviceEndDatesExistingReportRecordAndInsertsTheNewRecord() {
		ValuationsTargetDAO targetRecord = valTargetRecord;
		targetRecord.setCurrencyCode(currencyCode2);
		targetRecord.setEquityValue(equityValue2);
		targetRecord.setTotalValue(totalValue2);
		
		valReportRepo.dataMap.put(
				valReportRecord1.getPortfolioCode() + valReportRecord1.getEffectiveDate().toString() + valReportRecord1.getSecurityTypeCode() + "Test1"
				, valReportRecord1);

		valReportRepo.dataMap.put(
				valReportRecord2.getPortfolioCode() + valReportRecord2.getEffectiveDate().toString() + valReportRecord2.getSecurityTypeCode() + "Test2"
				, valReportRecord2);
		
		valReportRepo.dataMap.put(
				valReportRecord3.getPortfolioCode() + valReportRecord3.getEffectiveDate().toString() + valReportRecord3.getSecurityTypeCode() + "Test3"
				, valReportRecord3);
		
		valReportRepo.dataMap.put(
				valReportRecord4.getPortfolioCode() + valReportRecord4.getEffectiveDate().toString() + valReportRecord4.getSecurityTypeCode() + "Test4"
				, valReportRecord4);
		
		valReportRepo.dataMap.put(
				valReportRecord5.getPortfolioCode() + valReportRecord5.getEffectiveDate().toString() + valReportRecord5.getSecurityTypeCode() + "Test5"
				, valReportRecord5);
		
		valReportRepo.dataMap.put(
				valReportRecord6.getPortfolioCode() + valReportRecord6.getEffectiveDate().toString() + valReportRecord6.getSecurityTypeCode() + "Test6"
				, valReportRecord6);
		
		
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(targetRecord);
		when(valReportRepo.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(portCode, valReportRecord1.getSecurityTypeCode(), targetRecord.getValueDate()))
			.thenReturn(valReportRecord1);
		when(valReportRepo.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(portCode, valReportRecord2.getSecurityTypeCode(), targetRecord.getValueDate()))
		.thenReturn(valReportRecord2);
		when(valReportRepo.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(portCode, valReportRecord3.getSecurityTypeCode(), targetRecord.getValueDate()))
		.thenReturn(valReportRecord3);
		when(valReportRepo.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(portCode, valReportRecord4.getSecurityTypeCode(), targetRecord.getValueDate()))
		.thenReturn(valReportRecord4);
		when(valReportRepo.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(portCode, valReportRecord5.getSecurityTypeCode(), targetRecord.getValueDate()))
		.thenReturn(valReportRecord5);
		when(valReportRepo.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull(portCode, valReportRecord6.getSecurityTypeCode(), targetRecord.getValueDate()))
		.thenReturn(valReportRecord6);
		
		valService.transfer(valTargetRecord.getValueDate(), portCode, calledByUserId, null);
		assertNotNull(valReportRepo.dataMap.get(valReportRecord1.getPortfolioCode() + valReportRecord1.getEffectiveDate().toString() + valReportRecord1.getSecurityTypeCode() + "Test1").getEffectiveEndDate());
		assertNotNull(valReportRepo.dataMap.get(valReportRecord2.getPortfolioCode() + valReportRecord2.getEffectiveDate().toString() + valReportRecord2.getSecurityTypeCode() + "Test2").getEffectiveEndDate());
		assertNotNull(valReportRepo.dataMap.get(valReportRecord3.getPortfolioCode() + valReportRecord3.getEffectiveDate().toString() + valReportRecord3.getSecurityTypeCode() + "Test3").getEffectiveEndDate());
		assertNotNull(valReportRepo.dataMap.get(valReportRecord4.getPortfolioCode() + valReportRecord4.getEffectiveDate().toString() + valReportRecord4.getSecurityTypeCode() + "Test4").getEffectiveEndDate());
		assertNotNull(valReportRepo.dataMap.get(valReportRecord5.getPortfolioCode() + valReportRecord5.getEffectiveDate().toString() + valReportRecord5.getSecurityTypeCode() + "Test5").getEffectiveEndDate());
		assertNotNull(valReportRepo.dataMap.get(valReportRecord6.getPortfolioCode() + valReportRecord6.getEffectiveDate().toString() + valReportRecord6.getSecurityTypeCode() + "Test6").getEffectiveEndDate());
		
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			
			ValuationsReport valReportRecord = valReportRepo.dataMap.get(valTargetRecord.getPortfolioCode() + valTargetRecord.getValueDate().toString() + value.getCode());
			
			switch(value){
				case DERIVATIVES :
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), totalValue2);
					
					break;
				case EQUITY : 
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getValuationValue(), equityValue2);
					assertEquals(valReportRecord.getTotalValue(), totalValue2);
					
					break;
				case FUTURES : 
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), totalValue2);
					
					break;
				case FORWARD_FOREX :
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), totalValue2);
					
					break;
				case LIQUIDITY : 
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), totalValue2);
					
					break;
				case FIXED_INTEREST :
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), totalValue2);
					
					break;
			}
		}
	}

	@Test(expected=ReadValuationsException.class)
	public void serviceThrowsExceptionWhenTryingToSaveNullDataFromTargetRepository() {
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenThrow(new RuntimeException("Test Valuations Exception"));

		valService.transfer(valTargetRecord.getValueDate(), "Test Port Code", calledByUserId, null);
	}
	
	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfAsOfDateIsNull() {
		valService.transfer(null, null, calledByUserId, null);
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfCalledByUserIdIsNull() {
		valService.transfer(new Date(), null, null, null);
	}
	
	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfCalledByUserIdIsEmpty() {
		valService.transfer(new Date(), null, "", null);
	}
}


com.vanguard.corp.ics.sdt.service.impl.characteristics

	CharacteristicsRepoWrapperTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import static org.junit.Assert.*;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsHelperService.DeleteCombo;


public class CharacteristicsRepoWrapperTest {

	@Test
	public void testSillyPermutationsOfDeleteComboEqualsForCoverage() {
		
		DeleteCombo combo1 = new DeleteCombo("ABC", "123");
		DeleteCombo combo2 = new DeleteCombo("ABC", "123");
		DeleteCombo combo3 = new DeleteCombo("ABC", "124");
		DeleteCombo combo4 = new DeleteCombo("ABD", "123");
		
		assertTrue(combo1.equals(combo1));
		assertTrue(combo1.equals(combo2));
		assertFalse(combo1.equals(combo3));
		assertFalse(combo1.equals(combo4));
		assertFalse(combo1.equals(null));
		assertFalse(combo1.equals(new Object()));
	}

}


com.vanguard.corp.ics.sdt.test.characteristics

	CharacteristicsBuilder.java

package com.vanguard.corp.ics.sdt.test.characteristics;

import java.math.BigDecimal;
import java.util.Date;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

public class CharacteristicsBuilder {

	public Characteristics build(Date effectiveDate, String portId, CharacteristicsType type, String name, String portfolio, String benchmark) {
		Assert.notNull(effectiveDate);
		Assert.notNull(portId);
		
		Characteristics c = new Characteristics();
		c.setEffectiveDate(effectiveDate);
		c.setPortId(portId);
		c.setType(type == null ? null : type.getReportingCode());
		c.setName(name);
		c.setPortfolio(portfolio == null ? null : new BigDecimal(portfolio));
		c.setBenchmark(benchmark == null ? null : new BigDecimal(benchmark));
		return c;
	}
}


	DataTransferServiceApplicationTester.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.test.characteristics;

import static org.mockito.Mockito.mock;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

public class DataTransferServiceApplicationTester extends JerseyTest {

	private DataTransferService mockService;

	public DataTransferService getMockService() {
		return mockService;
	}

	@Override
	protected Application configure() {

		forceSet(TestProperties.CONTAINER_PORT, "0");

		ApplicationContext context = new AnnotationConfigApplicationContext(DataTransferServiceApplicationTester.BeanConfig.class);
		mockService = context.getBean(DataTransferService.class);

		return new ResourceConfig().register(DataTransferResource.class).property("contextConfig", context);
	}

	@Configuration
	public static class BeanConfig {

		@Bean
		public DataTransferService dataTransferService() {
			return mock(DataTransferService.class);
		}
	}
}


	FactsetMonthlyCharacteristicsTargetDAOBuilder.java

package com.vanguard.corp.ics.sdt.test.characteristics;

import java.math.BigDecimal;
import java.util.Date;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;

public class FactsetMonthlyCharacteristicsTargetDAOBuilder {

	public FactsetMonthlyCharacteristicsTargetDAO build(Date effectiveDate, String portId, String type, String name, String portfolio, String benchmark) {
		Assert.notNull(effectiveDate);
		Assert.notNull(portId);
		
		FactsetMonthlyCharacteristicsTargetDAO dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setFactsetEffectiveDate(effectiveDate);
		dao.setPortfolioCode(portId);
		dao.setCharacteristicsType(type);
		dao.setCharacteristicsName(name);
		dao.setPortfolioValue(portfolio == null ? null : new BigDecimal(portfolio));
		dao.setBenchMarkValue(benchmark == null ? null : new BigDecimal(benchmark));

		return dao;
	}
}


	PortfolioCharacteristicsType.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.test.characteristics;


public enum PortfolioCharacteristicsType {

	NUMBER_OF_SECURITIES	("Number of securities")
	, MARKET_CAPITALIZATION	("Weighted average market cap")
	, MIN_MARKET_CAP		("Minimum market cap")
	, MAX_MARKET_CAP		("Maximum market cap")
	, DIVIDEND_YIELD		("Dividend Yield")
	, PRICE_PER_EARNINGS	("Price/Earnings ratio")
	, PPE_USING_FY1_EST		("P/E using FY1 Est")
	, PRICE_PER_CASH_FLOW	("Price/Cash Flow ratio")
	, PRICE_PER_BOOK		("Price/Book ratio")
	, PRICE_PER_SALES		("Price/Sales ratio")
	, ROE					("ROE")
	, EARNINGS_GROWTH_RATE	("Earnings Growth Rate")
	, TURNOVER_1_MON		("Turnover - 1 Month")
	, TURNOVER_3_MON		("Turnover - 3 Months")
	, TURNOVER_12_MON		("Turnover - 12 Months")
	;

	private final String label;

	private PortfolioCharacteristicsType(final String label) {
		this.label = label;
	}

	public String getLabel() {
		return this.label;
	}
}


	TestCharacteristicsType.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.test.characteristics;

import java.util.HashMap;
import java.util.Map;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

public enum TestCharacteristicsType {

	PORTFOLIO_CHARACTERISTICS	(CharacteristicsType.PORTFOLIO_CHARACTERISTICS,	"Portfolio Characteristics")
	, COUNTRY_ALLOCATION		(CharacteristicsType.COUNTRY_ALLOCATION,		"Country Allocation")
	, CURRENCY_ALLOCATION		(CharacteristicsType.CURRENCY_ALLOCATION,		"Currency Allocation")
	, MARKET_SEGMENTATION		(CharacteristicsType.MARKET_SEGMENTATION,		"Market Segmentation by Capitalization")
	, REGIONAL_ALLOCATION		(CharacteristicsType.REGIONAL_ALLOCATION,		"Regional Allocation")
	, SECTOR_ALLOCATION			(CharacteristicsType.SECTOR_ALLOCATION,			"Sector Allocation")
	, TOP_TEN_HOLDINGS			(CharacteristicsType.TOP_TEN_HOLDINGS,			"Top 10 Holdings")
	, UNKNOWN					(CharacteristicsType.UNKNOWN,					"Unknown")
	;

	private static final Map<String, TestCharacteristicsType> typesByName;
	static {
		typesByName = new HashMap<>();
		for (TestCharacteristicsType type : TestCharacteristicsType.values()) {
			typesByName.put(type.fullName, type);
		}
	}

	private final CharacteristicsType type;
	private final String fullName;

	private TestCharacteristicsType(CharacteristicsType type, String fullName) {
		this.type = type;
		this.fullName = fullName;
	}

	public CharacteristicsType getType() {
		return type;
	}

	public static TestCharacteristicsType byName(final String name) {
		return typesByName.get(name);
	}
}


com.vanguard.corp.ics.sdt.test.commentary
	CommentaryServiceApplicationTester.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.test.commentary;

import static org.mockito.Mockito.mock;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.vanguard.corp.ics.sdt.dao.impl.repository.CommentaryRepository;
import com.vanguard.corp.ics.sdt.service.impl.CommentaryServiceImpl;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryResource;

public class CommentaryServiceApplicationTester extends JerseyTest {


	private CommentaryServiceImpl mockService;

	public CommentaryServiceImpl getMockService() {
		return mockService;
	}

	@Override
	protected Application configure() {

		forceSet(TestProperties.CONTAINER_PORT, "0");

		ApplicationContext context = new AnnotationConfigApplicationContext(CommentaryServiceApplicationTester.BeanConfig.class);
		mockService = context.getBean(CommentaryServiceImpl.class);

		return new ResourceConfig().register(CommentaryResource.class).property("contextConfig", context);
	}

	@Configuration
	public static class BeanConfig {

		@Bean
		public CommentaryServiceImpl commentaryService() {
			return mock(CommentaryServiceImpl.class);
		}
		
		@Bean
		public CommentaryRepository commentaryRepository() {
			return mock(CommentaryRepository.class);
		}
	}
}


com.vanguard.corp.ics.sdt.webservice

	ApplicationTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;

import org.apache.catalina.core.StandardHost;
import org.apache.catalina.startup.Tomcat;
import org.apache.commons.lang3.StringUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.FilterRegistrationBean;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.core.Ordered;
import org.springframework.security.config.annotation.ObjectPostProcessor;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.test.util.ReflectionTestUtils;

import com.vanguard.corp.ics.sdt.webservice.Application.ApplicationSecurity;

@RunWith(MockitoJUnitRunner.class)
public class ApplicationTest {

	@InjectMocks
	private Application application;

	@Mock
	private ObjectPostProcessor<Object> mockObjectPostProcessor;

	@Mock
	private AuthenticationManagerBuilder mockAuthenticationManagerBuilder;

	@Before
	public void setUp() {
		MockitoAnnotations.initMocks(this);
		application = new Application();
	}

	@Test
	public void testMain() throws Exception {
		String[] args = { "args" };
		
		Application.isWindowsOS = true;
		SpringApplication app = mock(SpringApplication.class);
		doNothing().when(app).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
		
		Application.app = app;
		when(app.run(args)).thenReturn(null);
		
		Application.main(args);
		verify(app).run(args);
		verify(app).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
	}
	
	@Test
	public void testLocalPropertiesForWindows() {
		SpringApplication app = mock(SpringApplication.class);
		doNothing().when(app).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);

		Application.isWindowsOS = true;
		Application.setLocalProperties(app);
		
		assertEquals(Application.LOCAL_RTEID, System.getProperty(Application.KEY_RTEID));
		verify(app).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
	}
	
	@Test
	public void testLocalPropertiesForNotWindows() {
		SpringApplication app = mock(SpringApplication.class);
		
		Application.isWindowsOS = false;
		Application.setLocalProperties(app);
		
		verify(app, never()).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
	}

	@Test
	public void testCreateTomcatEmbeddedServletContainerFactory() {
		TomcatEmbeddedServletContainerFactory tomcat = application.createTomcatEmbeddedServletContainerFactory();
		assertNotNull(tomcat);
	}

	@Test
	public void testServletContainer() {
		application.tomcat = mock(TomcatEmbeddedServletContainerFactory.class);
		doNothing().when(application.tomcat).addConnectorCustomizers(any());
		
		EmbeddedServletContainerFactory servletContainer = application.servletContainer();
		assertNotNull(servletContainer);
		verify(application.tomcat).addConnectorCustomizers(any());
	}

	@Test
	public void testTomcatEmbeddedServletContainerFactoryCallingGetTomCatEmbeddedServletContainer() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {
		TomcatEmbeddedServletContainerFactory tomcatEmbeddedContainer = application.createTomcatEmbeddedServletContainerFactory();
		Tomcat tomcat = new Tomcat();
		
		//WARNING: Using Reflection to allow access to protected method
		Method method = tomcatEmbeddedContainer.getClass().getDeclaredMethod("getTomcatEmbeddedServletContainer", Tomcat.class);
		method.setAccessible(true);
		TomcatEmbeddedServletContainer result = (TomcatEmbeddedServletContainer) method.invoke(tomcatEmbeddedContainer, tomcat);
		assertNotNull(result);
		assertEquals(StringUtils.EMPTY, (((StandardHost) result.getTomcat().getHost()).getErrorReportValveClass()));
	}
	
	@Test
	public void testNtFilter() {
		FilterRegistrationBean registration = application.ntFilter();
		assertEquals(Ordered.HIGHEST_PRECEDENCE, registration.getOrder());
		assertEquals("/*", registration.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("NTFilter", filterName);
	}
	
	@Test
	public void testRequestContextFilter() {
		FilterRegistrationBean registration = application.requestContextFilter();
		assertEquals(Ordered.HIGHEST_PRECEDENCE + 1, registration.getOrder());
		assertEquals("/*", registration.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("RequestContextFilter", filterName);
	}
	
	@Test
	public void testSpringSecurityFilterChain() {
		FilterRegistrationBean registration = application.springSecurityFilterChain();
		assertEquals(Ordered.HIGHEST_PRECEDENCE + 2, registration.getOrder());
		assertEquals("/*", registration.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("SpringSecurityFilterChain", filterName);
	}
	
	@Test
	public void testF5Filter() {
		FilterRegistrationBean requestContextFilter = application.f5Filter();
		assertEquals(Ordered.HIGHEST_PRECEDENCE + 3, requestContextFilter.getOrder());
		assertEquals("/" + Application.BASE_PATH + "/*", requestContextFilter.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(requestContextFilter, "name"));
		assertEquals("F5Filter", filterName);
	}
//	
//	@Test
//	public void testH2DataSource() {
//		DataSource dataSource = application.h2DataSource();
//
//		assertNotNull(dataSource);
//	}
	
	@Test
	public void testJaxrsFilterForWindows() throws ReflectiveOperationException {
		Application.isWindowsOS = true;
		FilterRegistrationBean registration = application.jaxrsFilter();
		
		assertEquals("/" + Application.BASE_PATH + "/*", registration.getUrlPatterns().iterator().next());
		assertEquals(Application.BASE_PATH, registration.getInitParameters().get("jersey.config.servlet.filter.contextPath"));
		assertEquals("com.vanguard.jaxrs.feature;com.vanguard.corp.ics.sdt", registration.getInitParameters().get("jersey.config.server.provider.packages"));
		assertEquals("xml:application/xml, json:application/json", registration.getInitParameters().get("jersey.config.server.mediaTypeMappings"));
		assertEquals("true", registration.getInitParameters().get("jersey.config.beanValidation.enableOutputValidationErrorEntity.servers"));
		assertEquals("true", registration.getInitParameters().get("jersey.config.servlet.filter.forwardOn404"));
		
		// WIth great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("JerseyFilter", filterName);
		
		assertEquals("true", registration.getInitParameters().get("jaxrs.config.csrf.enableNullOriginBypass"));
		assertEquals("localhost.vanguard.com:8080", registration.getInitParameters().get("jaxrs.config.cors.allowedOrigins"));
		assertEquals("false", registration.getInitParameters().get("jaxrs.config.csrf.enableTokenCheck"));
	}
	
	@Test
	public void testJaxrsFilterForNotWindows() throws Exception {
		Application.isWindowsOS = false;
		FilterRegistrationBean registration = application.jaxrsFilter();
		
		assertEquals("/" + Application.BASE_PATH + "/*", registration.getUrlPatterns().iterator().next());
		assertEquals(Application.BASE_PATH, registration.getInitParameters().get("jersey.config.servlet.filter.contextPath"));
		assertEquals("com.vanguard.jaxrs.feature;com.vanguard.corp.ics.sdt", registration.getInitParameters().get("jersey.config.server.provider.packages"));
		assertEquals("xml:application/xml, json:application/json", registration.getInitParameters().get("jersey.config.server.mediaTypeMappings"));
		assertEquals("true", registration.getInitParameters().get("jersey.config.beanValidation.enableOutputValidationErrorEntity.servers"));
		assertEquals("true", registration.getInitParameters().get("jersey.config.servlet.filter.forwardOn404"));
		
		// WIth great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("JerseyFilter", filterName);
		
		assertNull(registration.getInitParameters().get("jaxrs.config.csrf.enableNullOriginBypass"));
		assertNull(registration.getInitParameters().get("jaxrs.config.cors.allowedOrigins"));
		assertNull(registration.getInitParameters().get("jaxrs.config.csrf.enableTokenCheck"));
	}
	
	@Test
	public void testJaxrsFilterJerseyDebugEnabled() throws ReflectiveOperationException {
		Application.isWindowsOS = false;
		application.isJerseyDebug = true;
		
		FilterRegistrationBean registration = application.jaxrsFilter();
		
		assertEquals("true", registration.getInitParameters().get("jersey.config.server.monitoring.statistics.enabled"));
		assertEquals("ALL", registration.getInitParameters().get("jersey.config.server.tracing.type"));
		assertEquals("VERBOSE", registration.getInitParameters().get("jersey.config.server.tracing.threshold"));
	}
	
	@Test
	public void testJaxrsFilterJerseyDebugDisabled() throws ReflectiveOperationException {
		Application.isWindowsOS = false;
		application.isJerseyDebug = false;
		
		FilterRegistrationBean registration = application.jaxrsFilter();
		
		assertNull(registration.getInitParameters().get("jersey.config.server.monitoring.statistics.enabled"));
		assertNull(registration.getInitParameters().get("jersey.config.server.tracing.type"));
		assertNull(registration.getInitParameters().get("jersey.config.server.tracing.threshold"));
	}
	
	@Test
	public void testApplicationSecurity() throws Exception {
		ApplicationSecurity applicationSecurity = application.applicationSecurity();
		assertNotNull(applicationSecurity);
		
		applicationSecurity.configure(new HttpSecurity(mockObjectPostProcessor, mockAuthenticationManagerBuilder, new HashMap<>()));
	}
}


	NonProductionConditionTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;


public class NonProductionConditionTest {

	private NonProductionCondition classUnderTest = new NonProductionCondition();

	@Mock
	private ConditionContext mockContext;

	@Mock
	private Environment mockEnvironment;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testMatchesNonProd() {
		when(mockContext.getEnvironment()).thenReturn(mockEnvironment);
		when(mockEnvironment.getProperty("RTEID")).thenReturn("test");
		
		assertTrue(classUnderTest.matches(mockContext, null));
	}

	@Test
	public void testMatchesProd() {
		when(mockContext.getEnvironment()).thenReturn(mockEnvironment);
		when(mockEnvironment.getProperty("RTEID")).thenReturn("prdprd");
		
		assertFalse(classUnderTest.matches(mockContext, null));
	}

}


	NTHeaderFilterTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.Principal;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Locale;
import java.util.Map;

import javax.servlet.AsyncContext;
import javax.servlet.DispatcherType;
import javax.servlet.FilterChain;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletInputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.webservice.NTHeaderFilter.FakeHeadersRequest;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpUpgradeHandler;
import javax.servlet.http.Part;


public class NTHeaderFilterTest {

	private NTHeaderFilter classUnderTest = new NTHeaderFilter();

//	@Mock
	private HttpServletRequest mockRequest;
	private ServletResponse mockResponse;

	@Mock
	private FilterChain mockChain;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		
		mockRequest = new HttpServletRequest() {

			@Override
			public AsyncContext getAsyncContext() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Object getAttribute(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<String> getAttributeNames() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getCharacterEncoding() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getContentLength() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public long getContentLengthLong() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public String getContentType() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public DispatcherType getDispatcherType() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public ServletInputStream getInputStream() throws IOException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getLocalAddr() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getLocalName() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getLocalPort() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public Locale getLocale() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<Locale> getLocales() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getParameter(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Map<String, String[]> getParameterMap() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<String> getParameterNames() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String[] getParameterValues(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getProtocol() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public BufferedReader getReader() throws IOException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRealPath(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRemoteAddr() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRemoteHost() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getRemotePort() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public RequestDispatcher getRequestDispatcher(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getScheme() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getServerName() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getServerPort() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public ServletContext getServletContext() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public boolean isAsyncStarted() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isAsyncSupported() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isSecure() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public void removeAttribute(String arg0) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void setAttribute(String arg0, Object arg1) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {
				// TODO Auto-generated method stub
				
			}

			@Override
			public AsyncContext startAsync() throws IllegalStateException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public AsyncContext startAsync(ServletRequest arg0, ServletResponse arg1) throws IllegalStateException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public boolean authenticate(HttpServletResponse arg0) throws IOException, ServletException {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public String changeSessionId() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getAuthType() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getContextPath() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Cookie[] getCookies() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public long getDateHeader(String arg0) {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public String getHeader(String arg0) {
				return "Hi!  I'm a header value!";
			}

			@Override
			public Enumeration<String> getHeaderNames() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<String> getHeaders(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getIntHeader(String arg0) {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public String getMethod() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Part getPart(String arg0) throws IOException, ServletException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Collection<Part> getParts() throws IOException, ServletException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getPathInfo() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getPathTranslated() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getQueryString() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRemoteUser() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRequestURI() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public StringBuffer getRequestURL() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRequestedSessionId() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getServletPath() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public HttpSession getSession() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public HttpSession getSession(boolean arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Principal getUserPrincipal() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public boolean isRequestedSessionIdFromCookie() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isRequestedSessionIdFromURL() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isRequestedSessionIdFromUrl() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isRequestedSessionIdValid() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isUserInRole(String arg0) {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public void login(String arg0, String arg1) throws ServletException {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void logout() throws ServletException {
				// TODO Auto-generated method stub
				
			}

			@Override
			public <T extends HttpUpgradeHandler> T upgrade(Class<T> arg0) throws IOException, ServletException {
				// TODO Auto-generated method stub
				return null;
			}
			
		};
	}

	@Test
	public void testNTHeaderFilter() {
		assertNotNull(new NTHeaderFilter());
	}

	@Test
	public void testDestroy() {
		classUnderTest.destroy();
	}

	@Test
	public void testInit() throws ServletException {
		classUnderTest.init(null);
	}

	@Test
	public void testDoFilter() throws IOException, ServletException {
		doNothing().when(mockChain).doFilter(any(FakeHeadersRequest.class), any(ServletResponse.class));
		
		classUnderTest.doFilter(mockRequest, mockResponse, mockChain);
	}

	@Test
	public void testFakeHeadersRequest() {
		NTHeaderFilter x = new NTHeaderFilter();
		FakeHeadersRequest req = x.new FakeHeadersRequest(mockRequest);
		
		String header = req.getHeader("APP_CODE");
		assertEquals("SDT", header);
		
		header = req.getHeader("other");
		assertEquals("Hi!  I'm a header value!", header);
	}
}



com.vanguard.corp.ics.sdt.webservice.cucumber

	RunAdHocCuke.java

package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = { "@AdHoc" }
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT + "adhoc"
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS + "adhoc/adhoc-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT + "adhoc/adhoc-test-reports.xml"
				}
)
public class RunAdHocCuke {


}


	RunEndToEndCukeTest.java
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;
import com.vanguard.test.categories.EndToEndTest;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@Category(EndToEndTest.class)
@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = {
				"~@ManualTest"
				, "~@SlowTest"
				, "~@IgnoreTest"
				, "~@AdHoc"
				, "@EndToEndTest"
				}
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT_ENDTOEND
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS_ENDTOEND + "endtoend-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT_ENDTOEND + "endtoend-test-reports.xml"
				}
)
public class RunEndToEndCukeTest {

}


	RunIgnoreCukeTest.java

package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = false
		, monochrome = true
		, tags = { "@IgnoreTest" }
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT + "ignore/ignore"
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS + "ignore/ignore-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT + "ignore/ignore-test-reports.xml"
				}
)
public class RunIgnoreCukeTest {

//	This is a tagged hook so that test marked Ignore will show up in the Cucumber Jenkins Report.
//	This code should be added in a Hooks class for use. For more information on Hooks see Best Practices or cucumber book.
//	@Before("@IgnoreTest")
//	public void beforeScenario() {
//		Assume.assumeTrue("These tests are marked IGNORE and will be counted as Skipped.", false);
//	} 
}


	RunIntegrationCukeTest.java

package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;
import com.vanguard.test.categories.IntegrationTest;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@Category(IntegrationTest.class)
@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = {
				"~@ManualTest"
				, "~@SlowTest"
				, "~@IgnoreTest"
				, "~@AdHoc"
				, "@IntegrationTest"
				}
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT_INTEGRATION
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS_INTEGRATION + "integration-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT_INTEGRATION + "integration-test-reports.xml"
				}
)
public class RunIntegrationCukeTest {
	
}


	RunRegressionCukeTest.java

package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = false
		, monochrome = true
		, tags = { "@ManualTest" }
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, glue = { "com.vanguard.shared" }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT + "manual/manual"
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS + "manual/manual-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT + "manual/manual-test-reports.xml"
				}
)
public class RunRegressionCukeTest {


}


	RunUnitCukeTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2015 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL: http://prdsvnrepo:8080/svn/shared/projects/cucumber-inner-source/trunk/src/test/java/com/vanguard/RunUnitCukeTest.java $
 $LastChangedRevision: 2839 $
 $Author: udwd $
 $LastChangedDate: 2016-03-10 16:01:42 -0500 (Thu, 10 Mar 2016) $
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;
import com.vanguard.test.categories.UnitTest;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@Category(UnitTest.class)
@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = {
				"~@ManualTest"
				, "~@SlowTest"
				, "~@IgnoreTest"
				, "~@AdHoc"
				, "@UnitTest"
				}
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT_UNIT
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS_UNIT + "unit-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT_UNIT + "unit-test-reports.xml"
				}
)
public class RunUnitCukeTest {
	
}


com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs

	BrokerageAndTaxesStepDefs.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import java.math.BigDecimal;
import java.util.Date;

import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.BrokerageAndTaxes;
import com.vanguard.corp.ics.sdt.dao.impl.entity.target.BrokerageAndTaxesTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestBrokerageAndTaxesRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestBrokerageAndTaxesTargetRepository;
import com.vanguard.corp.ics.sdt.service.impl.BrokerageAndTaxesServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class BrokerageAndTaxesStepDefs {

	@Spy
	TestBrokerageAndTaxesTargetRepository testBrokerageAndTaxesTargetRepo = new TestBrokerageAndTaxesTargetRepository();

	@Spy
	TestBrokerageAndTaxesRepository testBrokerageAndTaxesRepo = new TestBrokerageAndTaxesRepository();

	@InjectMocks
	private BrokerageAndTaxesServiceImpl brokerageAndTaxesService;

	private BrokerageAndTaxesTargetDAO brokerageAndTaxesTargetRecord, brokerageAndTaxesTargetRecord2,
			brokerageAndTaxesTargetRecord3, brokerageAndTaxesTargetRecord4;
	
	BrokerageAndTaxes existingReportRecord;

	private static final Long ID = Long.valueOf(1);
	private static final String PORT_ID = "ONE88";
	private static final String PORT_ID_2 = "ONE89";
	private static final String PORT_ID_3 = "ONE90";
	private static final String PORT_ID_4 = "ONE91";
	private static final Date AS_OF_DATE = new Date(1);
	private static final Date AS_OF_DATE_2 = new Date(50000000);
	private static final String FUND_CHARGE_TYPE = "Taxes";
	private static final String FUND_CHARGE_CURRENCY = "AUD";
	private static final String FUND_CHARGE_FREQUENCY = "1MO";
	private static final BigDecimal FUND_CHARGE_AMOUNT = new BigDecimal(100);
	private static final String LAST_UPDATED_USER = "UXXX";
	private static final String CALLED_BY_USER_ID = "UABC";

	@Given("^target tables contains positive and whole brokerage and taxes data for multiple port ids and multiple as of dates$")
	public void target_tables_contains_positive_and_whole_brokerage_and_taxes_data_for_multiple_port_ids_and_multiple_as_of_dates()
			throws Throwable {

		MockitoAnnotations.initMocks(this);

		brokerageAndTaxesTargetRecord = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord2 = new BrokerageAndTaxesTargetDAO();
		brokerageAndTaxesTargetRecord3 = new BrokerageAndTaxesTargetDAO();

		brokerageAndTaxesTargetRecord.setId(ID);
		brokerageAndTaxesTargetRecord.setPortfolioCode(PORT_ID);
		brokerageAndTaxesTargetRecord.setAsOfDate(AS_OF_DATE);
		brokerageAndTaxesTargetRecord.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord.setUpdatedUser(LAST_UPDATED_USER);

		brokerageAndTaxesTargetRecord2.setId(Long.valueOf(2));
		brokerageAndTaxesTargetRecord2.setPortfolioCode(PORT_ID_2);
		brokerageAndTaxesTargetRecord2.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord2.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord2.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord2.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord2.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord2.setUpdatedUser(LAST_UPDATED_USER);

		brokerageAndTaxesTargetRecord3.setId(Long.valueOf(3));
		brokerageAndTaxesTargetRecord3.setPortfolioCode(PORT_ID_3);
		brokerageAndTaxesTargetRecord3.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord3.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord3.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord3.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord3.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		brokerageAndTaxesTargetRecord3.setUpdatedUser(LAST_UPDATED_USER);

		// put target records into map field
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate(),
				brokerageAndTaxesTargetRecord);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord2.getPortfolioCode() + brokerageAndTaxesTargetRecord2.getAsOfDate(),
				brokerageAndTaxesTargetRecord2);
		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord3.getPortfolioCode() + brokerageAndTaxesTargetRecord3.getAsOfDate(),
				brokerageAndTaxesTargetRecord3);
	}

	@Given("^target tables contain no brokerage and taxes data$")
	public void targetTablesContainNoBrokerageAndTaxesData() throws Throwable {
		MockitoAnnotations.initMocks(this);

		brokerageAndTaxesTargetRecord = null;
		brokerageAndTaxesTargetRecord2 = null;
		brokerageAndTaxesTargetRecord3 = null;

		// don't add to brokerageAndTaxesMap in test target repo to signify no
		// data in target table
	}

	@Given("^target tables contain brokerage and taxes data with value of (\\d+)$")
	public void targetTablesContainBrokerageAndTaxesDataWithValueOf(int specifiedValue) throws Throwable {
		MockitoAnnotations.initMocks(this);

		brokerageAndTaxesTargetRecord4 = new BrokerageAndTaxesTargetDAO();

		brokerageAndTaxesTargetRecord4.setId(ID);
		brokerageAndTaxesTargetRecord4.setPortfolioCode(PORT_ID_4);
		brokerageAndTaxesTargetRecord4.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord4.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord4.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeAmount(BigDecimal.valueOf(specifiedValue));
		brokerageAndTaxesTargetRecord4.setUpdatedUser(LAST_UPDATED_USER);

		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord4.getPortfolioCode() + brokerageAndTaxesTargetRecord4.getAsOfDate(),
				brokerageAndTaxesTargetRecord4);

	}

	@Given("^target table data has the value of (.+)$")
	public void targetTableDataHasTheValueOf(BigDecimal specifiedValue) throws Throwable {
		MockitoAnnotations.initMocks(this);

		brokerageAndTaxesTargetRecord4 = new BrokerageAndTaxesTargetDAO();

		brokerageAndTaxesTargetRecord4.setId(ID);
		brokerageAndTaxesTargetRecord4.setPortfolioCode(PORT_ID_4);
		brokerageAndTaxesTargetRecord4.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord4.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord4.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeAmount(specifiedValue);
		brokerageAndTaxesTargetRecord4.setUpdatedUser(LAST_UPDATED_USER);

		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord4.getPortfolioCode() + brokerageAndTaxesTargetRecord4.getAsOfDate(),
				brokerageAndTaxesTargetRecord4);
	}
	
	@Given("^an active portfolio with the same portfolio code and as of date exists in the reporting table$")
	public void an_active_portfolio_with_the_same_portfolio_code_and_as_of_date_exists_in_the_reporting_table() throws Throwable {
		existingReportRecord = new BrokerageAndTaxes();

		existingReportRecord.setId(ID);
		existingReportRecord.setPortfolioId(PORT_ID);
		existingReportRecord.setAsOfDate(AS_OF_DATE);
		existingReportRecord.setFundChargeType("OLD FUND CHARGE TYPE");
		existingReportRecord.setFundChargeCurrency("OLD	CURRENCY");
		existingReportRecord.setFundChargeFrequency("OLD FREQUENCY");
		existingReportRecord.setFundChargeAmount(FUND_CHARGE_AMOUNT);
		existingReportRecord.setLastUpdatedUserId(LAST_UPDATED_USER);

		// put an old record into report table for update testing
		testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.put(existingReportRecord.getPortfolioId() + existingReportRecord.getAsOfDate(), existingReportRecord);
	}

	@Given("^target tables contain a null value for fund charge amount$")
	public void target_tables_contain_a_null_value_for_fund_charge_amount() throws Throwable {
		MockitoAnnotations.initMocks(this);

		brokerageAndTaxesTargetRecord4 = new BrokerageAndTaxesTargetDAO();

		brokerageAndTaxesTargetRecord4.setId(ID);
		brokerageAndTaxesTargetRecord4.setPortfolioCode(PORT_ID_4);
		brokerageAndTaxesTargetRecord4.setAsOfDate(AS_OF_DATE_2);
		brokerageAndTaxesTargetRecord4.setFundChargeType(FUND_CHARGE_TYPE);
		brokerageAndTaxesTargetRecord4.setFundChargeCurrency(FUND_CHARGE_CURRENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeFrequency(FUND_CHARGE_FREQUENCY);
		brokerageAndTaxesTargetRecord4.setFundChargeAmount(null);
		brokerageAndTaxesTargetRecord4.setUpdatedUser(LAST_UPDATED_USER);

		testBrokerageAndTaxesTargetRepo.brokerageAndTaxesTargetMap.put(
				brokerageAndTaxesTargetRecord4.getPortfolioCode() + brokerageAndTaxesTargetRecord4.getAsOfDate(),
				brokerageAndTaxesTargetRecord4);
	}

	@When("^brokerage and taxes data are transferred with as of date targeted$")
	public void brokerage_and_taxes_data_are_transferred_with_as_of_date_targeted() throws Throwable {
		// don't pass in a port id
		brokerageAndTaxesService.transfer(AS_OF_DATE_2, null, CALLED_BY_USER_ID, null);
	}

	@When("^brokerage and taxes data are transferred with as of date and port id targeted$")
	public void brokerage_and_taxes_data_are_transferred_with_as_of_date_and_port_id_targeted() throws Throwable {
		brokerageAndTaxesService.transfer(AS_OF_DATE, PORT_ID, CALLED_BY_USER_ID, null);
	}

	@When("^brokerage and taxes data are transferred with as of date targeted anyway$")
	public void brokerageAndTaxesDataAreTransferredWithAsOfDateTargetedAnyway() throws Throwable {
		brokerageAndTaxesService.transfer(AS_OF_DATE, null, CALLED_BY_USER_ID, null);
	}

	@When("^brokerage and taxes data are transferred$")
	public void brokerageAndTaxesDataAreTransferred() throws Throwable {
		brokerageAndTaxesService.transfer(AS_OF_DATE_2, null, CALLED_BY_USER_ID, null);
	}

	@Then("^the brokerage and taxes data for the targeted as of date are saved to reporting tables$")
	public void the_brokerage_and_taxes_data_for_the_targeted_as_of_date_are_saved_to_reporting_tables()
			throws Throwable {

		BrokerageAndTaxes brokerageAndTaxesReportRecord2 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord2.getPortfolioCode() + brokerageAndTaxesTargetRecord2.getAsOfDate());

		BrokerageAndTaxes brokerageAndTaxesReportRecord3 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord3.getPortfolioCode() + brokerageAndTaxesTargetRecord3.getAsOfDate());

		assertNotNull(brokerageAndTaxesReportRecord2);
		assertNotNull(brokerageAndTaxesReportRecord3);

	}

	@Then("^no brokerage and taxes data for other as of dates are saved to reporting tables$")
	public void no_brokerage_and_taxes_data_for_other_as_of_dates_are_saved_to_reporting_tables() throws Throwable {

		// pull in a record with a different asOfDate, should be null since
		// service didn't save it to report table
		BrokerageAndTaxes brokerageAndTaxesReportRecord = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate());

		assertNull(brokerageAndTaxesReportRecord);
	}

	@Then("^the saved brokerage and taxes data exactly match the source data$")
	public void the_saved_brokerage_and_taxes_data_exactly_match_the_source_data() throws Throwable {

		BrokerageAndTaxes brokerageAndTaxesReportRecord2 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord2.getPortfolioCode() + brokerageAndTaxesTargetRecord2.getAsOfDate());

		BrokerageAndTaxes brokerageAndTaxesReportRecord3 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord3.getPortfolioCode() + brokerageAndTaxesTargetRecord3.getAsOfDate());

		assertEquals(PORT_ID_2, brokerageAndTaxesReportRecord2.getPortfolioId());
		assertEquals(AS_OF_DATE_2, brokerageAndTaxesReportRecord2.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord2.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord2.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord2.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord2.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord2.getLastUpdatedUserId());

		assertEquals(PORT_ID_3, brokerageAndTaxesReportRecord3.getPortfolioId());
		assertEquals(AS_OF_DATE_2, brokerageAndTaxesReportRecord3.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord3.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord3.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord3.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord3.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord3.getLastUpdatedUserId());

	}

	@Then("^the brokerage and taxes data for the targeted port id and as of date are saved to reporting tables$")
	public void the_brokerage_and_taxes_data_for_the_targeted_port_id_and_as_of_date_are_saved_to_reporting_tables()
			throws Throwable {

		BrokerageAndTaxes brokerageAndTaxesReportRecord = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate());

		assertNotNull(brokerageAndTaxesReportRecord);

		assertEquals(PORT_ID, brokerageAndTaxesReportRecord.getPortfolioId());
		assertEquals(AS_OF_DATE, brokerageAndTaxesReportRecord.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord.getLastUpdatedUserId());

	}

	@Then("^no brokerage and taxes data for other port ids or as of dates are saved to reporting tables$")
	public void no_brokerage_and_taxes_data_for_other_port_ids_or_as_of_dates_are_saved_to_reporting_tables()
			throws Throwable {
		// pull in a record with a different asOfDate, should be null since
		// service didn't save it to report table
		BrokerageAndTaxes brokerageAndTaxesReportRecord2 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord2.getPortfolioCode() + brokerageAndTaxesTargetRecord2.getAsOfDate());

		BrokerageAndTaxes brokerageAndTaxesReportRecord3 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord3.getPortfolioCode() + brokerageAndTaxesTargetRecord3.getAsOfDate());

		assertNull(brokerageAndTaxesReportRecord2);
		assertNull(brokerageAndTaxesReportRecord3);
	}

	@Then("^no brokerage and taxes data are saved to reporting tables$")
	public void noBrokerageAndTaxesDataAreSavedToReportingTables() throws Throwable {
		BrokerageAndTaxes brokerageAndTaxesReportRecord = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID + AS_OF_DATE);

		BrokerageAndTaxes brokerageAndTaxesReportRecord2 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID_2 + AS_OF_DATE_2);

		BrokerageAndTaxes brokerageAndTaxesReportRecord3 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID_3 + AS_OF_DATE_2);

		assertNull(brokerageAndTaxesReportRecord);
		assertNull(brokerageAndTaxesReportRecord2);
		assertNull(brokerageAndTaxesReportRecord3);
		assertEquals(0, testBrokerageAndTaxesRepo.brokerageAndTaxesMap.size());
	}

	@Then("^brokerage and taxes data with value of (\\d+) are saved to reporting tables$")
	public void brokerageAndTaxesDataWithValueOfAreSavedToReportingTables(int specifiedValue) throws Throwable {
		BrokerageAndTaxes brokerageAndTaxesReportRecord4 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID_4 + AS_OF_DATE_2);

		assertEquals(specifiedValue, brokerageAndTaxesReportRecord4.getFundChargeAmount().intValue());
	}

	@Then("^the value should be rounded to (.+)$")
	public void theValueShouldBeRoundedTo(int roundedValue) throws Throwable {
		BrokerageAndTaxes brokerageAndTaxesReportRecord4 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID_4 + AS_OF_DATE_2);

		assertEquals(roundedValue, brokerageAndTaxesReportRecord4.getFundChargeAmount().intValue());
	}

	@Then("^the brokerage and taxes data are saved to reporting table$")
	public void theBrokerageAndTaxesDataAreSavedToReportingTable() throws Throwable {
		BrokerageAndTaxes brokerageAndTaxesReportRecord4 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID_4 + AS_OF_DATE_2);

		assertNotNull(brokerageAndTaxesReportRecord4);
	}
	
	@Then("^the existing record in the reporting table is end dated$")
	public void the_existing_record_in_the_report_table_is_end_dated() throws Throwable {
		assertNotNull(existingReportRecord.getEffectiveEndDate());
	} 
	
	@Then("^the new record is saved into the reporting table$")
	public void the_new_record_is_saved_into_the_reporting_table() throws Throwable {
		BrokerageAndTaxes brokerageAndTaxesReportRecord = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(brokerageAndTaxesTargetRecord.getPortfolioCode() + brokerageAndTaxesTargetRecord.getAsOfDate());

		assertNotNull(brokerageAndTaxesReportRecord);

		assertEquals(PORT_ID, brokerageAndTaxesReportRecord.getPortfolioId());
		assertEquals(AS_OF_DATE, brokerageAndTaxesReportRecord.getAsOfDate());
		assertEquals(FUND_CHARGE_TYPE, brokerageAndTaxesReportRecord.getFundChargeType());
		assertEquals(FUND_CHARGE_CURRENCY, brokerageAndTaxesReportRecord.getFundChargeCurrency());
		assertEquals(FUND_CHARGE_FREQUENCY, brokerageAndTaxesReportRecord.getFundChargeFrequency());
		assertEquals(FUND_CHARGE_AMOUNT, brokerageAndTaxesReportRecord.getFundChargeAmount());
		assertEquals(CALLED_BY_USER_ID, brokerageAndTaxesReportRecord.getLastUpdatedUserId());
	}
	
	@Then("^fund charge amount in report table should be null$")
	public void fund_charge_amount_in_report_table_should_be_null() throws Throwable {
		BrokerageAndTaxes brokerageAndTaxesReportRecord4 = testBrokerageAndTaxesRepo.brokerageAndTaxesMap
				.get(PORT_ID_4 + AS_OF_DATE_2);
		
		assertNull(brokerageAndTaxesReportRecord4.getFundChargeAmount());
	}

}


	CalculationEngineResourceSteps.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Optional;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.portal.PortalService;
import com.vanguard.corp.ics.portal.domain.Product;
import com.vanguard.corp.ics.sdt.service.calculation.PerformanceCalculationService;
import com.vanguard.corp.ics.sdt.webservice.resource.CalculationEngineParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.CalculationEngineResource;
import com.vanguard.corp.ics.sdt.webservice.resource.CalculationSingleParameters;

import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CalculationEngineResourceSteps {

	private static final Integer TEST_MONTH = 12;
	private static final Integer TEST_YEAR = 2017;

	@InjectMocks
	private CalculationEngineResource unitUnderTest;

	@Mock
	private PerformanceCalculationService calcService;

	@Mock
	private PortalService portal;

	@When("^user calls calculation resource without protfolio$")
	public void user_calls_calculation_resource() throws Throwable {
		MockitoAnnotations.initMocks(this);
		CalculationEngineParameters parms = new CalculationEngineParameters();
		parms.setMonth(TEST_MONTH);
		parms.setYear(TEST_YEAR);
		unitUnderTest.finalCalcsAll(parms);
	}

	@Then("^calculation engine is called$")
	public void calculation_engine_is_called() throws Throwable {
//		verify(calcService, times(1)).calculate(TEST_MONTH, TEST_YEAR);
	}

	@When("^user calls calculation resource portfolio (.*)$")
	public void user_calls_calculation_resource_portfolio(String portfolioName) throws Throwable {
		MockitoAnnotations.initMocks(this);
		if ("ABC".equalsIgnoreCase(portfolioName)) {
			when(portal.getProduct(portfolioName)).thenReturn(Optional.of(new Product()));
		}
		CalculationSingleParameters parms = new CalculationSingleParameters();
		parms.setPortfolioCode(portfolioName);
		parms.setMonth(TEST_MONTH);
		parms.setYear(TEST_YEAR);
		unitUnderTest.finalCalcsSingle(parms);
	}

	@Then("^calculation engine is called with (.*)$")
	public void calculation_engine_is_called_with_protfolio(String portfolioName) throws Throwable {
		if ("ABC".equalsIgnoreCase(portfolioName)) {
//			verify(calcService, times(1)).calculate(any(), any(), any());
		} else {
//			verify(calcService, times(0)).calculate(any(), any(), any());
		}
	}
}


	InvestmentObjectiveStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import static org.junit.Assert.*;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ProductDataServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class InvestmentObjectiveStepDefs {

	private static final String PRODUCT_CODE = "ONE90";
	private static final String PRODUCT_NAME = "OnePath Australian Listed Property Index Pool";
	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String CURRENCY_CODE = "AUD";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final String CLIENT_ID = "ANZ OnePath";
	private static final String BENCHMARK_NAME = "test";

	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();

	@InjectMocks
	private ProductDataServiceImpl productDataService;

	@Mock
	private Utilities utilities;

	private PortalProduct portalProduct;

	private Currency currency;

	private InvestmentGroup investmentGroup;

	private List<PortalProduct> portalProducts;

	private AccountFund existingAccountFundRecord;

	@Given("^a portfolio with Investment Objective that exists in Product Portal$")
	public void a_portfolio_with_Investment_Objective_that_exists_in_Product_Portal() throws Throwable {
		// Write code here that turns the phrase above into concrete actions
		MockitoAnnotations.initMocks(this);

		portalProducts = new ArrayList<>();

		portalProduct = new PortalProduct();
		currency = new Currency();
		investmentGroup = new InvestmentGroup();

		portalProduct.setBaseCurrencyID(Long.valueOf(1));
		portalProduct.setBenchMarkName(BENCHMARK_NAME);
		portalProduct.setClientID(CLIENT_ID);
		portalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct.setProductCode(PRODUCT_CODE);
		portalProduct.setProductName(PRODUCT_NAME);
		portalProduct.setInvestmentObjective(INVSTMNT_OBJ);

		currency.setCurrencyCode(CURRENCY_CODE);
		currency.setCurrencyId(Long.valueOf(1));
		currency.setCurrencyName("Australian Dollar123");

		investmentGroup.setInvestmentGroupCode("EIG");
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);

		portalProducts.add(portalProduct);

		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE)).thenReturn(this.portalProduct);
		when(utilities.generateDateFromString(portalProduct.getPerfInceptionDate(),
				RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT)).thenReturn(PERF_INCEPT_DATE);
		when(productPortalService.getProductCurrency(portalProduct, request)).thenReturn(currency);
		when(productPortalService.getInvestmentGroup(portalProduct, request)).thenReturn(investmentGroup);
	}

	@Given("^an active portfolio with the same portfolio code exists in the reporting table$")
	public void an_active_portfolio_with_the_same_portfolio_code_exists_in_the_reporting_table() throws Throwable {
		existingAccountFundRecord = new AccountFund();

		existingAccountFundRecord.setId(987654321L);
		existingAccountFundRecord.setPortfolioId(PRODUCT_CODE);
		existingAccountFundRecord.setAccountName("old account name");
		existingAccountFundRecord.setPortfolioManagerId(123L);
		existingAccountFundRecord.setPortfolioManager("old portfolio manager");
		existingAccountFundRecord.setPortfolioBaseCurrency("old base currency");
		existingAccountFundRecord.setInvestmentObjective("old objective");
		existingAccountFundRecord.setLastUpdatedUserId("old user");
		existingAccountFundRecord.setAccountType("old account type");
		existingAccountFundRecord.setAssetClassificationId(0L);
		existingAccountFundRecord.setProductEipID(999L);

		testAccountFundRepository.accountFundMap.put(PRODUCT_CODE, existingAccountFundRecord);

	}

	@When("^user runs the report service$")
	public void user_runs_the_report_service() throws Throwable {
		productDataService.moveProductPortalDataToReport(portalProduct, request, CURRENT_USERNAME);
	}

	@Then("^the table shall contain Investment Objective$")
	public void the_table_shall_contain_Investment_Objective() throws Throwable {
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
	}

	@Then("^the existing record in the report table is end dated$")
	public void theExistingRecordInTheReportTableIsEndDated() throws Throwable {
		assertNotNull(existingAccountFundRecord.getEffectiveEndDate());
	}

	@Then("^the new record is saved into the report table$")
	public void theNewRecordIsSavedIntoTheReportTable() throws Throwable {
		// check new record was added to table
		assertEquals(PRODUCT_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioId());
		assertEquals(PRODUCT_NAME, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(INVSTMNT_GRP_ID, testAccountFundRepository.accountFunds.get(0).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME, testAccountFundRepository.accountFunds.get(0).getPortfolioManager());
		assertEquals(CURRENCY_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(0).getInceptionDate());
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(0).getLastUpdatedUserId());
		assertEquals("TEST", testAccountFundRepository.accountFunds.get(0).getAccountType());
		assertEquals(Long.valueOf(3L), testAccountFundRepository.accountFunds.get(0).getAssetClassificationId());
	}
}


	PortfolioOverviewStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.when;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ProductDataServiceImpl;

import cucumber.api.DataTable;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class PortfolioOverviewStepDefs {
	
	private static final String CURRENT_USERNAME = "UXXX";
	private static final String DATE_STRING = "dd-MMM-yyyy";
	private static final DateFormat DATE_FORMAT = new SimpleDateFormat(DATE_STRING);
	private static final String CURRENCY_NAME = "Australian Dollar123";
	private static final String INVESTMENT_GROUP_CODE = "EIG";
	private static final int FIRST_RECORD = 0;
	private static final Long DEFAULT_LONG = Long.valueOf(1);
	private static final int DATA_ROW = 1;
	private static final String PRODUCT_CODE = "ONE90";
	private static final int PRODUCT_CODE_COL = 0;
	private static final int PORTFOLIO_MANAGER_COL = 1;
	private static final int INCEPTION_DATE_COL = 2;
	private static final int BENCHMARK_COL = 3;
	private static final int PORTFOLIO_CURRENCY_COL = 4;
	
	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();
	
	@InjectMocks
	private ProductDataServiceImpl productDataService;
	
	@Mock
	private Utilities utilities;
	
	private PortalProduct portalProduct;
	
	private List<PortalProduct> portalProducts;

	private Currency currency;

	private InvestmentGroup investmentGroup;
	
	private AccountFund existingAccountFund;
	private AccountSetup existingAccountSetup;
	private AccountBenchmarkAssociation existingAccountBenchmarkAssociation;
	
	@Given("^a portfolio with the following attributes which exists in Product Portal$")
	public void a_portfolio_with_the_following_attributes(DataTable table) throws Exception {
		MockitoAnnotations.initMocks(this);
		
		List<List<String>> data = table.raw();
		
		portalProducts = new ArrayList<>();
		portalProduct = new PortalProduct();
		currency = new Currency();
		investmentGroup = new InvestmentGroup();
		
		portalProduct.setBaseCurrencyID(DEFAULT_LONG);
		portalProduct.setBenchMarkName(data.get(DATA_ROW).get(BENCHMARK_COL));
		portalProduct.setPerfInceptionDate(data.get(DATA_ROW).get(INCEPTION_DATE_COL));
		portalProduct.setProductCode(data.get(DATA_ROW).get(PRODUCT_CODE_COL));
		
		currency.setCurrencyId(DEFAULT_LONG);
		currency.setCurrencyCode(data.get(DATA_ROW).get(PORTFOLIO_CURRENCY_COL));
		currency.setCurrencyName(CURRENCY_NAME);

		investmentGroup.setInvestmentGroupId(DEFAULT_LONG);
		investmentGroup.setInvestmentGroupCode(INVESTMENT_GROUP_CODE);
		investmentGroup.setInvestmentGroupName(data.get(DATA_ROW).get(PORTFOLIO_MANAGER_COL));
		
		portalProducts.add(portalProduct);
		
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		when(productPortalService.getProduct(portalProducts, portalProduct.getProductCode())).thenReturn(this.portalProduct);
		when(utilities.generateDateFromString(portalProduct.getPerfInceptionDate(), DATE_STRING)).thenReturn(DATE_FORMAT.parse(portalProduct.getPerfInceptionDate()));
		when(productPortalService.getProductCurrency(portalProduct, request)).thenReturn(currency);
		when(productPortalService.getInvestmentGroup(portalProduct, request)).thenReturn(investmentGroup);
	}
	
	@Given("^an active portfolio with the same product code exists in the report table$")
	public void anActivePortfolioWithTheSameProductCodeExistsInTheReportTable() throws Throwable {
		
		existingAccountFund = new AccountFund();
		existingAccountFund.setId(987654321L);
		existingAccountFund.setPortfolioId(PRODUCT_CODE);
		existingAccountFund.setAccountName("old account name");
		existingAccountFund.setPortfolioManagerId(123L);
		existingAccountFund.setPortfolioManager("old portfolio manager");
		existingAccountFund.setPortfolioBaseCurrency("old base currency");
		existingAccountFund.setInvestmentObjective("old objective");
		existingAccountFund.setLastUpdatedUserId("old user");
		existingAccountFund.setAccountType("old account type");
		existingAccountFund.setAssetClassificationId(0L);
		existingAccountFund.setProductEipID(999L);
		
		existingAccountSetup = new AccountSetup();
		existingAccountSetup.setId(345698345L);
		existingAccountSetup.setPortfolioId(PRODUCT_CODE);
		existingAccountSetup.setAccountClientName("old client name");
		existingAccountSetup.setLastUpdatedUserId("old user");
		existingAccountSetup.setStatusCode("old status code");
		
		existingAccountBenchmarkAssociation = new AccountBenchmarkAssociation();
		existingAccountBenchmarkAssociation.setId(1234876541L);
		existingAccountBenchmarkAssociation.setPortfolioId(PRODUCT_CODE);
		existingAccountBenchmarkAssociation.setBenchmarkName("old benchmark name");
		existingAccountBenchmarkAssociation.setLastUpdatedUserId("old user");
		
		testAccountFundRepository.accountFundMap.put(PRODUCT_CODE, existingAccountFund);
		testAccountSetupRepository.accountSetupMap.put(PRODUCT_CODE, existingAccountSetup);
		testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationMap.put(PRODUCT_CODE, existingAccountBenchmarkAssociation);
	}
	
	@When("^report service is run by user$")
	public void report_service_is_run_by_user_for_TEMP() {
		productDataService.moveProductPortalDataToReport(portalProduct, request, CURRENT_USERNAME);
	}
	
	@Then("^the existing records in the report table are end dated$")
	public void the_existing_records_in_the_report_table_are_end_dated() throws Throwable {
		assertNotNull(existingAccountFund.getEffectiveEndDate());
		assertNotNull(existingAccountBenchmarkAssociation.getEffectiveEndDate());
	}
	
	@Then("^the table shall contain the following information$")
	public void the_table_shall_contain_the_following_information(DataTable table) throws Exception{
		List<List<String>> data = table.raw();
		
		Date inceptionDate = DATE_FORMAT.parse(data.get(DATA_ROW).get(INCEPTION_DATE_COL));

		assertEquals(data.get(DATA_ROW).get(PORTFOLIO_MANAGER_COL),testAccountFundRepository.accountFunds.get(FIRST_RECORD).getPortfolioManager());
		assertEquals(inceptionDate,testAccountFundRepository.accountFunds.get(FIRST_RECORD).getInceptionDate());
		assertEquals(data.get(DATA_ROW).get(BENCHMARK_COL),testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(FIRST_RECORD).getBenchmarkName());
		assertEquals(data.get(DATA_ROW).get(PORTFOLIO_CURRENCY_COL),testAccountFundRepository.accountFunds.get(FIRST_RECORD).getPortfolioBaseCurrency());
	}
}

	ReportHeaderStepDefs.java

/*
****************************************************************************
*
* Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
* All rights reserved.
*
* This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
* distribution, adaptation, or use may be subject to civil and criminal
* penalties.
*
****************************************************************************
Module Description:

$HeadURL:$
$LastChangedRevision:$
$Author:$
$LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ProductDataServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class ReportHeaderStepDefs {

	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String CURRENCY_CODE = "AUD";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final String BENCHMARK_NAME = "test";

	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();

	@InjectMocks
	private ProductDataServiceImpl productDataService;

	@Mock
	private Utilities utilities;

	private PortalProduct portalProduct;

	private Currency currency;

	private InvestmentGroup investmentGroup;

	private List<PortalProduct> portalProducts;
	
	private AccountFund existingAccountFund;
	private AccountSetup existingAccountSetup;
	private AccountBenchmarkAssociation existingAccountBenchmarkAssociation;

	@Given("^a portfolio with (.*) that has (.*) and (.*) which exists in Product Portal$")
	public void a_portfolio_with_that_has_and_which_exists_in_Product_Portal(String productCode, String clientName,
			String mandateName) throws Throwable {
		MockitoAnnotations.initMocks(this);
		portalProducts = new ArrayList<>();
		portalProduct = new PortalProduct();
		currency = new Currency();
		investmentGroup = new InvestmentGroup();

		portalProduct.setBaseCurrencyID(Long.valueOf(1));
		portalProduct.setBenchMarkName(BENCHMARK_NAME);
		portalProduct.setClientID(clientName);
		portalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct.setProductCode(productCode);
		portalProduct.setProductName(mandateName);
		portalProduct.setInvestmentObjective(INVSTMNT_OBJ);

		currency.setCurrencyCode(CURRENCY_CODE);
		currency.setCurrencyId(Long.valueOf(1));
		currency.setCurrencyName("Australian Dollar123");

		investmentGroup.setInvestmentGroupCode("EIG");
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);

		portalProducts.add(portalProduct);

		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		when(productPortalService.getProduct(portalProducts, productCode)).thenReturn(this.portalProduct);
		when(utilities.generateDateFromString(portalProduct.getPerfInceptionDate(),
				RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT)).thenReturn(PERF_INCEPT_DATE);
		when(productPortalService.getProductCurrency(portalProduct, request)).thenReturn(currency);
		when(productPortalService.getInvestmentGroup(portalProduct, request)).thenReturn(investmentGroup);
	}
	
	@Given("^an active portfolio with the same (.*) product code exists in the reporting table$")
	public void an_active_portfolio_with_the_same_product_code_exists_in_the_reporting_table(String productCode) throws Throwable {
		existingAccountFund = new AccountFund();
		existingAccountFund.setId(987654321L);
		existingAccountFund.setPortfolioId(productCode);
		existingAccountFund.setAccountName("old account name");
		existingAccountFund.setPortfolioManagerId(123L);
		existingAccountFund.setPortfolioManager("old portfolio manager");
		existingAccountFund.setPortfolioBaseCurrency("old base currency");
		existingAccountFund.setInvestmentObjective("old objective");
		existingAccountFund.setLastUpdatedUserId("old user");
		existingAccountFund.setAccountType("old account type");
		existingAccountFund.setAssetClassificationId(0L);
		existingAccountFund.setProductEipID(999L);
		
		existingAccountSetup = new AccountSetup();
		existingAccountSetup.setId(345698345L);
		existingAccountSetup.setPortfolioId(productCode);
		existingAccountSetup.setAccountClientName("old client name");
		existingAccountSetup.setLastUpdatedUserId("old user");
		existingAccountSetup.setStatusCode("old status code");
		
		existingAccountBenchmarkAssociation = new AccountBenchmarkAssociation();
		existingAccountBenchmarkAssociation.setId(1234876541L);
		existingAccountBenchmarkAssociation.setPortfolioId(productCode);
		existingAccountBenchmarkAssociation.setBenchmarkName("old benchmark name");
		existingAccountBenchmarkAssociation.setLastUpdatedUserId("old user");
		
		testAccountFundRepository.accountFundMap.put(productCode, existingAccountFund);
		testAccountSetupRepository.accountSetupMap.put(productCode, existingAccountSetup);
		testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationMap.put(productCode, existingAccountBenchmarkAssociation);
	}

	@When("^report service is run by user for (.*)$")
	public void report_service_is_run_by_user(String productCode) throws Throwable {
		productDataService.moveProductPortalDataToReport(portalProduct, request, CURRENT_USERNAME);
	}
	
	@Then("^the existing records in the report tables are end dated$")
	public void the_existing_records_in_the_report_tables_are_end_dated() throws Throwable {
	    assertNotNull(existingAccountSetup.getEffectiveEndDate());
	    assertNotNull(existingAccountFund.getEffectiveEndDate());
	}


	@Then("^the table shall contain (.*) and (.*) for (.*)$")
	public void the_table_shall_contain(String clientName, String mandateName, String productCode)
			throws Throwable {
		assertEquals(clientName, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(mandateName, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(productCode, testAccountFundRepository.accountFunds.get(0).getPortfolioId());
	}
}


	ValuationsStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.dao.target.ValuationsTargetDAO;
import com.vanguard.corp.ics.repository.target.ValuationsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestValuationReportRepository;
import com.vanguard.corp.ics.sdt.service.api.constants.SecurityTypeCode;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ValuationsServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class ValuationsStepDefs {

	@InjectMocks
	ValuationsServiceImpl valService = new ValuationsServiceImpl();
	
	@Spy
	TestValuationReportRepository valuationsReportRepository = new TestValuationReportRepository();
	
	@Mock
	ValuationsRepository valuationsTargetRepository;
	
	@Mock
	Utilities utilities;
	
	private ValuationsTargetDAO valTargetDAO;
	private ValuationsReport valReportRecord1;
	private ValuationsReport valReportRecord2; 
	private ValuationsReport valReportRecord3;
	private ValuationsReport valReportRecord4;
	private ValuationsReport valReportRecord5;
	private ValuationsReport valReportRecord6;
	private DateFormat df = new SimpleDateFormat("dd-MMM-yy");
	private String userId = "UABC";
	
	@Given("^a portfolio with (.*) with (.*)$")
	public void a_portfolio_with_Equity_with_and(String assetType, BigDecimal currentMonthSource) throws Throwable {
		MockitoAnnotations.initMocks(this);
		valTargetDAO = new ValuationsTargetDAO();
		
		valTargetDAO.setId(Long.valueOf(1));
		valTargetDAO.setEquityValue(BigDecimal.valueOf(0.0));
		valTargetDAO.setDerivitivesValue(BigDecimal.valueOf(0.0));
		valTargetDAO.setLiquidityValue(BigDecimal.valueOf(0.0));
		valTargetDAO.setFixedInterestValue(BigDecimal.valueOf(0.0));
		valTargetDAO.setForwardForiegnExchangeValue(BigDecimal.valueOf(0.0));
		valTargetDAO.setFuturesValue(BigDecimal.valueOf(0.0));
		valTargetDAO.setTotalValue(currentMonthSource);
		valTargetDAO.setPortfolioCode("TEST");
		valTargetDAO.setValueDate(df.parse("31-jul-17"));
		
		switch(assetType){
			case "Equity" : 
				valTargetDAO.setEquityValue(currentMonthSource);
				
				break;
				
			case "Liquidity" : 
				valTargetDAO.setLiquidityValue(currentMonthSource);
				
				break;
				
			case "Futures Exposure" :
				valTargetDAO.setFuturesValue(currentMonthSource);
				
				break;
				
			case "Derivitives" : 
				valTargetDAO.setDerivitivesValue(currentMonthSource);
				
				break;
				
			case "Securities" : 
				valTargetDAO.setFixedInterestValue(currentMonthSource);
				
				break;
			
			case "FFX" :
				valTargetDAO.setForwardForiegnExchangeValue(currentMonthSource);
				
		}
		
		List<ValuationsTargetDAO> valTargetRecords = new ArrayList<ValuationsTargetDAO>();
		
		valTargetRecords.add(valTargetDAO);
		
		when(utilities.getPreviousMonthEnd(df.parse("31-jul-17"))).thenReturn(df.parse("30-jun-17"));
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetDAO.getValueDate(), "TEST")).thenReturn(valTargetDAO);
		
	}
	
	
	@Given("^a portfolio with multiple asset types$")
	public void a_portfolio_with_multiple_asset_types() throws Throwable {
		MockitoAnnotations.initMocks(this);
		valTargetDAO = new ValuationsTargetDAO();
		
		valTargetDAO.setId(Long.valueOf(3));
		valTargetDAO.setEquityValue(BigDecimal.valueOf(100.0));
		valTargetDAO.setDerivitivesValue(BigDecimal.valueOf(100.0));
		valTargetDAO.setLiquidityValue(BigDecimal.valueOf(100.0));
		valTargetDAO.setFixedInterestValue(BigDecimal.valueOf(100.0));
		valTargetDAO.setForwardForiegnExchangeValue(BigDecimal.valueOf(100.0));
		valTargetDAO.setFuturesValue(BigDecimal.valueOf(100.0));
		BigDecimal totalValue = new BigDecimal(600.0); 
		valTargetDAO.setTotalValue(totalValue);
		valTargetDAO.setPortfolioCode("TEST");
		valTargetDAO.setValueDate(df.parse("31-jul-17"));
		
		List<ValuationsTargetDAO> valTargetRecords = new ArrayList<ValuationsTargetDAO>();
		
		valTargetRecords.add(valTargetDAO);
		
		when(utilities.getPreviousMonthEnd(df.parse("31-jul-17"))).thenReturn(df.parse("30-jun-17"));
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetDAO.getValueDate(), "TEST")).thenReturn(valTargetDAO);
	}
	
	@Given("^an active portfolio with the same portfolio code exists in the reporting database$")
	public void anActivePortfolioWithTheSamePortfolioCodeExistsInTheReportingDatabase() throws Throwable {
		valReportRecord1 = new ValuationsReport();
		valReportRecord2 = new ValuationsReport();
		valReportRecord3 = new ValuationsReport();
		valReportRecord4 = new ValuationsReport();
		valReportRecord5 = new ValuationsReport();
		valReportRecord6 = new ValuationsReport();
		
		valReportRecord1.setId(Long.valueOf(1));
		valReportRecord1.setPortfolioCode("TEST");
		valReportRecord1.setEffectiveDate(df.parse("30-Oct-17"));
		valReportRecord1.setSecurityTypeCode("EQUI");
		valReportRecord1.setValuationValue(BigDecimal.valueOf(100.0));
		valReportRecord1.setTotalValue(BigDecimal.valueOf(2100.0));
		valReportRecord1.setCreatedUser("UXXX");
		valReportRecord1.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord1.setLastUpdatedUserId("UYYY");
		valReportRecord1.setEffectiveEndDate(null);
		
		valReportRecord2.setId(Long.valueOf(2));
		valReportRecord2.setPortfolioCode("TEST");
		valReportRecord2.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord2.setSecurityTypeCode("FUTU");
		valReportRecord2.setValuationValue(BigDecimal.valueOf(200.0));
		valReportRecord2.setTotalValue(BigDecimal.valueOf(2100.0));
		valReportRecord2.setCreatedUser("UXXX");
		valReportRecord2.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord2.setLastUpdatedUserId("UYYY");
		valReportRecord2.setEffectiveEndDate(null);
		
		valReportRecord3.setId(Long.valueOf(3));
		valReportRecord3.setPortfolioCode("TEST");
		valReportRecord3.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord3.setSecurityTypeCode("SECU");
		valReportRecord3.setValuationValue(BigDecimal.valueOf(300.0));
		valReportRecord3.setTotalValue(BigDecimal.valueOf(2100.0));
		valReportRecord3.setCreatedUser("UXXX");
		valReportRecord3.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord3.setLastUpdatedUserId("UYYY");
		valReportRecord3.setEffectiveEndDate(null);
		
		valReportRecord4.setId(Long.valueOf(4));
		valReportRecord4.setPortfolioCode("TEST");
		valReportRecord4.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord4.setSecurityTypeCode("FWFX");
		valReportRecord4.setValuationValue(BigDecimal.valueOf(400.0));
		valReportRecord4.setTotalValue(BigDecimal.valueOf(2100.0));
		valReportRecord4.setCreatedUser("UXXX");
		valReportRecord4.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord4.setLastUpdatedUserId("UYYY");
		valReportRecord4.setEffectiveEndDate(null);
		
		valReportRecord5.setId(Long.valueOf(5));
		valReportRecord5.setPortfolioCode("TEST");
		valReportRecord5.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord5.setSecurityTypeCode("LIQU");
		valReportRecord5.setValuationValue(BigDecimal.valueOf(500.0));
		valReportRecord5.setTotalValue(BigDecimal.valueOf(2100.0));
		valReportRecord5.setCreatedUser("UXXX");
		valReportRecord5.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord5.setLastUpdatedUserId("UYYY");
		valReportRecord5.setEffectiveEndDate(null);
		
		valReportRecord6.setId(Long.valueOf(6));
		valReportRecord6.setPortfolioCode("TEST");
		valReportRecord6.setEffectiveDate(df.parse("31-jul-17"));
		valReportRecord6.setSecurityTypeCode("DERI");
		valReportRecord6.setValuationValue(BigDecimal.valueOf(600.0));
		valReportRecord6.setTotalValue(BigDecimal.valueOf(100.0));
		valReportRecord6.setCreatedUser("UXXX");
		valReportRecord6.setCreatedDate(df.parse("4-jul-17"));
		valReportRecord6.setLastUpdatedUserId("UYYY");
		valReportRecord6.setEffectiveEndDate(null);
		
		valuationsReportRepository.dataMap.put(
				valReportRecord1.getPortfolioCode() + valReportRecord1.getEffectiveDate().toString() + valReportRecord1.getSecurityTypeCode() + "Test1"
				, valReportRecord1);
		
		valuationsReportRepository.dataMap.put(
				valReportRecord2.getPortfolioCode() + valReportRecord2.getEffectiveDate().toString() + valReportRecord2.getSecurityTypeCode() + "Test2"
				, valReportRecord2);
		
		valuationsReportRepository.dataMap.put(
				valReportRecord3.getPortfolioCode() + valReportRecord3.getEffectiveDate().toString() + valReportRecord3.getSecurityTypeCode() + "Test3"
				, valReportRecord3);
		
		valuationsReportRepository.dataMap.put(
				valReportRecord4.getPortfolioCode() + valReportRecord4.getEffectiveDate().toString() + valReportRecord4.getSecurityTypeCode() + "Test4"
				, valReportRecord4);
		
		valuationsReportRepository.dataMap.put(
				valReportRecord5.getPortfolioCode() + valReportRecord5.getEffectiveDate().toString() + valReportRecord5.getSecurityTypeCode() + "Test5"
				, valReportRecord5);
		
		valuationsReportRepository.dataMap.put(
				valReportRecord6.getPortfolioCode() + valReportRecord6.getEffectiveDate().toString() + valReportRecord6.getSecurityTypeCode() + "Test6"
				, valReportRecord6);
		
		when(valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull("TEST", valReportRecord1.getSecurityTypeCode(), valTargetDAO.getValueDate()))
			.thenReturn(valReportRecord1);
		when(valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull("TEST", valReportRecord2.getSecurityTypeCode(), valTargetDAO.getValueDate()))
			.thenReturn(valReportRecord2);
		when(valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull("TEST", valReportRecord3.getSecurityTypeCode(), valTargetDAO.getValueDate()))
			.thenReturn(valReportRecord3);
		when(valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull("TEST", valReportRecord4.getSecurityTypeCode(), valTargetDAO.getValueDate()))
			.thenReturn(valReportRecord4);
		when(valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull("TEST", valReportRecord5.getSecurityTypeCode(), valTargetDAO.getValueDate()))
			.thenReturn(valReportRecord5);
		when(valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIsAndEffectiveEndDateIsNull("TEST", valReportRecord6.getSecurityTypeCode(), valTargetDAO.getValueDate()))
			.thenReturn(valReportRecord6);
		
	}

	@When("^user runs portfolio valuation calculations for June (\\d+)$")
	public void user_runs_portfolio_valuation_calculations(int year) throws Throwable {
		valService.moveValuationsFromTargetToReport("TEST", valTargetDAO.getValueDate(), userId);
	}
	
	@When("^user runs portfolio valuation calculations for current month$")
	public void userRunsPortfolioValuationCalculationsForCurrentMonth() throws Throwable {
		valService.moveValuationsFromTargetToReport("TEST", valTargetDAO.getValueDate(), userId);
	}
	
	@Then("^current month NAV value matches value for < current month report>$")
	public void current_month_NAV_value_matches_value_for_current_month_report() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			assertEquals(valTargetDAO.getTotalValue(), valuationsReportRepository.dataMap.get(valTargetDAO.getPortfolioCode() + valTargetDAO.getValueDate().toString() + value.getCode()).getTotalValue());	}
		}
		
	@Then("^current month total will be the sum of all current month assets$")
	public void current_month_total_will_be_Sum_of_all_current_month_assets() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			assertEquals(valTargetDAO.getTotalValue(), valuationsReportRepository.dataMap.get(valTargetDAO.getPortfolioCode() + valTargetDAO.getValueDate().toString() + value.getCode()).getTotalValue());	}
		}
	
	@Then("^the existing records are end dated$")
	public void theExistingRecordsAreEndDated() throws Throwable {
		assertNotNull(valuationsReportRepository.dataMap.get(valReportRecord1.getPortfolioCode() + valReportRecord1.getEffectiveDate().toString() + valReportRecord1.getSecurityTypeCode() + "Test1").getEffectiveEndDate());
		assertNotNull(valuationsReportRepository.dataMap.get(valReportRecord2.getPortfolioCode() + valReportRecord2.getEffectiveDate().toString() + valReportRecord2.getSecurityTypeCode() + "Test2").getEffectiveEndDate());
		assertNotNull(valuationsReportRepository.dataMap.get(valReportRecord3.getPortfolioCode() + valReportRecord3.getEffectiveDate().toString() + valReportRecord3.getSecurityTypeCode() + "Test3").getEffectiveEndDate());
		assertNotNull(valuationsReportRepository.dataMap.get(valReportRecord4.getPortfolioCode() + valReportRecord4.getEffectiveDate().toString() + valReportRecord4.getSecurityTypeCode() + "Test4").getEffectiveEndDate());
		assertNotNull(valuationsReportRepository.dataMap.get(valReportRecord5.getPortfolioCode() + valReportRecord5.getEffectiveDate().toString() + valReportRecord5.getSecurityTypeCode() + "Test5").getEffectiveEndDate());
		assertNotNull(valuationsReportRepository.dataMap.get(valReportRecord6.getPortfolioCode() + valReportRecord6.getEffectiveDate().toString() + valReportRecord6.getSecurityTypeCode() + "Test6").getEffectiveEndDate());
	}
	
	@Then("^the new records are saved into the database$")
	public void theNewRecordsAreSavedIntoTheDatabase() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			
			ValuationsReport valReportRecord = valuationsReportRepository.dataMap.get(valTargetDAO.getPortfolioCode() + valTargetDAO.getValueDate().toString() + value.getCode());
			
			switch(value){
				case DERIVATIVES :
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), valTargetDAO.getTotalValue());
					
					break;
				case EQUITY : 
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getValuationValue(), valTargetDAO.getEquityValue());
					assertEquals(valReportRecord.getTotalValue(), valTargetDAO.getTotalValue());
					
					break;
				case FUTURES : 
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), valTargetDAO.getTotalValue());
					
					break;
				case FORWARD_FOREX :
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), valTargetDAO.getTotalValue());
					
					break;
				case LIQUIDITY : 
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), valTargetDAO.getTotalValue());
					
					break;
				case FIXED_INTEREST :
					assertNull(valReportRecord.getEffectiveEndDate());
					assertEquals(valReportRecord.getTotalValue(), valTargetDAO.getTotalValue());
					
					break;
			}
		}
	}
}

com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e
	AttributionSummaryStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

/**
 * @author um2a
 *
 */
public class AttributionSummaryStepDefs {
	
	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");
	

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	
	@Given("^test attribution summary data are loaded into target tables$")
	public void testAttributionSummaryDataAreLoadedIntoTargetTables() throws Throwable {
		// no need for this (yet) as target table & repository are not complete
	}

	@When("^transfer of attribution summary data is requested$")
	public void transferOfAttributionSummaryDataIsRequested() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-07-31");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "TEST02");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.ATTRIBUTION_SUMMARY.toString());
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, "UABC");
		response = builder.get();
		// response.bufferEntity();
	    
	}

	@Then("^the system indicates successful completion of the attribution Summary transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheAttributionSummaryTransfer() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	    
	}

	@Then("^the test attribution summary data are saved in reporting tables$")
	public void theTestAttributionSummaryDataAreSavedInReportingTables() throws Throwable {
		// TODO figure out how to check database without exposing an endpoint to prod
	   
	}

	@Then("^the test attribution summary data are cleaned up from the target tables$")
	public void theTestAttributionSummaryDataAreCleanedUpFromTheTargetTables() throws Throwable {
		// not necessary at this time
	}

	@Then("^the test attribution summary data are cleaned up from the reporting tables$")
	public void theTestAttributionSummaryDataAreCleanedUpFromTheReportingTables() throws Throwable {
		// TODO figure out how to clean up without exposing an endpoint to prod
	}

}

	BrokerageAndTaxesStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class BrokerageAndTaxesStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}

	@Given("^test brokerage and taxes data are loaded into target tables$")
	public void test_brokerage_and_taxes_data_are_loaded_into_target_tables() throws Throwable {
		// no need for this (yet) as target table & repository are not complete
	}

	@When("^transfer of brokerage and taxes data is requested$")
	public void transfer_of_brokerage_and_taxes_data_is_requested() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-06-30");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "TEST01");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.BROKERAGE_TAXES.toString());
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, "UABC");
		response = builder.get();
	}

	@Then("^the system indicates successful completion of the brokerage and taxes transfer$")
	public void the_system_indicates_successful_completion_of_the_brokerage_and_taxes_transfer() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the test brokerage and taxes data are saved in reporting tables$")
	public void the_test_brokerage_and_taxes_data_are_saved_in_reporting_tables() throws Throwable {
		// TODO figure out how to check database without exposing an endpoint to prod
	}

	@Then("^the test brokerage and taxes data are cleaned up from the target tables$")
	public void the_test_brokerage_and_taxes_data_are_cleaned_up_from_the_target_tables() throws Throwable {
		// not necessary at this time
	}

	@Then("^the test brokerage and taxes data are cleaned up from the reporting tables$")
	public void the_test_brokerage_and_taxes_data_are_cleaned_up_from_the_reporting_tables() throws Throwable {
		// TODO figure out how to clean up without exposing an endpoint to prod
	}
}


	CharacteristicsStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CharacteristicsStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");
	private static final String TEST_DATE = "2017-09-30"; //"2016-12-30";
	private static final String TEST_PORT_ID = "ONE90";
	private static final String TEST_USER = "UABC";

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}

	@Given("^test characteristics data are loaded into target tables$")
	public void testCharacteristicsDataAreLoadedIntoTargetTables() throws Throwable {
		// no need for this (yet) as target table & repository are not complete
	}

	@When("^transfer of characteristics data is requested$")
	public void transferOfCharacteristicsDataIsRequested() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, TEST_DATE);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, TEST_PORT_ID);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.CHARACTERISTICS.toString());
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, TEST_USER);
		response = builder.get();
		// response.bufferEntity();
	}

	@Then("^the system indicates successful completion of the characteristics transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheCharacteristicsTransfer() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the test characteristics data are saved in reporting tables$")
	public void theTestCharactersisticsDataAreSavedInReportingTables() throws Throwable {
		// TODO figure out how to check database without exposing an endpoint to prod
	}

	@Then("^the test characteristics data are cleaned up from the target tables$")
	public void theTestCharacteristicsDataAreCleanedUpFromTheTargetTables() throws Throwable {
		// not necessary at this time
	}

	@Then("^the test characteristics data are cleaned up from the reporting tables$")
	public void theTestCharacteristicsDataAreCleanedUpFromTheReportingTables() throws Throwable {
		// TODO figure out how to clean up without exposing an endpoint to prod
	}
}


	CommentaryStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryResource;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CommentaryStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	@Given("^a mandate exists in the product portal$")
	public void a_mandate_exists_in_the_product_portal() throws Throwable {
	    // Not sure we need this yet
	}
	
	@Given("^a commentary entry exists for a mandate on a specified date$")
	public void a_commentary_entry_exists_for_a_mandate_on_a_specified_date() throws Throwable {
	   // Table doesn't exist yet.  Update when it does.
	}

	@When("^commentary is added for a mandate on a specified date$")
	public void commentary_is_added_for_that_mandate_on_a_specified_date() throws Throwable {
		CommentaryDTO commentary = new CommentaryDTO();
		
		commentary.setAsOfDate("2016-03-31");
		commentary.setPortId("TEST01");
		commentary.setCommentary("Here is a short commentary");
		
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(CommentaryResource.PATH);
		response = webTarget.request().post(Entity.json(commentary));
	}

	@When("^commentary is requested for a manadate on a specified date$")
	public void commentary_is_requested_for_that_manadate_on_a_specified_date() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2016-03-31");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "TEST01");
		response = webTarget.request().get();
	}

	@Then("^the system indicates successful completion of the commentary entry$")
	public void the_system_indicates_successful_completion_of_the_commentary_entry() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the system indicates successful completion of the commentary update$")
	public void the_system_indicates_successful_completion_of_the_commentary_update() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the system indicates successful completion of the commentary retrieval$")
	public void the_system_indicates_successful_completion_of_the_commentary_retrieval() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}
}


	PerformanceSummaryStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class PerformanceSummaryStepDefs {
	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");
	

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	@Given("^test performance summary data are loaded into target tables$")
	public void testPerformanceSummaryDataAreLoadedIntoTargetTables() throws Throwable {
		// no need for this (yet) as target table & repository are not complete
	}

	@When("^transfer of performance summary data is requested$")
	public void transferOfPerformanceSummaryDataIsRequested() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-07-31");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "SUQN");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.PERFORMANCE_SUMMARY.toString());
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, "UABC");
		response = builder.get();
	}

	@Then("^the system indicates successful completion of the performance summary transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfThePerformanceSummaryTransfer() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the test performance summary data are saved in reporting tables$")
	public void theTestPerformanceSummaryDataAreSavedInReportingTables() throws Throwable {
		// TODO figure out how to check database without exposing an endpoint to prod
	}

	@Then("^the test performance summary data are cleaned up from the target tables$")
	public void theTestPerformanceSummaryDataAreCleanedUpFromTheTargetTables() throws Throwable {
		// not necessary at this time
	}

	@Then("^the test performance summary data are cleaned up from the reporting tables$")
	public void theTestPerformanceSummaryDataAreCleanedUpFromTheReportingTables() throws Throwable {
		// TODO figure out how to clean up without exposing an endpoint to prod
	}
}


	SecurityStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.Response;

import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.PendingException;
import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class SecurityStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	@Given("^test data are loaded into target tables$")
	public void testDataAreLoadedIntoTargetTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Given("^a user with valid permission to request transfer of data$")
	public void aUserWithValidPermissionToRequestTransferOfData() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Given("^a user without valid permission to request transfer of data$")
	public void aUserWithoutValidPermissionToRequestTransferOfData() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@When("^transfer of data is requested$")
	public void transferOfDataIsRequested() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the system indicates successful completion of the transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheTransfer() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the system indicates failure due to no permission$")
	public void theSystemIndicatesFailureDueToNoPermission() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are saved in reporting tables$")
	public void theTestDataAreSavedInReportingTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are not saved in reporting tables$")
	public void theTestDataAreNotSavedInReportingTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are cleaned up from the target tables$")
	public void theTestDataAreCleanedUpFromTheTargetTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are cleaned up from the reporting tables$")
	public void theTestDataAreCleanedUpFromTheReportingTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
}


	ValuationsStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class ValuationsStepDefs {
	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");
	

	private Client client = null;
	private Response response;
	private static final String TEST_USER = "UABC";

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	@Given("^test valuations data is loaded into target tables$")
	public void testValuationsDataIsLoadedIntoTargetTables() throws Throwable{
		//not setting this yet to stay uniform with other E2E tests
	}
	
	@When("^transfer of valuations data is requested")
	public void transferOfValuationsDataIsRequested() throws Throwable{
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-07-31");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "ONE88");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.VALUATIONS.toString());
		Builder builder = webTarget.request();
		builder = builder.header(DataTransferParameters.PARM_UID, TEST_USER);
		response = builder.get();
	}
	
	@Then("^the system indicates successful completion of the valuations transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheValuationsTransfer() throws Throwable{
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}
	
	@Then("^the test valuations data is saved in reporting tables")
	public void theTestValuationsDataIsSavedInReportingTables() throws Throwable{
		// TODO figure out how to check database without exposing an endpoint to prod
	}
}


com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration
	AttributionSummaryStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.inject.Inject;

import org.powermock.reflect.Whitebox;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.corp.ics.repository.target.AttributionSummaryTargetRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AttributionSummaryRepository;
import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.impl.DataTransferServiceImpl;
import com.vanguard.corp.ics.sdt.service.impl.attributionsummary.AttributionSummaryConverter;
import com.vanguard.corp.ics.sdt.service.impl.attributionsummary.AttributionSummaryTransferService;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.AttributionSummaryIntegrationData;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class AttributionSummaryStepDefs {
	private static final String DATE_FORMAT = "yyyy-MM-dd";
	private static final String AS_OF_DATE_1 = "2016-01-31";
	private static final String AS_OF_DATE_2 = "2016-02-29";
	private static final String PORT_ID_1 = "TEST01";
	private static final String PORT_ID_2 = "TEST02";
	private static final String CALLED_BY_USER_ID = "UXYZ";

	@Inject
	private AttributionSummaryIntegrationData attributionSummaryIntegrationData;
	private List<AttributionTargetDAO> retrievableTargetAttributionSummaries;
	private String targetPortId;
	private CheckableAttributionSummaryServiceWrapper checkableWrapper;

	@Before
	public void setup() {
		attributionSummaryIntegrationData.setAvailableTargetAttributionSummaries(new ArrayList<>());
		attributionSummaryIntegrationData.setSavedAttributionSummaries(null);
		attributionSummaryIntegrationData.setEffectiveDate(null);
		retrievableTargetAttributionSummaries = new ArrayList<>();
		targetPortId = null;
		checkableWrapper = null;
	}

	@Given("^target tables contain attribution summary data for multiple port ids and multiple effective dates$")
	public void testAttributionSummaryDataAreLoadedIntoTargetTables() throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		Date validAsOfDate = new Date();
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO attributionSummaryTargetDAO = new AttributionTargetDAO();
		attributionSummaryTargetDAO.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		attributionSummaryTargetDAO.setPortfolioCode(PORT_ID_1);
		attributionSummaryTargetDAO.setAttrtnName("Stock Selection Impact");
		attributionSummaryTargetDAO.setAttrtnTypeCd("3MON");
		attributionSummaryTargetDAO.setAttrtnTypeVal(BigDecimal.valueOf(1));
		attributionSummaryTargetDAO.setCreatedUser("FAKE");
		attributionSummaryTargetDAO.setDatasourceFileDAO(datasourceFileDAO);
		attributionSummaryTargetDAO.setCreatedDate(validAsOfDate);
		attributionSummaryTargetDAO.setUpdatedUser("ABCD");
		attributionSummaryTargetDAO.setUpdatedDate(validAsOfDate);
		attributionSummaryIntegrationData.getAvailableTargetAttributionSummaries().add(attributionSummaryTargetDAO);
		AttributionTargetDAO attributionSummaryTargetDAO1 = new AttributionTargetDAO();
		attributionSummaryTargetDAO1.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		attributionSummaryTargetDAO1.setPortfolioCode(PORT_ID_2);
		attributionSummaryTargetDAO1.setAttrtnName("Stock Selection Impact");
		attributionSummaryTargetDAO1.setDatasourceFileDAO(datasourceFileDAO);
		attributionSummaryTargetDAO1.setAttrtnTypeCd("3MON");
		attributionSummaryTargetDAO1.setAttrtnTypeVal(BigDecimal.valueOf(10));
		attributionSummaryTargetDAO1.setCreatedUser("FAKE1");
		attributionSummaryTargetDAO1.setCreatedDate(validAsOfDate);
		attributionSummaryTargetDAO.setUpdatedUser("ABCD");
		attributionSummaryTargetDAO.setUpdatedDate(validAsOfDate);
		attributionSummaryIntegrationData.getAvailableTargetAttributionSummaries().add(attributionSummaryTargetDAO1);
	}

	@Given("^target tables contain attribution summary data with name \"([^\"]*)\"$")
	public void targetTablesContainAttributionSummaryDataWithName(String name) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		Date validAsOfDate = new Date();
		DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
		datasourceFileDAO.setId(660L);
		AttributionTargetDAO attributionSummaryTargetDAO = new AttributionTargetDAO();
		attributionSummaryTargetDAO.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		attributionSummaryTargetDAO.setPortfolioCode(PORT_ID_1);
		attributionSummaryTargetDAO.setAttrtnName(name);
		attributionSummaryTargetDAO.setAttrtnTypeCd("1MON");
		attributionSummaryTargetDAO.setDatasourceFileDAO(datasourceFileDAO);
		attributionSummaryTargetDAO.setAttrtnTypeVal(BigDecimal.valueOf(1));
		attributionSummaryTargetDAO.setCreatedUser("FAKE");
		attributionSummaryTargetDAO.setCreatedDate(validAsOfDate);
		attributionSummaryTargetDAO.setUpdatedUser("ABCD");
		attributionSummaryTargetDAO.setUpdatedDate(validAsOfDate);
		attributionSummaryIntegrationData.getAvailableTargetAttributionSummaries().add(attributionSummaryTargetDAO);
		AttributionTargetDAO attributionSummaryTargetDAO1 = new AttributionTargetDAO();
		attributionSummaryTargetDAO1.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		attributionSummaryTargetDAO1.setPortfolioCode(PORT_ID_2);
		attributionSummaryTargetDAO1.setAttrtnName(name);
		attributionSummaryTargetDAO1.setAttrtnTypeCd("3MON");
		attributionSummaryTargetDAO.setDatasourceFileDAO(datasourceFileDAO);
		attributionSummaryTargetDAO1.setAttrtnTypeVal(BigDecimal.valueOf(1));
		attributionSummaryTargetDAO1.setCreatedUser("FAKE");
		attributionSummaryTargetDAO1.setCreatedDate(validAsOfDate);
		attributionSummaryTargetDAO.setUpdatedUser("ABCD");
		attributionSummaryTargetDAO.setUpdatedDate(validAsOfDate);
		attributionSummaryIntegrationData.getAvailableTargetAttributionSummaries().add(attributionSummaryTargetDAO1);
	}

	@Given("^target tables contain no attribution summary data$")
	public void targetTablesContainNoAttributionSummaryData() throws Throwable {
		// no AttributionSummary added to availableTargetAttributionSummary
	}

	@Given("^one of the included effective dates is targeted$")
	public void oneOfTheIncludedAsOfDatesIsTargeted() throws Throwable {
		// attributionSummaryIntegrationData.setEffectiveDate((new
		// Random()).nextBoolean() ? AS_OF_DATE_1 : AS_OF_DATE_2);
		attributionSummaryIntegrationData.setEffectiveDate(AS_OF_DATE_1);
	}

	@Given("^one of the included attribution summary port ids is targeted$")
	public void oneOfTheIncludedPortIdsIsTargeted() throws Throwable {
		targetPortId = (new Random()).nextBoolean() ? PORT_ID_1 : PORT_ID_2;
	}

	@Given("^an effective date is targeted anyway$")
	public void anAsOfDatesIsTargetedAnyway() throws Throwable {
		attributionSummaryIntegrationData.setEffectiveDate((new Random()).nextBoolean() ? AS_OF_DATE_1 : AS_OF_DATE_2);
	}

	@When("^attribution summary data are transferred$")
	public void transferOfAttributionSummaryDataIsRequested() throws Throwable {
		SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		Date targetDate = formatter.parse(attributionSummaryIntegrationData.getEffectiveDate());

		for (AttributionTargetDAO targetDao : attributionSummaryIntegrationData
				.getAvailableTargetAttributionSummaries()) {
			if (targetDao.getEffectiveDate().equals(targetDate)
					&& (targetPortId == null || targetDao.getPortfolioCode().equals(targetPortId))) {
				retrievableTargetAttributionSummaries.add(targetDao);
			}
		}

		final DataTransferParameters parms = new DataTransferParameters();
		parms.setAsOfDate(attributionSummaryIntegrationData.getEffectiveDate());
		parms.setPortId(targetPortId);
		parms.setUid(CALLED_BY_USER_ID);

		final DataTransferResource resource = buildDataTransferResource();
		resource.transfer(parms);

		assertNotNull("checkableWrapper is null", checkableWrapper);
		attributionSummaryIntegrationData.setSavedAttributionSummaries(checkableWrapper.getSavedAttributionSummaries());
	}

	@Then("^the attribution summary data for the targeted effective dates are saved to reporting tables$")
	public void thePortfolioAttributionSummaryDataForTheTargetedAsOfDateAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedAttributionSummary is null",
				attributionSummaryIntegrationData.getAvailableTargetAttributionSummaries());

		int foundCount = 0;
		for (AttributionTargetDAO dao : retrievableTargetAttributionSummaries) {
			for (AttributionSummary attributionSummary : attributionSummaryIntegrationData
					.getSavedAttributionSummaries()) {
				if (dao.getEffectiveDate().equals(attributionSummary.getEffectiveDate())
						&& dao.getAttrtnName().equals(attributionSummary.getName())
						&& dao.getAttrtnTypeVal().equals(attributionSummary.getThreeMonthVal())
						&& dao.getPortfolioCode().equals(attributionSummary.getPortId())) {
					foundCount++;
					break;
				}
			}
		}

		assertEquals(1, foundCount);
	}

	@Then("^the attribution summary data for the targeted port id and effective dates are saved to reporting tables$")
	public void thePortfolioAttributionSummaryDataForTheTargetedAsOfDateAndPortIdAreSavedToReportingTables()
			throws Throwable {
		assertNotNull("savedAttributionSummary is null",
				attributionSummaryIntegrationData.getAvailableTargetAttributionSummaries());

		int foundCount = 0;
		for (AttributionTargetDAO dao : retrievableTargetAttributionSummaries) {
			for (AttributionSummary fake : attributionSummaryIntegrationData.getSavedAttributionSummaries()) {
				if (dao.getEffectiveDate().equals(fake.getEffectiveDate()) && dao.getAttrtnName().equals(fake.getName())
						&& dao.getAttrtnTypeVal().equals(fake.getThreeMonthVal())
						&& dao.getPortfolioCode().equals(fake.getPortId())) {
					foundCount++;
					break;
				}
			}
		}

		assertEquals(retrievableTargetAttributionSummaries.size(), foundCount);
	}

	@Then("^no attribution summary data for other effective dates are saved to reporting tables$")
	public void theTestAttributionSummaryDataForTheTargetedAsOfDateAreSavedInReportingTables() throws Throwable {
		// yeah, already did that above
	}

	@Then("^no attribution summary data for other port ids or effective dates are saved to reporting tables$")
	public void theTestAttributionSummaryDataForTheTargetedAsOfDateAndPortIdAreSavedInReportingTables()
			throws Throwable {
		// yeah, already did that above
	}

	@Then("^the saved attribution summary data exactly match the source data$")
	public void theTestAttributionSummaryDataAreCleanedUpFromTheTargetTables() throws Throwable {
		assertNotNull("savedAttributionSummary is null",
				attributionSummaryIntegrationData.getSavedAttributionSummaries());
		assertEquals(retrievableTargetAttributionSummaries.size(),
				attributionSummaryIntegrationData.getSavedAttributionSummaries().size());
	}

	@Then("^no attribution summary data are saved to reporting tables$")
	public void noPortfolioAttributionSummaryDataAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedAttributionSummary is null",
				attributionSummaryIntegrationData.getSavedAttributionSummaries());
		assertEquals(retrievableTargetAttributionSummaries.size(),
				attributionSummaryIntegrationData.getSavedAttributionSummaries().size());
	}

	@Then("^attribution summary data with name \"([^\"]*)\" are saved to reporting tables$")
	public void portfolioAttributionSummaryDataWithNameAreSavedToReportingTables(String name) throws Throwable {
		boolean found = false;
		for (AttributionSummary attributionSummary : attributionSummaryIntegrationData.getSavedAttributionSummaries()) {
			if (attributionSummary.getName().equals(name)) {
				found = true;
				break;
			}
		}
		assertTrue(found);
	}

	private DataTransferResource buildDataTransferResource() {
		final DataTransferResource resource = new DataTransferResource();
		Whitebox.setInternalState(resource, DataTransferService.class, buildDataTransferService());
		return resource;
	}

	private DataTransferService buildDataTransferService() {
		final DataTransferService service = new DataTransferServiceImpl();
		List<TransferService> services = new ArrayList<>();
		services.add(buildAttributionSummaryTransferHandler());
		Whitebox.setInternalState(service, "services", services);
		return service;
	}

	private TransferService buildAttributionSummaryTransferHandler() {
		final TransferService handler = new AttributionSummaryTransferService();
		Whitebox.setInternalState(handler, AttributionSummaryTargetRepository.class,
				buildReadAttributionSummaryRepository());
		Whitebox.setInternalState(handler, "dataConverter", buildAttributionSummaryConverter());
		Whitebox.setInternalState(handler, AttributionSummaryRepository.class,
				buildAttributionSummaryTransferSummaryJpa());
		return handler;
	}

	private AttributionSummaryTargetRepository buildReadAttributionSummaryRepository() {
		final AttributionSummaryTargetRepository targetRepo = new AttributionSummaryTargetRepository() {

			private final List<AttributionTargetDAO> retrievable = retrievableTargetAttributionSummaries;

			@Override
			public List<AttributionTargetDAO> findAllByEffectiveDateAndPortfolioCode(Date effectiveDate,
					String portId) {
				return retrievable;
			}

			@Override
			public List<AttributionTargetDAO> findAllByEffectiveDate(Date effectiveDate) {
				return retrievable;
			}

			@Override
			public List<AttributionTargetDAO> findAll() {
				return null;
			}

			@Override
			public List<AttributionTargetDAO> findAll(Sort sort) {
				return null;
			}

			@Override
			public List<AttributionTargetDAO> findAll(Iterable<Long> ids) {
				return null;
			}

			@Override
			public <S extends AttributionTargetDAO> List<S> save(Iterable<S> entities) {
				return null;
			}

			@Override
			public void flush() {

			}

			@Override
			public <S extends AttributionTargetDAO> S saveAndFlush(S entity) {
				return null;
			}

			@Override
			public void deleteInBatch(Iterable<AttributionTargetDAO> entities) {
			}

			@Override
			public void deleteAllInBatch() {
			}

			@Override
			public AttributionTargetDAO getOne(Long id) {
				return null;
			}

			@Override
			public Page<AttributionTargetDAO> findAll(Pageable arg0) {
				return null;
			}

			@Override
			public long count() {
				return 0;
			}

			@Override
			public void delete(Long arg0) {
			}

			@Override
			public void delete(AttributionTargetDAO arg0) {
			}

			@Override
			public void delete(Iterable<? extends AttributionTargetDAO> arg0) {
			}

			@Override
			public void deleteAll() {
			}

			@Override
			public boolean exists(Long arg0) {
				return false;
			}

			@Override
			public AttributionTargetDAO findOne(Long arg0) {
				return null;
			}

			@Override
			public <S extends AttributionTargetDAO> S save(S arg0) {
				return null;
			}
		};
		return targetRepo;
	}

	private Object buildAttributionSummaryConverter() {
		return new AttributionSummaryConverter();
	}

	private static interface CheckableAttributionSummaryServiceWrapper extends AttributionSummaryRepository {

		List<AttributionSummary> getSavedAttributionSummaries();
	}

	private CheckableAttributionSummaryServiceWrapper buildAttributionSummaryTransferSummaryJpa() {
		final CheckableAttributionSummaryServiceWrapper repo = new CheckableAttributionSummaryServiceWrapper() {
			private final List<AttributionSummary> saved = new ArrayList<>();

			@Override
			public <S extends AttributionSummary> S save(S arg0) {
				return arg0;
			}

			@Override
			public AttributionSummary findOne(Long arg0) {
				return null;
			}

			@Override
			public boolean exists(Long arg0) {
				return false;
			}

			@Override
			public void deleteAll() {

			}

			@Override
			public void delete(Iterable<? extends AttributionSummary> arg0) {

			}

			@Override
			public void delete(AttributionSummary arg0) {

			}

			@Override
			public void delete(Long arg0) {

			}

			@Override
			public long count() {
				return 0;
			}

			@Override
			public Page<AttributionSummary> findAll(Pageable arg0) {
				return null;
			}

			@Override
			public <S extends AttributionSummary> S saveAndFlush(S entity) {
				return null;
			}

			@Override
			public <S extends AttributionSummary> List<S> save(Iterable<S> entities) {
				for (AttributionSummary summ : entities) {
					saved.add(summ);
				}
				return null;
			}

			@Override
			public AttributionSummary getOne(Long id) {
				return null;
			}

			@Override
			public void flush() {

			}

			@Override
			public List<AttributionSummary> findAll(Iterable<Long> ids) {
				return null;
			}

			@Override
			public List<AttributionSummary> findAll(Sort sort) {
				return null;
			}

			@Override
			public List<AttributionSummary> findAll() {
				return null;
			}

			@Override
			public void deleteInBatch(Iterable<AttributionSummary> entities) {

			}

			@Override
			public void deleteAllInBatch() {

			}

			@Override
			public List<AttributionSummary> findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(Date effectiveDate,
					String portId) {
				return saved;
			}

			@Override
			public List<AttributionSummary> getSavedAttributionSummaries() {
				return saved;
			}
		};
		checkableWrapper = repo;
		return repo;
	}
}


	CharacteristicsStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import javax.inject.Inject;

import org.powermock.reflect.Whitebox;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.constants.MarketSegmentationType;
import com.vanguard.corp.ics.sdt.service.api.exception.DataTransferException;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.service.impl.DataTransferServiceImpl;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsHelperService;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsTransferService;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MagicRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MundaneRounder;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.TopTenHoldingsRounder;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.CharacteristicsIntegrationData;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.TargetCharacteristicsDataBuilder;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CharacteristicsStepDefs {

	private static final String AS_OF_DATE_1 = "2016-01-31";
	private static final String AS_OF_DATE_2 = "2016-02-29";
	private static final String AS_OF_DATE_3 = "2016-03-31"; // no target data
	private static final String PORT_ID_1 = "TEST01";
	private static final String PORT_ID_2 = "TEST02";
	private static final String CALLED_BY_USER_ID = "UABC";

	@Inject
	private CharacteristicsIntegrationData characteristicsIntegrationData;

	@Inject
	private TargetCharacteristicsDataBuilder characteristicsBuilder;

	private DateParser dateParser = new DateParser();
	private Random random = new Random((new Date()).getTime());
	private List<FactsetMonthlyCharacteristicsTargetDAO> retrievableTargetCharacteristics;
	private CheckableCharacteristicsRepoWrapper checkableWrapper;
	private boolean targetTableProblem;
	private boolean reportingTableProblem;
	private Exception caughtException;
	private Map<String, String> codeMap = new HashMap<>();

	@Before
	public void setup() {
		characteristicsIntegrationData.resetData();
		retrievableTargetCharacteristics = new ArrayList<>();
		checkableWrapper = null;
		targetTableProblem = false;
		reportingTableProblem = false;
		caughtException = null;
		if (codeMap.isEmpty()) {
			codeMap.put("CONALOCN", "CountryAllocation");
			codeMap.put("CURALOCN", "CurrencyAllocation");
			codeMap.put("REGALOCN", "RegionalAllocation");
			codeMap.put("SECALOCN", "SectorAllocation");
			codeMap.put("TOP10HOL", "TopTenHoldings");
			codeMap.put("MKTSGMNT", "MarketCharacteristics");
			codeMap.put("CHARSTCS", "MarketCharacteristics");
		}
	}

	@Given("^target tables contain characteristics data for multiple port ids and multiple as of dates$")
	public void targetTablesContainCharacteristicsDataForMultiplePortIdsAndMultipleAsOfDates() throws Throwable {
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildPortfolioCharacteristicsData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildPortfolioCharacteristicsData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildPortfolioCharacteristicsData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildPortfolioCharacteristicsData(AS_OF_DATE_2, PORT_ID_2));
		
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCountryAllocationData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCountryAllocationData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCountryAllocationData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCountryAllocationData(AS_OF_DATE_2, PORT_ID_2));
		
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCurrencyAllocationData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCurrencyAllocationData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCurrencyAllocationData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildCurrencyAllocationData(AS_OF_DATE_2, PORT_ID_2));
		
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildRegionalAllocationData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildRegionalAllocationData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildRegionalAllocationData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildRegionalAllocationData(AS_OF_DATE_2, PORT_ID_2));
		
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildSectorAllocationData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildSectorAllocationData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildSectorAllocationData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildSectorAllocationData(AS_OF_DATE_2, PORT_ID_2));
		
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildTopTenHoldingsData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildTopTenHoldingsData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildTopTenHoldingsData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildTopTenHoldingsData(AS_OF_DATE_2, PORT_ID_2));
		
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildMarketSegmentationData(AS_OF_DATE_1, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildMarketSegmentationData(AS_OF_DATE_1, PORT_ID_2));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildMarketSegmentationData(AS_OF_DATE_2, PORT_ID_1));
		characteristicsIntegrationData.getAvailableTargetCharacteristics().addAll(characteristicsBuilder.buildMarketSegmentationData(AS_OF_DATE_2, PORT_ID_2));
		
		System.err.println(characteristicsIntegrationData.getAvailableTargetCharacteristics().size() + " AVAILABLE CHARACTERISTICS");
	}

	@Given("^target tables contain no characteristics data for a specific as of date$")
	public void targetTablesContainNoCharacteristicsDataForASpecificAsOfDate() throws Throwable {
		// no characteristics added to availableTargetCharacteristics
	}

	@Given("^one of the included as of dates is targeted$")
	public void oneOfTheIncludedAsOfDatesIsTargeted() throws Throwable {
		List<String> includedDates = characteristicsIntegrationData.getIncludedAsOfDates();
		characteristicsIntegrationData.setTargetAsOfDate(includedDates.get(random.nextInt(includedDates.size())));
	}

	@Given("^that as of date is targeted anyway$")
	public void thatAsOfDatesIsTargetedAnyway() throws Throwable {
		characteristicsIntegrationData.setTargetAsOfDate(AS_OF_DATE_3);
	}

	@Given("^one of the included port ids is targeted$")
	public void oneOfTheIncludedPortIdsIsTargeted() throws Throwable {
		List<String> includedPortIds = characteristicsIntegrationData.getIncludedPortIds();
		characteristicsIntegrationData.setTargetPortId(includedPortIds.get(random.nextInt(includedPortIds.size())));
	}

	@When("^characteristics data are transferred$")
	public void characteristicsDataAreTransferred() throws Throwable {
		for (FactsetMonthlyCharacteristicsTargetDAO ch : characteristicsIntegrationData.getAvailableTargetCharacteristics()) {
			if (isTargeted(ch)) {
				retrievableTargetCharacteristics.add(ch);
			}
		}

		final DataTransferParameters parms = new DataTransferParameters();
		parms.setAsOfDate(characteristicsIntegrationData.getTargetAsOfDate());
		parms.setPortId(characteristicsIntegrationData.getTargetPortId());
		parms.setUid(CALLED_BY_USER_ID);

		final DataTransferResource resource = buildDataTransferResource();
		try {
			resource.transfer(parms);
		}
		catch (Exception e) {
			caughtException = e;
		}

		assertNotNull("checkableWrapper is null", checkableWrapper);
		characteristicsIntegrationData.setSavedCharacteristics(checkableWrapper.getSavedCharacteristics());
	}

	private boolean isTargeted(FactsetMonthlyCharacteristicsTargetDAO ch) {
		return ch.getFactsetEffectiveDate().equals(dateParser.parse(characteristicsIntegrationData.getTargetAsOfDate())) && 
				(characteristicsIntegrationData.getTargetPortId() == null || ch.getPortfolioCode().equals(characteristicsIntegrationData.getTargetPortId()));
	}

	@Then("^the characteristics data for the targeted as of date are saved to reporting tables$")
	public void theCharacteristicsDataForTheTargetedAsOfDateAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());

		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			assertEquals(dateParser.parse(characteristicsIntegrationData.getTargetAsOfDate()), ch.getEffectiveDate());
		}

		assertEquals(retrievableTargetCharacteristics.size(), characteristicsIntegrationData.getSavedCharacteristics().size());
	}

	@Then("^no characteristics data for other as of dates are saved to reporting tables$")
	public void noCharacteristicsDataForOtherAsOfDatesAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			assertEquals(dateParser.parse(characteristicsIntegrationData.getTargetAsOfDate()), ch.getEffectiveDate());
		}
		
		assertEquals(retrievableTargetCharacteristics.size(), characteristicsIntegrationData.getSavedCharacteristics().size());
	}

	@Then("^the saved characteristics codes are based on the source characteristics codes$")
	public void theSavedCharacteristicsCodesAreBasedOnTheSourceCharacteristicsCodes() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		
		for (FactsetMonthlyCharacteristicsTargetDAO dao : retrievableTargetCharacteristics) {
			for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
				if (dao.getCharacteristicsName().equals(ch.getName())) {
					assertEquals(dao.getCharacteristicsType(), codeMap.get(ch.getType()));
				}
			}
		}
	}
	
	@Then("^the saved characteristics numeric values are rounded to one decimal place$")
	public void theSavedCharacteristicsNumericValuesAreRoundedToOneDecimalPlace() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			if (ch.getBenchmark() != null) {
				assertEquals(1, ch.getBenchmark().scale());
			}
			if (ch.getPortfolio() != null) {
				assertEquals(1, ch.getPortfolio().scale());
			}
		}
	}

	@Then("^the saved characteristics last updated user id is set appropriately$")
	public void theSavedCharacteristicsLastUpdatedUserIdIsSetAppropriately() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			assertEquals(CALLED_BY_USER_ID, ch.getLastUpdatedUserId());
		}
	}
	
	@Then("^the other saved characteristics data exactly match the source data$")
	public void theOtherSavedCharacteristicsDataExactlyMatchTheSourceData() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());

		int foundCount = 0;
		for (FactsetMonthlyCharacteristicsTargetDAO dao : retrievableTargetCharacteristics) {
			for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
				if (CharacteristicsType.MARKET_SEGMENTATION.getReportingCode().equals(ch.getType())) {
					if (isConvertedMarketingSegmentationName(dao, ch)) {
						foundCount++;
						break;
					}
				}
				else {
					if (dao.getCharacteristicsName().equals(ch.getName()) && dao.getPortfolioCode().equals(ch.getPortId())) {
						foundCount++;
						break;
					}
				}
			}
		}

		assertEquals(retrievableTargetCharacteristics.size(), foundCount);
	}

	protected boolean isConvertedMarketingSegmentationName(FactsetMonthlyCharacteristicsTargetDAO dao, Characteristics ch) {
		return (MarketSegmentationType.LARGE.getTargetName().equals(dao.getCharacteristicsName()) && MarketSegmentationType.LARGE.getReportingName().equals(ch.getName())) ||
				(MarketSegmentationType.MEDIUM_LARGE.getTargetName().equals(dao.getCharacteristicsName()) && MarketSegmentationType.MEDIUM_LARGE.getReportingName().equals(ch.getName())) ||
				(MarketSegmentationType.MEDIUM.getTargetName().equals(dao.getCharacteristicsName()) && MarketSegmentationType.MEDIUM.getReportingName().equals(ch.getName())) ||
				(MarketSegmentationType.MEDIUM_SMALL.getTargetName().equals(dao.getCharacteristicsName()) && MarketSegmentationType.MEDIUM_SMALL.getReportingName().equals(ch.getName())) ||
				(MarketSegmentationType.SMALL.getTargetName().equals(dao.getCharacteristicsName()) && MarketSegmentationType.SMALL.getReportingName().equals(ch.getName()))
				;
	}

	@Then("^the characteristics data for the targeted port id and as of date are saved to reporting tables$")
	public void theCharacteristicsDataForTheTargetedPortIdAndAsOfDateAreSavedToReportingTables() throws Throwable {
		Set<String> includedPortIds = new HashSet<>();
		for (FactsetMonthlyCharacteristicsTargetDAO dao : retrievableTargetCharacteristics) {
			includedPortIds.add(dao.getPortfolioCode());
		}
		
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			assertEquals(dateParser.parse(characteristicsIntegrationData.getTargetAsOfDate()), ch.getEffectiveDate());
			assertTrue(includedPortIds.contains(ch.getPortId()));
		}
	}

	@Then("^no characteristics data for other port ids or as of dates are saved to reporting tables$")
	public void noCharacteristicsDataForOtherPortIdsOrAsOfDatesAreSavedToReportingTables() throws Throwable {
		Set<String> includedPortIds = new HashSet<>();
		for (FactsetMonthlyCharacteristicsTargetDAO dao : retrievableTargetCharacteristics) {
			includedPortIds.add(dao.getPortfolioCode());
		}
		
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			assertEquals(dateParser.parse(characteristicsIntegrationData.getTargetAsOfDate()), ch.getEffectiveDate());
			assertTrue(includedPortIds.contains(ch.getPortId()));
		}
	}

	@Then("^no characteristics data are saved to reporting tables$")
	public void noCharacteristicsDataAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		assertEquals(0, characteristicsIntegrationData.getSavedCharacteristics().size());
	}

	@Then("^a problem exists in the (.*) table connection$")
	public void aProblemExistsInTheTableConnection(String whichTable) throws Throwable {
		targetTableProblem = "target".equals(whichTable);
		reportingTableProblem = "reporting".equals(whichTable);
	}

	@Then("^the system indicates a (.*) data transfer$")
	public void theSystemIndicatesADataTransfer(String success) throws Throwable {
		if ("successful".equals(success)) {
			assertNull(caughtException);
		}
		else if ("failed".equals(success)) {
			assertNotNull(caughtException);
			assertTrue(caughtException instanceof DataTransferException);
		}
		else {
			throw new RuntimeException("unexpected success value:"+success);
		}
	}

	private DataTransferResource buildDataTransferResource() {
		final DataTransferResource resource = new DataTransferResource();
		Whitebox.setInternalState(resource, DataTransferService.class, buildDataTransferService());
		return resource;
	}

	private DataTransferService buildDataTransferService() {
		final DataTransferService service = new DataTransferServiceImpl();
		List<TransferService> services = new ArrayList<>();
		services.add(buildCharacteristicsTransferHandler());
		Whitebox.setInternalState(service, "services", services);
		return service;
	}

	private TransferService buildCharacteristicsTransferHandler() {
		final TransferService handler = new CharacteristicsTransferService();
		Whitebox.setInternalState(handler, FactsetMonthlyCharacteristicsRepository.class, buildReadCharacteristicsRepository());
		Whitebox.setInternalState(handler, CharacteristicsConverter.class, new CharacteristicsConverter.Impl());
		Whitebox.setInternalState(handler, "rounders", buildCharacteristicsRounders());
		Whitebox.setInternalState(handler, CharacteristicsHelperService.class, buildCharacteristicsRepoWrapper());
		return handler;
	}

	private FactsetMonthlyCharacteristicsRepository buildReadCharacteristicsRepository() {
		final FactsetMonthlyCharacteristicsRepository repo = new FactsetMonthlyCharacteristicsRepository() {

			private final List<FactsetMonthlyCharacteristicsTargetDAO> retrievable = retrievableTargetCharacteristics;
			private final boolean readProblem = targetTableProblem;

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findByFactsetEffectiveDateAndPortfolioCodeAndExpiryDateIsNull(Date asOfDate, String portfolioCode) {
				if (readProblem) {
					throw new RuntimeException("read target failed");
				}
				return retrievable;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findByFactsetEffectiveDateAndExpiryDateIsNull(Date asOfDate) {
				if (readProblem) {
					throw new RuntimeException("read target failed");
				}
				return retrievable;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findAll() {
				return null;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findAll(Sort sort) {
				return null;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findAll(Iterable<Long> ids) {
				return null;
			}

			@Override
			public <S extends FactsetMonthlyCharacteristicsTargetDAO> List<S> save(Iterable<S> entities) {
				return null;
			}

			@Override
			public void flush() {
			}

			@Override
			public <S extends FactsetMonthlyCharacteristicsTargetDAO> S saveAndFlush(S entity) {
				return null;
			}

			@Override
			public void deleteInBatch(Iterable<FactsetMonthlyCharacteristicsTargetDAO> entities) {
			}

			@Override
			public void deleteAllInBatch() {
			}

			@Override
			public FactsetMonthlyCharacteristicsTargetDAO getOne(Long id) {
				return null;
			}

			@Override
			public Page<FactsetMonthlyCharacteristicsTargetDAO> findAll(Pageable arg0) {
				return null;
			}

			@Override
			public long count() {
				return 0;
			}

			@Override
			public void delete(Long arg0) {
			}

			@Override
			public void delete(FactsetMonthlyCharacteristicsTargetDAO arg0) {
			}

			@Override
			public void delete(Iterable<? extends FactsetMonthlyCharacteristicsTargetDAO> arg0) {
			}

			@Override
			public void deleteAll() {
			}

			@Override
			public boolean exists(Long arg0) {
				return false;
			}

			@Override
			public FactsetMonthlyCharacteristicsTargetDAO findOne(Long arg0) {
				return null;
			}

			@Override
			public <S extends FactsetMonthlyCharacteristicsTargetDAO> S save(S arg0) {
				return null;
			}
		};
		return repo;
	}

	private List<CharacteristicsRounder> buildCharacteristicsRounders() {
		List<CharacteristicsRounder> rounders = new ArrayList<>();
		rounders.add(new MagicRounder());
		rounders.add(new MundaneRounder());
		rounders.add(new TopTenHoldingsRounder());
		
		return rounders;
	}

	private static interface CheckableCharacteristicsRepoWrapper extends CharacteristicsHelperService {

		List<Characteristics> getSavedCharacteristics();
	}

	private CharacteristicsHelperService buildCharacteristicsRepoWrapper() {
		final CheckableCharacteristicsRepoWrapper wrapper = new CheckableCharacteristicsRepoWrapper() {

			private final List<Characteristics> saved = new ArrayList<>();
			private final boolean writeProblem = reportingTableProblem;

			@Override
			public List<Characteristics> getSavedCharacteristics() {
				return saved;
			}

			@Override
			public List<Characteristics> saveAll(List<Characteristics> saveList) {
				if (writeProblem) {
					throw new RuntimeException("write reporting failed");
				}
				saved.addAll(saveList);
				return saveList;
			}

			@Override
			public List<Characteristics> retrieveAll(Date asOfDate, String portId) {
				return null;
			}

			@Override
			public List<Characteristics> retrieveAll(Date asOfDate) {
				return null;
			}

			@Override
			public void logicalDelete(Date asOfDate, String portId, String characteristicsType) {
			}
		};

		checkableWrapper = wrapper;
		return wrapper;
	}
}


	PerformanceSummaryStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.inject.Inject;

import org.powermock.reflect.Whitebox;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.dao.target.PerformanceCalculationDAO;
import com.vanguard.corp.ics.enums.CalculationPeriodEnum;
import com.vanguard.corp.ics.pojos.DateVersion;
import com.vanguard.corp.ics.repository.target.PerformanceCalculationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.PerformanceSummarayRepository;
import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.PerformanceSummaryName;
import com.vanguard.corp.ics.sdt.service.impl.DataTransferServiceImpl;
import com.vanguard.corp.ics.sdt.service.impl.performancesummary.PerformanceSummaryDataConverter;
import com.vanguard.corp.ics.sdt.service.impl.performancesummary.PerformanceSummaryTransferService;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.PerformanceSummaryIntegrationData;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class PerformanceSummaryStepDefs {
	private static final String DATE_FORMAT = "yyyy-MM-dd";
	private static final String AS_OF_DATE_1 = "2016-01-31";
	private static final String AS_OF_DATE_2 = "2016-02-29";
	private static final String PORT_ID_1 = "TEST01";
	private static final String PORT_ID_2 = "TEST02";
	private static final String CALLED_BY_USER_ID = "UXYZ";

	@Inject
	private PerformanceSummaryIntegrationData performanceSummaryIntegrationData;
	private List<PerformanceCalculationDAO> retrievableTargetPerformanceSummaries;
	private String targetPortId;
	private CheckablePerformanceSummaryServiceWrapper checkableWrapper;

	@Before
	public void setup() {
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(new ArrayList<>());
		performanceSummaryIntegrationData.setSavedPerformanceSummaries(null);
		performanceSummaryIntegrationData.setEffectiveDate(null);
		retrievableTargetPerformanceSummaries = new ArrayList<>();
		targetPortId = null;
		checkableWrapper = null;
	}

	private List<PerformanceCalculationDAO> buildPerformanceSummary(final Date effectiveDate, final String portId, final String bmkType, String prtType) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(7);
		for(int i=0; i<10; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			c.setBmkType(bmkType);
			c.setPrtType(prtType);
			returnData.add(addValuesToPerformanceCalculationDAO(c, i));
		}
		return returnData;
	}
	
	private PerformanceCalculationDAO addValuesToPerformanceCalculationDAO(PerformanceCalculationDAO dao, int i){
		if (i == 0) {
			dao.setPeriod(CalculationPeriodEnum.CYTD);
			dao.setPrtVal(BigDecimal.valueOf(2.2357));
			dao.setBmkVal(BigDecimal.valueOf(1.2357));
		} else if (i == 1) {
			dao.setPeriod(CalculationPeriodEnum.P1M);
			dao.setPrtVal(BigDecimal.valueOf(2.1527));
			dao.setBmkVal(BigDecimal.valueOf(3.4527));
		} else if (i == 2) {
			dao.setPeriod(CalculationPeriodEnum.P3M);
			dao.setPrtVal(BigDecimal.valueOf(2.1527));
			dao.setBmkVal(BigDecimal.valueOf(5.7527));
		} else if (i == 3) {
			dao.setPeriod(CalculationPeriodEnum.P6M);
			dao.setPrtVal(BigDecimal.valueOf(2.167));
			dao.setBmkVal(BigDecimal.valueOf(1.867));
		} else if (i == 4) {
			dao.setPeriod(CalculationPeriodEnum.P1Y);
			dao.setPrtVal(BigDecimal.valueOf(2.1017));
			dao.setBmkVal(BigDecimal.valueOf(7.2517));
		} else if (i == 5) {
			dao.setPeriod(CalculationPeriodEnum.P3YPA);
			dao.setPrtVal(BigDecimal.valueOf(4.1997));
			dao.setBmkVal(BigDecimal.valueOf(2.1097));
		} else if (i == 6) {
			dao.setPeriod(CalculationPeriodEnum.P5YPA);
			dao.setPrtVal(BigDecimal.valueOf(3.7917));
			dao.setBmkVal(BigDecimal.valueOf(2.1117));
		} else if (i == 7) {
			dao.setPeriod(CalculationPeriodEnum.PINCP);
			dao.setPrtVal(BigDecimal.valueOf(6.1070));
			dao.setBmkVal(BigDecimal.valueOf(8.1570));
		} else if (i == 8) {
			dao.setPeriod(CalculationPeriodEnum.PINCEPPA);
			dao.setPrtVal(BigDecimal.valueOf(19.057));
			dao.setBmkVal(BigDecimal.valueOf(9.657));
		} else if (i == 9) {
			dao.setPeriod(CalculationPeriodEnum.FYTD);
			dao.setPrtVal(BigDecimal.valueOf(1.9927));
			dao.setBmkVal(BigDecimal.valueOf(2.9027));
		}
		return dao;
	}

	public List<PerformanceCalculationDAO> buildPerformanceSummaryList() throws ParseException {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();

		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (Gross)", "Bmk (Div Return)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (Net)", "Bmk (Div Return)"));

		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_2, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_2, "Portfolio (Gross)", "Bmk (Div Return)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_2, "Portfolio (Net)", "Bmk (Div Return)"));

		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_2, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_2, "Portfolio (Gross)", "Bmk (Div Return)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_2, "Portfolio (Net)", "Bmk (Div Return)"));

		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (Gross)", "Bmk (Div Return)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (Net)", "Bmk (Div Return)"));

		return performanceCalculationDAOs;
	}

	@Given("^target tables contain performance summary data for multiple port ids and multiple effective dates$")
	public void targetTablesContainPerformanceSummaryDataForMultiplePortIdsAndMultipleEffectiveDates()
			throws Throwable {
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(buildPerformanceSummaryList());
	}

	@Given("^one of the included performance summary effective date is targeted$")
	public void oneOfTheIncludedPerformanceSummaryEffectiveDateIsTargeted() throws Throwable {
		performanceSummaryIntegrationData.setEffectiveDate((new Random()).nextBoolean() ? AS_OF_DATE_1 : AS_OF_DATE_2);
	}

	@When("^performance summary data are transferred$")
	public void performanceSummaryDataAreTransferred() throws Throwable {
		SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		Date targetDate = formatter.parse(performanceSummaryIntegrationData.getEffectiveDate());
		for (PerformanceCalculationDAO dao : performanceSummaryIntegrationData.getAvailablePerformanceSummaries()) {
			if (dao.getCalcDt().equals(targetDate) && (targetPortId == null || dao.getPrtCd().equals(targetPortId))) {
				retrievableTargetPerformanceSummaries.add(dao);
			}
		}

		final DataTransferParameters parms = new DataTransferParameters();
		parms.setAsOfDate(performanceSummaryIntegrationData.getEffectiveDate());
		parms.setPortId(targetPortId);
		parms.setUid(CALLED_BY_USER_ID);

		final DataTransferResource resource = buildDataTransferResource();
		resource.transfer(parms);

		assertNotNull("checkableWrapper is null", checkableWrapper);
		performanceSummaryIntegrationData.setSavedPerformanceSummaries(checkableWrapper.getSavedPerformanceSummaries());
	}

	@Then("^the performance summary data for the targeted effective dates are saved to reporting tables$")
	public void thePerformanceSummaryDataForTheTargetedEffectiveDatesAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedAttributionSummary is null",
				performanceSummaryIntegrationData.getAvailablePerformanceSummaries());
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		int foundCount = 0;
		for (PerformanceSummary performanceSummary : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if (formatter.format(performanceSummary.getEffectiveDate())
					.equals(performanceSummaryIntegrationData.getEffectiveDate())) {
				foundCount++;
			}
		}

		assertEquals(performanceSummaryIntegrationData.getSavedPerformanceSummaries().size(), foundCount);
	}

	@Then("^no performance summary data for other effective dates are saved to reporting tables$")
	public void noPerformanceSummaryDataForOtherEffectiveDatesAreSavedToReportingTables() throws Throwable {
		// yeah, already did that above
	}

	@Then("^data rounded off to (\\d+) decimal places are saved to the reporting table$")
	public void dataRoundedOffToDecimalPlacesAreSavedToTheReportingTable(int scale) throws Throwable {
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			assertEquals(scale, data.getOneMonthValue().scale());
			assertEquals(scale, data.getThreeMonthValue().scale());
			assertEquals(scale, data.getSixMonthValue().scale());
			assertEquals(scale, data.getOneYearValue().scale());
			assertEquals(scale, data.getThreeYearValue().scale());
			assertEquals(scale, data.getFiveYearValue().scale());
			assertEquals(scale, data.getYearToDateValue().scale());
			assertEquals(scale, data.getInceptionValue().scale());
		}
	}

	@Then("^performance summary data with type name \"([^\"]*)\" are saved to the reporting table$")
	public void performanceSummaryDataWithTypeNameAreSavedToTheReportingTable(String name) throws Throwable {
		boolean found = false;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if (data.getPerformanceTypeName().equals(name)) {
				found = true;
			}
		}
		assertEquals(found, true);
	}

	@Given("^one of the included performance summary port ids is targeted$")
	public void oneOfTheIncludedPerformanceSummaryPortIdsIsTargeted() throws Throwable {
		targetPortId = (new Random()).nextBoolean() ? PORT_ID_1 : PORT_ID_2;
	}

	@Then("^the performance summary data for the targeted effective date and port id are saved to reporting tables$")
	public void thePerformanceSummaryDataForTheTargetedEffectiveDateAndPortIdAreSavedToReportingTables()
			throws Throwable {
		assertNotNull("savedAttributionSummary is null",
				performanceSummaryIntegrationData.getAvailablePerformanceSummaries());

		int foundCount = 0;
		for (PerformanceCalculationDAO dao : retrievableTargetPerformanceSummaries) {
			for (PerformanceSummary performanceSummary : performanceSummaryIntegrationData
					.getSavedPerformanceSummaries()) {
				if (dao.getCalcDt().equals(performanceSummary.getEffectiveDate()) && dao.getPrtCd().equals(performanceSummary.getPortId())) {
					foundCount++;
					break;
				}
			}
		}

		assertEquals(retrievableTargetPerformanceSummaries.size(), foundCount);
	}

	@Then("^no performance summary data for other effective dates or port ids are saved to reporting tables$")
	public void noPerformanceSummaryDataForOtherEffectiveDatesOrPortIdsAreSavedToReportingTables() throws Throwable {
		// yeah, already did that above
	}

	@Given("^target tables contain no performance summary data$")
	public void targetTablesContainNoPerformanceSummaryData() throws Throwable {
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(new ArrayList<>());
	}

	@Given("^a performance summary effective date is targeted anyway$")
	public void aPerformanceSummaryEffectiveDateIsTargetedAnyway() throws Throwable {
		performanceSummaryIntegrationData.setEffectiveDate((new Random()).nextBoolean() ? AS_OF_DATE_1 : AS_OF_DATE_2);
	}

	@Given("^a performance summary port id is targeted anyway$")
	public void aPerformanceSummaryPortIdIsTargetedAnyway() throws Throwable {
		targetPortId = (new Random()).nextBoolean() ? PORT_ID_1 : PORT_ID_2;
	}

	@Then("^data with type name \"([^\"]*)\" with NULL values are saved into report table$")
	public void dataWithTypeNameWithNULLValuesAreSavedIntoReportTable(String name) throws Throwable {
		boolean found = false;
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if (name.equals(data.getPerformanceTypeName())) {
				found = true;
				verifyValuesToBeNull(data);
			}
		}
		assertEquals(found, true);
	}

	@Given("^target tables contain performance summary data with type name \"([^\"]*)\"$")
	public void targetTablesContainPerformanceSummaryDataWithTypeName(String name) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (GrossSSSS)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (GrossSSSS)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_2, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_2, "Portfolio (GrossSSSS)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_2, "Portfolio (Gross)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_2, "Portfolio (GrossSSSS)", "Bmk (Net)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}

	@Then("^performance summary data with valid name \"([^\"]*)\" are saved to reporting tables$")
	public void performanceSummaryDataWithValidNameAreSavedToReportingTables(String name) throws Throwable {
		boolean foundValidName = false;
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if (name.equals(data.getPerformanceTypeName())) {
				foundValidName = true;
			}
		}
		assertEquals(foundValidName, true);
	}

	@Then("^performance summary data with invalid name \"([^\"]*)\" are not saved to reporting tables$")
	public void performanceSummaryDataWithInvalidNameAreNotSavedToReportingTables(String name) throws Throwable {
		boolean foundValidName = false;
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if (name.equals(data.getPerformanceTypeName())) {
				foundValidName = true;
			}
		}
		assertEquals(foundValidName, false);
	}

	@Given("^target tables does not contain the required type name \"([^\"]*)\"$")
	public void targetTablesDoesNotContainTheRequiredTypeName(String name) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (Net)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_2), PORT_ID_2, "Portfolio (Net)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (Net)", "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummary(formatter.parse(AS_OF_DATE_1), PORT_ID_2, "Portfolio (Net)", "Bmk (Net)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}

	@Then("^performance summary data with null values for the type name \"([^\"]*)\" is saved to the reporting table$")
	public void performanceSummaryDataWithNullValuesForTheTypeNameIsSavedToTheReportingTable(String name)
			throws Throwable {
		PerformanceSummary portfolio = null;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if (name.equals(data.getPerformanceTypeName())) {
				portfolio = data;
				assertNotNull(portfolio);
				verifyValuesToBeNull(portfolio);
			}
		}
	}

	private void verifyValuesToBeNull(PerformanceSummary portfolio) {
		assertEquals(null, portfolio.getOneMonthValue());
		assertEquals(null, portfolio.getThreeMonthValue());
		assertEquals(null, portfolio.getSixMonthValue());
		assertEquals(null, portfolio.getNineMonthValue());
		assertEquals(null, portfolio.getOneYearValue());
		assertEquals(null, portfolio.getThreeYearValue());
		assertEquals(null, portfolio.getFiveYearValue());
		assertEquals(null, portfolio.getTenYearValue());
		assertEquals(null, portfolio.getInceptionValue());
		assertEquals(null, portfolio.getYearToDateValue());
	}

	@Then("^performance summary data with null values are saved for the type name \"([^\"]*)\"$")
	public void performanceSummaryDataWithNullValuesAreSavedForTheTypeName(String arg1) throws Throwable {
		PerformanceSummary diff = null;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if ("Diff".equals(data.getPerformanceTypeName())) {
				diff = data;
				assertNotNull(diff);
				verifyValuesToBeNull(diff);
			}
		}
	}

	@Given("^target tables contains data for the required type name \"([^\"]*)\" with value \"([^\"]*)\"$")
	public void targetTablesContainsDataForTheRequiredTypeNameWithValue(String arg1, String arg2) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithSpecificTestValues(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Portfolio (Gross)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithSpecificTestValues(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Bmk (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithSpecificTestValues(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Portfolio (Gross)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithSpecificTestValues(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Bmk (Net)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}
	
	private List<PerformanceCalculationDAO> buildPerformanceSummaryWithSpecificTestValues(final Date effectiveDate, final String portId, final String name) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(7);
		for(int i=0; i<10; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			if(name.equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())){
				c.setPrtType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_PRICE_RETURN.getName())){
				c.setBmkType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_DIV_RETURN.getName())){
				c.setBmkType(name);
			} else if(name.equals(PerformanceSummaryName.PORTFOLIO_NET.getName())){
				c.setPrtType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_GROSS.getName())){
				c.setBmkType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_NET.getName())){
				c.setBmkType(name);
			} else if(name .equals("Portfolio (GrossSSSSS)")){
				c.setPrtType(name);
			}
			returnData.add(addValuesToPerformanceCalculationDAOWithSpecificTestValues(c, i));
		}
		return returnData;
	}
	
	private PerformanceCalculationDAO addValuesToPerformanceCalculationDAOWithSpecificTestValues(PerformanceCalculationDAO dao, int i){
		if (i == 0) {
			dao.setPeriod(CalculationPeriodEnum.CYTD);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 1) {
			dao.setPeriod(CalculationPeriodEnum.P1M);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 2) {
			dao.setPeriod(CalculationPeriodEnum.P3M);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 3) {
			dao.setPeriod(CalculationPeriodEnum.P6M);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 4) {
			dao.setPeriod(CalculationPeriodEnum.P1Y);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 5) {
			dao.setPeriod(CalculationPeriodEnum.P3YPA);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 6) {
			dao.setPeriod(CalculationPeriodEnum.P5YPA);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 7) {
			dao.setPeriod(CalculationPeriodEnum.PINCP);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 8) {
			dao.setPeriod(CalculationPeriodEnum.PINCEPPA);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		} else if (i == 9) {
			dao.setPeriod(CalculationPeriodEnum.FYTD);
			dao.setPrtVal(BigDecimal.valueOf(10.0149999));
			dao.setBmkVal(BigDecimal.valueOf(10.0149999));
		}
		return dao;
	}

	@Then("^data are rounded off to (\\d+) decimal places$")
	public void dataAreRoundedOffToDecimalPlaces(int scale) throws Throwable {
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			assertEquals(scale, data.getOneMonthValue().scale());
			assertEquals(scale, data.getThreeMonthValue().scale());
			assertEquals(scale, data.getSixMonthValue().scale());
			assertEquals(scale, data.getOneYearValue().scale());
			assertEquals(scale, data.getThreeYearValue().scale());
			assertEquals(scale, data.getFiveYearValue().scale());
			assertEquals(scale, data.getYearToDateValue().scale());
			assertEquals(scale, data.getInceptionValue().scale());
		}
	}

	@Then("^data with type name \"([^\"]*)\" with value (\\d+)\\.(\\d+) is saved into report table$")
	public void dataWithTypeNameWithValueIsSavedIntoReportTable(String arg1, int integer, int fraction) throws Throwable {
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if ("Portfolio (Gross)".equals(data.getPerformanceTypeName())) {
				validateValues(data, BigDecimal.valueOf(10.01));
			} else if ("Bmk (Net)".equals(data.getPerformanceTypeName())) {
				validateValues(data, BigDecimal.valueOf(10.01));
			} else if ("Diff".equals(data.getPerformanceTypeName())) {
				validateValues(data, BigDecimal.valueOf(0.00).setScale(2, RoundingMode.HALF_UP));
			}
		}

	}

	private void validateValues(PerformanceSummary data, BigDecimal value) {
		assertEquals(value, data.getOneMonthValue());
		assertEquals(value, data.getThreeMonthValue());
		assertEquals(value, data.getSixMonthValue());
		assertEquals(value, data.getOneYearValue());
		assertEquals(value, data.getThreeYearValue());
		assertEquals(value, data.getFiveYearValue());
		assertEquals(value, data.getYearToDateValue());
		assertEquals(value, data.getInceptionValue());
	}

	@Given("^target tables contains data for the Bmk \\(Div Return\\) with all values \"([^\"]*)\"$")
	public void targetTablesContainsDataForTheBmkDivReturnWithAllValues(String arg1) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Bmk (Div Return)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Bmk (Div Return)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}

	private List<PerformanceCalculationDAO> buildPerformanceSummaryWithNullValues(final Date effectiveDate, final String portId, final String name) {
		List<PerformanceCalculationDAO> returnData = new ArrayList<>(7);
		for(int i=0; i<7; i++){
			PerformanceCalculationDAO c = new PerformanceCalculationDAO();
			c.setCalcDt(effectiveDate);
			c.setPrtCd(portId);
			if(name.equals(PerformanceSummaryName.PORTFOLIO_GROSS.getName())){
				c.setPrtType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_PRICE_RETURN.getName())){
				c.setBmkType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_DIV_RETURN.getName())){
				c.setBmkType(name);
			} else if(name.equals(PerformanceSummaryName.PORTFOLIO_NET.getName())){
				c.setPrtType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_GROSS.getName())){
				c.setBmkType(name);
			} else if(name.equals(PerformanceSummaryName.BMK_NET.getName())){
				c.setBmkType(name);
			}
			returnData.add(addNullToPerformanceCalculationDAO(c, i));
		}
		return returnData;
	}
	
	private PerformanceCalculationDAO addNullToPerformanceCalculationDAO(PerformanceCalculationDAO dao, int i){
		if (i == 0) {
			dao.setPeriod(CalculationPeriodEnum.CYTD);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 1) {
			dao.setPeriod(CalculationPeriodEnum.P1M);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 2) {
			dao.setPeriod(CalculationPeriodEnum.P3M);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 3) {
			dao.setPeriod(CalculationPeriodEnum.P6M);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 4) {
			dao.setPeriod(CalculationPeriodEnum.P1Y);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 5) {
			dao.setPeriod(CalculationPeriodEnum.P3YPA);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 6) {
			dao.setPeriod(CalculationPeriodEnum.P5YPA);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 7) {
			dao.setPeriod(CalculationPeriodEnum.PINCP);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 8) {
			dao.setPeriod(CalculationPeriodEnum.PINCEPPA);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		} else if (i == 9) {
			dao.setPeriod(CalculationPeriodEnum.FYTD);
			dao.setPrtVal(null);
			dao.setBmkVal(null);
		}
		return dao;
	}

	@Then("^the data with type name Bmk \\(Div Return\\) is not saved into the report table$")
	public void theDataWithTypeNameBmkDivReturnIsNotSavedIntoTheReportTable() throws Throwable {
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		PerformanceSummary performanceSummary = null;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if ("Bmk (Div Return)".equals(data.getPerformanceTypeName())) {
				performanceSummary = data;
			}
		}
		assertEquals(null, performanceSummary);
	}

	@Given("^target tables contains data for the Bmk \\(Price Return\\) with all values \"([^\"]*)\"$")
	public void targetTablesContainsDataForTheBmkPriceReturnWithAllValues(String arg1) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_2), PORT_ID_1,
				"Bmk (Price Return)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_1), PORT_ID_1,
				"Bmk (Price Return)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}

	@Then("^the data with type name Bmk \\(Price Return\\) is not saved into the report table$")
	public void theDataWithTypeNameBmkPriceReturnIsNotSavedIntoTheReportTable() throws Throwable {
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		PerformanceSummary performanceSummary = null;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if ("Bmk (Price Return)".equals(data.getPerformanceTypeName())) {
				performanceSummary = data;
			}
		}
		assertEquals(null, performanceSummary);
	}

	@Given("^target tables contains data for the Portfolio \\(Net\\) with all values \"([^\"]*)\"$")
	public void targetTablesContainsDataForThePortfolioNetWithAllValues(String arg1) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_2), PORT_ID_1,
				"Portfolio (Net)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_1), PORT_ID_1,
				"Portfolio (Net)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}

	@Then("^the data with type name Portfolio \\(Net\\) is not saved into the report table$")
	public void theDataWithTypeNamePortfolioNetIsNotSavedIntoTheReportTable() throws Throwable {
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		PerformanceSummary performanceSummary = null;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if ("Portfolio (Net)".equals(data.getPerformanceTypeName())) {
				performanceSummary = data;
			}
		}
		assertEquals(null, performanceSummary);
	}

	@Given("^target tables contains data for the Bmk \\(Gross\\) with all values \"([^\"]*)\"$")
	public void targetTablesContainsDataForTheBmkGrossWithAllValues(String arg1) throws Throwable {
		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		List<PerformanceCalculationDAO> performanceCalculationDAOs = new ArrayList<>();
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_2), PORT_ID_1, "Bmk (Gross)"));
		performanceCalculationDAOs.addAll(buildPerformanceSummaryWithNullValues(formatter.parse(AS_OF_DATE_1), PORT_ID_1, "Bmk (Gross)"));
		performanceSummaryIntegrationData.setAvailablePerformanceSummaries(performanceCalculationDAOs);
	}

	@Then("^the data with type name Bmk \\(Gross\\) is not saved into the report table$")
	public void theDataWithTypeNameBmkGrossIsNotSavedIntoTheReportTable() throws Throwable {
		assertEquals(3, performanceSummaryIntegrationData.getSavedPerformanceSummaries().size());
		PerformanceSummary performanceSummary = null;
		for (PerformanceSummary data : performanceSummaryIntegrationData.getSavedPerformanceSummaries()) {
			if ("Bmk (Gross)".equals(data.getPerformanceTypeName())) {
				performanceSummary = data;
			}
		}
		assertEquals(null, performanceSummary);
	}

	private DataTransferResource buildDataTransferResource() {
		final DataTransferResource resource = new DataTransferResource();
		Whitebox.setInternalState(resource, DataTransferService.class, buildDataTransferService());
		return resource;
	}

	private DataTransferService buildDataTransferService() {
		final DataTransferService service = new DataTransferServiceImpl();
		List<TransferService> services = new ArrayList<>();
		services.add(buildPerformanceSummaryTransferHandler());
		Whitebox.setInternalState(service, "services", services);
		return service;
	}

	private TransferService buildPerformanceSummaryTransferHandler() {
		final TransferService handler = new PerformanceSummaryTransferService();
		Whitebox.setInternalState(handler, PerformanceCalculationRepository.class,
				buildReadPerformanceSummaryRepository());
		Whitebox.setInternalState(handler, "dataConverter", buildPerformanceSummaryConverter());
		Whitebox.setInternalState(handler, PerformanceSummarayRepository.class,
				buildPerformanceSummaryTransferSummaryJpa());
		return handler;
	}

	private PerformanceCalculationRepository buildReadPerformanceSummaryRepository() {
		final PerformanceCalculationRepository readRepo = new PerformanceCalculationRepository() {
			private final List<PerformanceCalculationDAO> retrievable = retrievableTargetPerformanceSummaries;
			@Override
			public <S extends PerformanceCalculationDAO> S save(S arg0) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public PerformanceCalculationDAO findOne(Long arg0) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public boolean exists(Long arg0) {
				// TODO Auto-generated method stub
				return false;
			}
			
			@Override
			public void deleteAll() {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void delete(Iterable<? extends PerformanceCalculationDAO> arg0) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void delete(PerformanceCalculationDAO arg0) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void delete(Long arg0) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public long count() {
				// TODO Auto-generated method stub
				return 0;
			}
			
			@Override
			public Page<PerformanceCalculationDAO> findAll(Pageable arg0) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public <S extends PerformanceCalculationDAO> S saveAndFlush(S entity) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public <S extends PerformanceCalculationDAO> List<S> save(Iterable<S> entities) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public PerformanceCalculationDAO getOne(Long id) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public void flush() {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public List<PerformanceCalculationDAO> findAll(Iterable<Long> ids) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public List<PerformanceCalculationDAO> findAll(Sort sort) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public List<PerformanceCalculationDAO> findAll() {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public void deleteInBatch(Iterable<PerformanceCalculationDAO> entities) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void deleteAllInBatch() {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public List<DateVersion> findMaxVersionPerMonthByPortfolioAndEndDateAndPeriod(String portfolioCode, Date start,
					Date end, CalculationPeriodEnum period) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public List<PerformanceCalculationDAO> findByPortfolioAndEndDateAndVersionAndPeriod(String portfolioCode, Date end,
					BigDecimal version, CalculationPeriodEnum period) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public List<PerformanceCalculationDAO> findByPortfolioAndDateRangeAndVersionAndPeriod(String portfolioCode,
					Date start, Date end, BigDecimal version, CalculationPeriodEnum period) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public PerformanceCalculationDAO findByPortfolioAndDateAndVersionAndPeriod(String portfolioCode, Date date,
					BigDecimal version, CalculationPeriodEnum period) {
				// TODO Auto-generated method stub
				return null;
			}
			
			@Override
			public List<PerformanceCalculationDAO> findByCalculationDateAndPortCodeAndLastestVersion(Date calculationDate,
					String portId) {
				return retrievable;
			}
			
			@Override
			public List<PerformanceCalculationDAO> findByCalculationDateAndLastestVersion(Date calculationDate) {
				return retrievable;
			}
		};
		return readRepo;
	}

	private Object buildPerformanceSummaryConverter() {
		return new PerformanceSummaryDataConverter();
	}

	private static interface CheckablePerformanceSummaryServiceWrapper extends PerformanceSummarayRepository {
		List<PerformanceSummary> getSavedPerformanceSummaries();
	}

	private CheckablePerformanceSummaryServiceWrapper buildPerformanceSummaryTransferSummaryJpa() {
		final CheckablePerformanceSummaryServiceWrapper repo = new CheckablePerformanceSummaryServiceWrapper() {
			private final List<PerformanceSummary> saved = new ArrayList<>();

			@Override
			public List<PerformanceSummary> findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(Date effectiveDate,
					String portId) {
				return saved;
			}

			@Override
			public List<PerformanceSummary> findAll() {
				return null;
			}

			@Override
			public List<PerformanceSummary> findAll(Sort sort) {
				return null;
			}

			@Override
			public List<PerformanceSummary> findAll(Iterable<Long> ids) {
				return null;
			}

			@Override
			public <S extends PerformanceSummary> List<S> save(Iterable<S> entities) {
				for (PerformanceSummary summ : entities) {
					saved.add(summ);
				}
				return null;
			}

			@Override
			public void flush() {
			}

			@Override
			public <S extends PerformanceSummary> S saveAndFlush(S entity) {
				return null;
			}

			@Override
			public void deleteInBatch(Iterable<PerformanceSummary> entities) {
			}

			@Override
			public void deleteAllInBatch() {
			}

			@Override
			public PerformanceSummary getOne(Long id) {
				return null;
			}

			@Override
			public Page<PerformanceSummary> findAll(Pageable arg0) {
				return null;
			}

			@Override
			public long count() {
				return 0;
			}

			@Override
			public void delete(Long arg0) {
			}

			@Override
			public void delete(PerformanceSummary arg0) {
			}

			@Override
			public void delete(Iterable<? extends PerformanceSummary> arg0) {
			}

			@Override
			public void deleteAll() {
			}

			@Override
			public boolean exists(Long arg0) {
				return false;
			}

			@Override
			public PerformanceSummary findOne(Long arg0) {
				return null;
			}

			@Override
			public <S extends PerformanceSummary> S save(S arg0) {
				return arg0;
			}

			@Override
			public List<PerformanceSummary> getSavedPerformanceSummaries() {
				return saved;
			}

		};
		checkableWrapper = repo;
		return repo;
	}
}


	RoundingStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.inject.Inject;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.constants.MarketSegmentationType;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.test.characteristics.FactsetMonthlyCharacteristicsTargetDAOBuilder;
import com.vanguard.corp.ics.sdt.test.characteristics.TestCharacteristicsType;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.CharacteristicsIntegrationData;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;

public class RoundingStepDefs {

	private static final String AS_OF_DATE = "2016-01-31";

	@Inject
	private CharacteristicsIntegrationData characteristicsIntegrationData;

	private FactsetMonthlyCharacteristicsTargetDAOBuilder builder = new FactsetMonthlyCharacteristicsTargetDAOBuilder();

	@Given("^target tables contain the following (.*) section data$")
	public void targetTablesContainTheFollowingSectionData(final String sectionName, final List<Map<String, String>> dataRows) throws Throwable {
		
		DateParser dateParser = new DateParser();
		
		TestCharacteristicsType testCharacteristicsType = TestCharacteristicsType.byName(sectionName);
		assertNotNull("Unknown characteristics name: "+sectionName, testCharacteristicsType);
		
		List<FactsetMonthlyCharacteristicsTargetDAO> available = new ArrayList<>();
		String portId, portfolio, benchmark;
		for (Map<String, String> dataRow : dataRows) {
			portId = dataRow.get("port id");
			portfolio = dataRow.get("portfolio value");
			benchmark = dataRow.get("benchmark value");
			
			available.add(builder.build(dateParser.parse(AS_OF_DATE), portId
					, testCharacteristicsType.getType().getTargetCode()
					, CharacteristicsType.MARKET_SEGMENTATION == testCharacteristicsType.getType() ? MarketSegmentationType.LARGE.getTargetName() : ""
					, portfolio.equals("null") ? null : portfolio
					, benchmark.equals("null") ? null : benchmark
					));
		}
		
		characteristicsIntegrationData.setAvailableTargetCharacteristics(available);
		characteristicsIntegrationData.setTargetAsOfDate(AS_OF_DATE);
	}

	@Then("^reporting tables contain the following (.*) section data$")
	public void reportingTablesContainTheFollowingSectionData(final String sectionName, final List<Map<String, String>> dataRows) throws Throwable {
		
		TestCharacteristicsType characteristicsType = TestCharacteristicsType.byName(sectionName);
		assertNotNull("Unknown characteristics name: "+sectionName, characteristicsType);
		
		Set<String> portIdsWithNullPortfolioValues = new HashSet<>();
		Set<String> portIdsWithNullBenchmarkValues = new HashSet<>();
		Map<String, List<String>> portIdEntryCounter = new HashMap<>();
		
		Set<String> portIds = new HashSet<>();
		String portId, portfolio, benchmark;
		List<String> counterList;
		boolean found = false;
		for (Map<String, String> dataRow : dataRows) {
			portId = dataRow.get("port id");
			portIds.add(portId);
			portfolio = dataRow.get("portfolio value");
			benchmark = dataRow.get("benchmark value");
			found = false;
			
			counterList = portIdEntryCounter.get(portId);
			if (counterList == null) {
				counterList = new ArrayList<>();
				portIdEntryCounter.put(portId, counterList);
			}
			counterList.add(portfolio+"-"+benchmark);
			
			if ("null".equals(portfolio)) {
				portIdsWithNullPortfolioValues.add(portId);
			}
			if ("null".equals(benchmark)) {
				portIdsWithNullBenchmarkValues.add(portId);
			}
			
			for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
				if (ch.getPortId().equals(portId)
						&& ch.getType().equals(characteristicsType.getType().getReportingCode())
						&& (
								("null".equals(portfolio) && ch.getPortfolio() == null)
								|| (!"null".equals(portfolio) && ch.getPortfolio() != null && ch.getPortfolio().compareTo(new BigDecimal(portfolio)) == 0)
								)
						&& (
								("null".equals(benchmark) && ch.getBenchmark() == null)
								|| (!"null".equals(benchmark) && ch.getBenchmark() != null && ch.getBenchmark().compareTo(new BigDecimal(benchmark)) == 0)
								)
						) {
					found = true;
					break;
				}
			}
			assertTrue(String.format("didn't find: portId:%s portfolio:%s benchmark:%s", portId, portfolio, benchmark), found);
		}
		
		if (characteristicsType.getType() == CharacteristicsType.PORTFOLIO_CHARACTERISTICS) {
			return; // yay, successful!
		}
		
		Map<String, BigDecimal> portfolioTotalsByPortId = new HashMap<>();
		Map<String, BigDecimal> benchmarkTotalsByPortId = new HashMap<>();
		Iterator<String> iterator = portIds.iterator();
		while (iterator.hasNext()) {
			portId = iterator.next();
			portfolioTotalsByPortId.put(portId, new BigDecimal("0.00000"));
			benchmarkTotalsByPortId.put(portId, new BigDecimal("0.00000"));
		}
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			portfolioTotalsByPortId.put(ch.getPortId(), portfolioTotalsByPortId.get(ch.getPortId()).add(ch.getPortfolio() == null ? BigDecimal.ZERO : ch.getPortfolio()));
			benchmarkTotalsByPortId.put(ch.getPortId(), benchmarkTotalsByPortId.get(ch.getPortId()).add(ch.getBenchmark() == null ? BigDecimal.ZERO : ch.getBenchmark()));
		}
		for (String key : portfolioTotalsByPortId.keySet()) {
			
			if (characteristicsType.getType() == CharacteristicsType.TOP_TEN_HOLDINGS
					&& portIdEntryCounter.get(key).size() > 9
					) {
				continue; // don't magic round more than 9 entries
			}
			
			if (!portIdsWithNullPortfolioValues.contains(key)) {
				assertEquals(String.format("type %s %s portfolio total is: %s", characteristicsType.getType().getReportingCode(), key, portfolioTotalsByPortId.get(key)), 0, portfolioTotalsByPortId.get(key).compareTo(new BigDecimal("100.0")));
			}
			if (!portIdsWithNullBenchmarkValues.contains(key)) {
				assertEquals(String.format("type %s %s benchmark total is: %s", characteristicsType.getType().getReportingCode(), key, benchmarkTotalsByPortId.get(key)), 0, benchmarkTotalsByPortId.get(key).compareTo(new BigDecimal("100.0")));
			}
		}
	}

}


com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared

	AttributionSummaryIntegrationData.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared;

import java.util.List;

import javax.inject.Named;

import org.springframework.context.annotation.Scope;

import com.vanguard.corp.ics.dao.target.AttributionTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;

@Named
@Scope("cucumber-glue")
public class AttributionSummaryIntegrationData {

	private List<AttributionTargetDAO> availableTargetAttributionSummaries;
	private String effectiveDate;
	private List<AttributionSummary> savedAttributionSummaries;
	private String portId;

	public List<AttributionTargetDAO> getAvailableTargetAttributionSummaries() {
		return availableTargetAttributionSummaries;
	}

	public void setAvailableTargetAttributionSummaries(
			List<AttributionTargetDAO> availableTargetAttributionSummaries) {
		this.availableTargetAttributionSummaries = availableTargetAttributionSummaries;
	}

	public String getEffectiveDate() {
		return effectiveDate;
	}

	public void setEffectiveDate(String effectiveDate) {
		this.effectiveDate = effectiveDate;
	}

	public List<AttributionSummary> getSavedAttributionSummaries() {
		return savedAttributionSummaries;
	}

	public void setSavedAttributionSummaries(List<AttributionSummary> savedAttributionSummaries) {
		this.savedAttributionSummaries = savedAttributionSummaries;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(String portId) {
		this.portId = portId;
	}

}


	CharacteristicsIntegrationData.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.inject.Named;

import org.springframework.context.annotation.Scope;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

@Named
@Scope("cucumber-glue")
public class CharacteristicsIntegrationData {

	private List<FactsetMonthlyCharacteristicsTargetDAO> availableTargetCharacteristics;
	private List<Characteristics> savedCharacteristics;
	private List<String> includedAsOfDates;
	private List<String> includedPortIds;
	private String targetAsOfDate;
	private String targetPortId;

	public void resetData() {
		availableTargetCharacteristics = new ArrayList<>();
		savedCharacteristics = null;
		includedAsOfDates = null;
		includedPortIds = null;
		targetAsOfDate = null;
		targetPortId = null;
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> getAvailableTargetCharacteristics() {
		return availableTargetCharacteristics;
	}

	public void setAvailableTargetCharacteristics(List<FactsetMonthlyCharacteristicsTargetDAO> availableTargetCharacteristics) {
		this.availableTargetCharacteristics = availableTargetCharacteristics;
	}

	public String getTargetAsOfDate() {
		return targetAsOfDate;
	}

	public void setTargetAsOfDate(String targetAsOfDate) {
		this.targetAsOfDate = targetAsOfDate;
	}

	public List<Characteristics> getSavedCharacteristics() {
		return savedCharacteristics;
	}

	public void setSavedCharacteristics(List<Characteristics> savedCharacteristics) {
		this.savedCharacteristics = savedCharacteristics;
	}

	public String getTargetPortId() {
		return targetPortId;
	}

	public void setTargetPortId(String targetPortId) {
		this.targetPortId = targetPortId;
	}

	public List<String> getIncludedAsOfDates() {
		if (includedAsOfDates == null) {
			Set<String> included = new HashSet<>();
			SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			
			for (FactsetMonthlyCharacteristicsTargetDAO dao : availableTargetCharacteristics) {
				included.add(df.format(dao.getFactsetEffectiveDate()));
			}
			
			includedAsOfDates = new ArrayList<>(included);
		}
		
		return includedAsOfDates;
	}

	public List<String> getIncludedPortIds() {
		if (includedPortIds == null) {
			Set<String> included = new HashSet<>();
			
			for (FactsetMonthlyCharacteristicsTargetDAO dao : availableTargetCharacteristics) {
				included.add(dao.getPortfolioCode());
			}
			
			includedPortIds = new ArrayList<>(included);
		}
		
		return includedPortIds;
	}
}


	PerformanceSummaryIntegrationData.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared;

import java.util.List;

import javax.inject.Named;

import org.springframework.context.annotation.Scope;

import com.vanguard.corp.ics.dao.target.PerformanceCalculationDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.PerformanceSummary;

@Named
@Scope("cucumber-glue")
public class PerformanceSummaryIntegrationData {
	private List<PerformanceCalculationDAO> availablePerformanceSummaries;
	private String effectiveDate;
	private List<PerformanceSummary> savedPerformanceSummaries;
	private String portId;
	public List<PerformanceCalculationDAO> getAvailablePerformanceSummaries() {
		return availablePerformanceSummaries;
	}
	public void setAvailablePerformanceSummaries(List<PerformanceCalculationDAO> availablePerformanceSummaries) {
		this.availablePerformanceSummaries = availablePerformanceSummaries;
	}
	public String getEffectiveDate() {
		return effectiveDate;
	}
	public void setEffectiveDate(String effectiveDate) {
		this.effectiveDate = effectiveDate;
	}
	public List<PerformanceSummary> getSavedPerformanceSummaries() {
		return savedPerformanceSummaries;
	}
	public void setSavedPerformanceSummaries(List<PerformanceSummary> savedPerformanceSummaries) {
		this.savedPerformanceSummaries = savedPerformanceSummaries;
	}
	public String getPortId() {
		return portId;
	}
	public void setPortId(String portId) {
		this.portId = portId;
	}
}


		TargetCharacteristicsDataBuilder.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.inject.Named;

import org.springframework.context.annotation.Scope;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.test.characteristics.FactsetMonthlyCharacteristicsTargetDAOBuilder;
import com.vanguard.corp.ics.sdt.test.characteristics.PortfolioCharacteristicsType;

@Named
@Scope("cucumber-glue")
public class TargetCharacteristicsDataBuilder {

	private FactsetMonthlyCharacteristicsTargetDAOBuilder builder = new FactsetMonthlyCharacteristicsTargetDAOBuilder();
	private DateParser dateParser = new DateParser();
	private Random random = new Random((new Date()).getTime());

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildPortfolioCharacteristicsData(String asOfDate, String portId) {
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();
		
		double val;
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.NUMBER_OF_SECURITIES.getLabel()
				, String.format("%.5f", (val = (2000 * random.nextDouble())))
				, String.format("%.5f", (20 * random.nextDouble() - 10) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.MARKET_CAPITALIZATION.getLabel()
				, String.format("%.5f", (val = (10000000 * random.nextDouble())))
				, String.format("%.5f", (1000000 * random.nextDouble() - 500000) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel()
				, String.format("%.5f", (val = (10000000 * random.nextDouble())))
				, String.format("%.5f", (1000000 * random.nextDouble() - 500000) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.MAX_MARKET_CAP.getLabel()
				, String.format("%.5f", (val = (10000000 * random.nextDouble())))
				, String.format("%.5f", (1000000 * random.nextDouble() - 500000) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.DIVIDEND_YIELD.getLabel()
				, String.format("%.5f", (val = (10 * random.nextDouble() - 5)))
				, String.format("%.5f", (5 * random.nextDouble() - 2.5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.PRICE_PER_EARNINGS.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", (10 * random.nextDouble() - 5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.PPE_USING_FY1_EST.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", (10 * random.nextDouble() - 5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.PRICE_PER_CASH_FLOW.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", (10 * random.nextDouble() - 5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.PRICE_PER_BOOK.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", (10 * random.nextDouble() - 5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.PRICE_PER_SALES.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", (10 * random.nextDouble() - 5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.ROE.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", (10 * random.nextDouble() - 5) + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.EARNINGS_GROWTH_RATE.getLabel()
				, String.format("%.5f", (val = (25 * random.nextDouble() - 12.5)))
				, String.format("%.5f", 10 * random.nextDouble() - 5 + val)
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.TURNOVER_1_MON.getLabel()
				, String.format("%.5f", (val = (2 * random.nextDouble() - 1)))
				, null
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.TURNOVER_3_MON.getLabel()
				, String.format("%.5f", (val = (2 * random.nextDouble() - 1)))
				, null
				));
		list.add(builder.build(dateParser.parse(asOfDate), portId
				, CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getTargetCode()
				, PortfolioCharacteristicsType.TURNOVER_12_MON.getLabel()
				, String.format("%.5f", (val = (2 * random.nextDouble() - 1)))
				, null
				));

		return list;
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildCountryAllocationData(String asOfDate, String portId) {
		String[] allowedValues = {"China", "Korea", "Taiwan", "India", "South Africa", "Brazil", "Mexico", "Russia",
				"Indonesia", "Malaysia", "Thailand", "Poland", "Philippines", "Chile", "Turkey", "United Arab Emirates",
				"Qatar", "Colombia", "Greece", "Peru", "Hungary", "Czech Republic", "Egypt"};
		
		return buildTargetData(asOfDate, portId, CharacteristicsType.COUNTRY_ALLOCATION.getTargetCode(), allowedValues, 10);
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildCurrencyAllocationData(String asOfDate, String portId) {
		String[] allowedValues = {"HKD", "KRW", "CNY", "BRL", "ZAR", "MXN", "RUB", "IDR", "MYR", "THB", "PLN", "CLP", "TRY",
				"PHP", "USD", "AED", "QAR", "COP", "EUR", "PEN", "HUF", "CZK", "EGP", "PKR"};
		
		return buildTargetData(asOfDate, portId, CharacteristicsType.CURRENCY_ALLOCATION.getTargetCode(), allowedValues, 10);
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildRegionalAllocationData(String asOfDate, String portId) {
		String[] allowedValues = {"Europe", "Japan", "North America", "Africa/Mid East", "Asia Pacific ex Japan", "Latin America"};
		
		return buildTargetData(asOfDate, portId, CharacteristicsType.REGIONAL_ALLOCATION.getTargetCode(), allowedValues, 3);
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildSectorAllocationData(String asOfDate, String portId) {
		String[] allowedValues = {"Financials", "Information Technology", "Consumer Discretionary", "Materials", "Consumer Staples",
				"Energy", "Industrials", "Telecommunication Services", "Utilities", "Health Care", "Real Estate"};
		
		return buildTargetData(asOfDate, portId, CharacteristicsType.SECTOR_ALLOCATION.getTargetCode(), allowedValues, 5);
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildTopTenHoldingsData(String asOfDate, String portId) {
		String[] allowedValues = {"Samsung Electronics Co., Ltd.", "Tencent Holdings Ltd.", "Taiwan Semiconductor Manufacturing Co., Ltd.",
				"Alibaba Group Holding Ltd. Sponsored ADR", "Naspers Limited Class N", "China Mobile Limited",
				"China Construction Bank Corporation Class H", "Industrial and Commercial Bank of China Limited Class H",
				"Baidu, Inc. Sponsored ADR Class A", "Fomento Economico Mexicano SAB de CV Units Cons. Of 1 ShsB And 4 ShsD",
				"Ufotable", "A-1 Studios", "J. C. Staff", "Production I.d.", "Gainax", "Sunrise", "Tatsunoko Production"};
		
		return buildTargetData(asOfDate, portId, CharacteristicsType.TOP_TEN_HOLDINGS.getTargetCode(), allowedValues, 6);
	}

	public List<FactsetMonthlyCharacteristicsTargetDAO> buildMarketSegmentationData(String asOfDate, String portId) {
		String[] allowedValues = {"Large Cap", "Medium/Large Cap", "Medium Cap", "Medium/Small Cap", "Small Cap"};
		
		return buildTargetData(asOfDate, portId, CharacteristicsType.MARKET_SEGMENTATION.getTargetCode(), allowedValues, allowedValues.length);
	}

	private List<FactsetMonthlyCharacteristicsTargetDAO> buildTargetData(String asOfDate, String portId, String targetCode, String[] allowedValues, int minSize) {
		List<String> allowedNames = new ArrayList<>();
		for (String name : allowedValues) {
			allowedNames.add(name);
		}
		
		List<Double> portfolioPercentages = generatePercentages(allowedValues.length, minSize);
		List<Double> benchmarkPercentages = generatePercentages(portfolioPercentages.size(), portfolioPercentages.size());
		
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();
		
		int bmkPosition, namePosition;
		for (Double portfolio : portfolioPercentages) {
			namePosition = random.nextInt(allowedNames.size());
			bmkPosition = random.nextInt(benchmarkPercentages.size());
			
			list.add(builder.build(dateParser.parse(asOfDate), portId, targetCode
					, allowedNames.get(namePosition)
					, String.format("%.5f", portfolio)
					, String.format("%.5f", benchmarkPercentages.get(bmkPosition))
					));
			
			allowedNames.remove(namePosition);
			benchmarkPercentages.remove(bmkPosition);
		}
		
		return list;
	}

	private List<Double> generatePercentages(int maxCount, int minCount) {
		Assert.isTrue(maxCount >= minCount);
		
		List<Double> list = new ArrayList<>();
		double remaining = 100.0d, val;
		
		do {
			val = (remaining < 1.0 ? 1.0 : (remaining > 20 ? remaining * 0.6 : remaining)) * random.nextDouble();
			
			if (remaining - val < 0.0) {
				val = remaining;
				remaining = 0.0;
			}
			else {
				remaining = remaining - val;
			}
			
			list.add(val);
		} while (remaining > 0.0);
		
		while (list.size() > maxCount && list.size() > 1) {
			double sum = list.get(list.size() - 1);
			sum += list.get(list.size() - 2);
			list.remove(list.size() - 1);
			list.remove(list.size() - 1);
			list.add(sum);
		}
		
		while (list.size() < minCount) {
			list.add(0.0d);
		}
		
		return list;
	}
}


com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.unit
	CharacteristicsStepDefs.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.unit;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

import java.math.BigDecimal;
import java.util.Date;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CharacteristicsStepDefs {

	private static final String CALLED_BY_USER_ID = "UABC";

	private CharacteristicsConverter converter = new CharacteristicsConverter.Impl();
	private FactsetMonthlyCharacteristicsTargetDAO targetCharacteristics;
	private Characteristics reportingCharacteristics;
	private CharacteristicsType expectedCharacteristicsType;
	private String givenName;
	private Random random = new Random();

	@Before
	public void setup() {
		targetCharacteristics = null;
		reportingCharacteristics = null;
		expectedCharacteristicsType = null;
		givenName = null;
	}

	@Given("^a characteristics record from target tables$")
	public void aCharacteristicsRecordFromTargetTables() throws Throwable {
		targetCharacteristics = new FactsetMonthlyCharacteristicsTargetDAO();
		targetCharacteristics.setFactsetEffectiveDate(new Date());
		targetCharacteristics.setPortfolioCode("ABC123");
		targetCharacteristics.setPortfolioValue(BigDecimal.valueOf(1.23456d));
		targetCharacteristics.setBenchMarkValue(BigDecimal.valueOf(0.12345d));
	}

	@Given("^the characteristics type code is (.*)$")
	public void theCharacteristicsTypeCodeIs(String targetTypeCode) throws Throwable {
		Set<String> expectedValues = new HashSet<>();
		expectedValues.add("CountryAllocation");
		expectedValues.add("CurrencyAllocation");
		expectedValues.add("RegionalAllocation");
		expectedValues.add("SectorAllocation");
		expectedValues.add("TopTenHoldings");
		expectedValues.add("MarketCharacteristics");
		
		if ("missing".equals(targetTypeCode)) {
			targetCharacteristics.setCharacteristicsType(null);
		}
		else if (expectedValues.contains(targetTypeCode)) {
			targetCharacteristics.setCharacteristicsType(targetTypeCode);
		}
		else if ("any other value".equals(targetTypeCode)) {
			targetCharacteristics.setCharacteristicsType(anyNonNullString());
		}
		else {
			throw new RuntimeException("unhandled targetTypeCode value: "+targetTypeCode);
		}
	}

	@Given("^the name is (.*)$")
	public void theNameIs(String name) throws Throwable {
	    Set<String> expectedValues = new HashSet<>();
	    expectedValues.add("Large Cap");
	    expectedValues.add("Medium/Large Cap");
	    expectedValues.add("Medium Cap");
	    expectedValues.add("Medium/Small Cap");
	    expectedValues.add("Small Cap");
	    
	    if ("missing".equals(name)) {
	    	targetCharacteristics.setCharacteristicsName(null);
	    }
	    else if (expectedValues.contains(name)) {
	    	targetCharacteristics.setCharacteristicsName(name);
	    }
	    else if ("any other value".equals(name)) {
	    	targetCharacteristics.setCharacteristicsName(anyNonNullString());
	    }
	    else if ("any value".equals(name)) {
	    	targetCharacteristics.setCharacteristicsName(anyString());
	    }
	    else {
	    	throw new RuntimeException("unhandled name value: "+name);
	    }
	    
	    givenName = targetCharacteristics.getCharacteristicsName();
	}

	@When("^the characteristics code is translated$")
	public void theCharacteristicsCodeIsTranslated() throws Throwable {
		reportingCharacteristics = converter.convert(targetCharacteristics, CALLED_BY_USER_ID);
	}

	@Then("^the translated characteristics name is (.*)$")
	public void theTranslatedCharacteristicsNameIs(String name) throws Throwable {
		if ("missing".equals(name)) {
			assertNull(reportingCharacteristics.getName());
		}
		else if ("given value".equals(name)) {
			assertEquals(givenName, reportingCharacteristics.getName());
		}
		else {
			assertEquals(name, reportingCharacteristics.getName());
		}
	}

	@Then("^the translated characteristics type is (.*)$")
	public void theTranslatedCharacteristicsTypeIs(String expectedType) throws Throwable {
		if ("Country Allocation".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.COUNTRY_ALLOCATION;
		}
		else if ("Currency Allocation".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.CURRENCY_ALLOCATION;
		}
		else if ("Regional Allocation".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.REGIONAL_ALLOCATION;
		}
		else if ("Sector Allocation".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.SECTOR_ALLOCATION;
		}
		else if ("Top Ten Holdings".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.TOP_TEN_HOLDINGS;
		}
		else if ("Market Segmentation By Cap".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.MARKET_SEGMENTATION;
		}
		else if ("Portfolio Characteristics".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.PORTFOLIO_CHARACTERISTICS;
		}
		else if ("Unknown".equals(expectedType)) {
			expectedCharacteristicsType = CharacteristicsType.UNKNOWN;
		}
		
		CharacteristicsType actualType = CharacteristicsType.byReportingCodeOrUnknown(reportingCharacteristics.getType());
		assertEquals(expectedCharacteristicsType, actualType);
	}

	@Then("^the translated characteristics code is (.*)$")
	public void theTranslatedCharacteristicsCodeIs(String expectedTypeCode) throws Throwable {
		assertEquals(expectedTypeCode, reportingCharacteristics.getType());
	}

	private String anyString() {
		if (random.nextInt(100) < 10) {
			return null;
		}
		if (random.nextInt(100) < 10) {
			return "";
		}
		return anyNonNullString();
	}

	private String anyNonNullString() {
		int length = 5 + random.nextInt(25);
		StringBuffer sb = new StringBuffer();
		
		while (sb.length() < length) {
			sb.append(anyCharacter());
		}
		
		return sb.toString();
	}

	private char anyCharacter() {
		String allowed = "ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz _-,.?/!@#$%^&*()+=";
		return allowed.charAt(random.nextInt(allowed.length()));
	}
}


	RiskSummaryServiceSteps.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.unit;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.portal.ProductPortalServiceImpl;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestPortfolioLimitRepository;
import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.LimitValidator;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.RiskSummaryServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class RiskSummaryServiceSteps {

	private static final String CURRENT_USERNAME = "Utilities Username";
	
	@Mock
	ProductPortalServiceImpl productPortalService;
	
	@Mock
	LimitValidator limitValidator;

	@Spy
	TestPortfolioLimitRepository repo = new TestPortfolioLimitRepository();

	@InjectMocks
	RiskSummaryServiceImpl riskSummaryService;

	private PortalProduct product;

	private AnalyticsTypeCode type;
	
	private List<Limit> limitList = new ArrayList<>();

	@Given("^a portfolio with ([\\dA-z -]+) and (-?\\d+) that exists in Product Portal$")
	public void a_portfolio_with_Analytic_Type_and_risk_that_exists_in_Product_Portal(String analyticName, BigDecimal limit) throws Throwable {
		MockitoAnnotations.initMocks(this);
		product = new PortalProduct();

		if (AnalyticsTypeCode.EX_ANTE_RISK.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.EX_ANTE_RISK;
			product.setExAnteMaxBreachIMA(limit);
		} else if (AnalyticsTypeCode.ONE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_EX_POST;
			product.setExPostMaxBreachIMA(limit);
		} else if (AnalyticsTypeCode.THREE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.THREE_YR_EX_POST;
			product.setExPostMaxBreachIMA(limit);
		} else if (AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_STANDARD_DEV;
		} else {
			type = AnalyticsTypeCode.THREE_YR_STANDARD_DEV;
		}

		product.setProductCode("TEST");

		List<PortalProduct> products = new ArrayList<PortalProduct>();

		products.add(product);

		when(productPortalService.getProducts(any(HttpServletRequest.class))).thenReturn(products);
		when(productPortalService.getProduct(products, "TEST")).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		when(repo.findByPortfolioCodeAndEffectiveEndDateIsNull(any(String.class))).thenReturn(limitList);
	}

	@Given("^a portfolio with ([\\dA-z -]+), (-?\\d+), (-?\\d+), and (\\d+) that exists in Product Portal$")
	public void a_portfolio_with_Analytic_type_and_split_attributes_that_exists_in_Product_Portal(String analyticName,
			BigDecimal riskLowerLimit, BigDecimal riskUpperLimit, BigDecimal fumSplitLimit) throws Throwable {
		MockitoAnnotations.initMocks(this);
		product = new PortalProduct();
		
		if (AnalyticsTypeCode.EX_ANTE_RISK.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.EX_ANTE_RISK;
			product.setExAnteMaxBreachIMA(riskLowerLimit);
			product.setExAnteMaxBreachIMAAbove(riskUpperLimit);
			product.setFumLimitexAnte(fumSplitLimit);
		} else if (AnalyticsTypeCode.ONE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_EX_POST;
			product.setExPostMaxBreachIMA(riskLowerLimit);
		} else if (AnalyticsTypeCode.THREE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.THREE_YR_EX_POST;
			product.setExPostMaxBreachIMA(riskLowerLimit);
		} else if (AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_STANDARD_DEV;
		} else {
			type = AnalyticsTypeCode.THREE_YR_STANDARD_DEV;
		}
		
		product.setProductCode("TEST");
		
		List<PortalProduct> products = new ArrayList<PortalProduct>();
		
		products.add(product);
		
		when(productPortalService.getProducts(any(HttpServletRequest.class))).thenReturn(products);
		when(productPortalService.getProduct(products, "TEST")).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(BigDecimal.class), nullable(BigDecimal.class), nullable(BigDecimal.class))).thenReturn(true);
		when(repo.findByPortfolioCodeAndEffectiveEndDateIsNull(any(String.class))).thenReturn(limitList);
	}
	
	@Given("^the same portfolio exists in the reporting table$")
	public void the_same_portfolio_exists_in_the_reporting_table() throws Throwable {
		Limit limit = new Limit();
		
		limit.setPortfolioCode(product.getProductCode());
		limit.setLimitTypeCode(type.getCode());
		limit.setLimitName(type.getName());
		
		if (type.equals(AnalyticsTypeCode.EX_ANTE_RISK)) {
			limit.setLowerLimitValue(product.getExAnteMaxBreachIMA());
		} else {
			limit.setLowerLimitValue(product.getExPostMaxBreachIMA());
		}
		
		limitList.add(limit);
		
		repo.dataMap.put(product.getProductCode() + type.getCode() + "existing", limit);
		
		when(repo.findByPortfolioCodeAndEffectiveEndDateIsNull(any(String.class))).thenReturn(limitList);
	}

	@When("^user runs the Risk Summary calculations$")
	public void user_runs_the_Risk_Summary_calculations() throws Throwable {
		HttpServletRequest mock = Mockito.mock(HttpServletRequest.class);
		riskSummaryService.transfer(new Date(), "TEST", CURRENT_USERNAME, mock);
	}

	@Then("^the reporting table shall show (-?\\d+\\.?\\d+|\\s*)$")
	public void the_reporting_table_shall_show_limit(BigDecimal expected) throws Throwable {
		assertEquals(expected, repo.dataMap.get(product.getProductCode() + type.getCode()).getLowerLimitValue());
		assertNull(repo.dataMap.get(product.getProductCode() + type.getCode()).getEffectiveEndDate());
	}

	@Then("^the reporting table shall show (-?\\d+\\.?\\d+|\\s*) and (-?\\d+\\.?\\d+|\\s*) and (\\d+|\\s*)$")
	public void the_reporting_table_shall_show_lower_limit_and_upper_limit_and_FUM_split_limit(BigDecimal lowerLimit,
			BigDecimal upperLimit, BigDecimal fumSplitLimit) throws Throwable {
		assertEquals(lowerLimit, repo.dataMap.get(product.getProductCode() + type.getCode()).getLowerLimitValue());
		assertEquals(upperLimit, repo.dataMap.get(product.getProductCode() + type.getCode()).getUpperLimitValue());
		assertEquals(fumSplitLimit, repo.dataMap.get(product.getProductCode() + type.getCode()).getFumSplitLimitValue());
		assertNull(repo.dataMap.get(product.getProductCode() + type.getCode()).getEffectiveEndDate());
	}
	
	@Then("^the existing reporting record should be end-dated$")
	public void the_existing_reporting_record_should_be_end_dated() {
		assertNotNull(repo.dataMap.get(product.getProductCode() + type.getCode() + "existing").getEffectiveEndDate());
	}
}

com.vanguard.corp.ics.sdt.webservice.resource
	TomcatDefaultErrorResourceTest.java

/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.webservice.resource;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.times;

import java.io.IOException;

import javax.servlet.DispatcherType;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
@RunWith(MockitoJUnitRunner.class)
public class TomcatDefaultErrorResourceTest {
	
	@Mock
	private HttpServletResponse response;
	
	@Mock
	private HttpServletRequest request;
	
	@Mock
	private ServletOutputStream outputStream;
	
	@Test
	public void testHandleErrorWhenDispatcherTypeError() throws IOException {
		TomcatDefaultErrorResource resource = createTomcatDefaultErrorResource("ERROR");
		int returnCode = 401;
		
		when(request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).thenReturn(returnCode);
		when(request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).thenReturn("http://blahblahblah.com");
		when(request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).thenReturn("Success");
		when(request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).thenReturn(null);
		when(response.getStatus()).thenReturn(returnCode);
		when(response.getOutputStream()).thenReturn(outputStream);
		doNothing().when(outputStream).flush();
		doNothing().when(outputStream).close();

		resource.handleError(response, request);
		
		assertEquals(returnCode, response.getStatus());
		
	}

	@Test
	public void testHandleErrorWhenDispatcherTypeNotError() throws IOException {
		TomcatDefaultErrorResource resource = createTomcatDefaultErrorResource("REQUEST");
		int returnCode = 500;
		
		when(response.getOutputStream()).thenReturn(outputStream);
		when(response.getStatus()).thenReturn(returnCode);
		doNothing().when(outputStream).flush();
		doNothing().when(outputStream).close();

		resource.handleError(response, request);
		
		assertEquals(returnCode, response.getStatus());
	}
	
	private TomcatDefaultErrorResource createTomcatDefaultErrorResource(String dispatcherType) {
		TomcatDefaultErrorResource resource = new TomcatDefaultErrorResource() {

			@Override
			protected String getDispatcherType(HttpServletRequest request) {
				return dispatcherType;
			}
			
		};
		return resource;
	}

	@Test
	public void testGetDispatcherType() {
		when(request.getDispatcherType()).thenReturn(DispatcherType.FORWARD);
		
		TomcatDefaultErrorResource classUnderTest = new TomcatDefaultErrorResource();
		classUnderTest.getDispatcherType(request);
		
		verify(request, times(1)).getDispatcherType();
	}
}



src/test/resources
	features
		attributionSummary
			attributionSummary.feature

@AttributionSummary
Feature: Attribution Summary functionality
  
  Specifications:
  1. Calculating Attribution Summary values:
     a. read value from L2 (Target) table
     b. write value to L1 (Reporting) table
  
  2. 
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for Attribution Summary.
  2. Effective Date is a required input parameter.
  
  Definitions:
  1.

  @IntegrationTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contain attribution summary data for multiple port ids and multiple effective dates
    And one of the included effective dates is targeted
    When attribution summary data are transferred
    Then the attribution summary data for the targeted effective dates are saved to reporting tables
    And no attribution summary data for other effective dates are saved to reporting tables
    And the saved attribution summary data exactly match the source data

  @IntegrationTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contain attribution summary data for multiple port ids and multiple effective dates
    And one of the included effective dates is targeted
    And one of the included attribution summary port ids is targeted
    When attribution summary data are transferred
    Then the attribution summary data for the targeted port id and effective dates are saved to reporting tables
    And no attribution summary data for other port ids or effective dates are saved to reporting tables
    And the saved attribution summary data exactly match the source data

  @IntegrationTest
  Scenario: no data found is fine
    Given target tables contain no attribution summary data
    And an effective date is targeted anyway
    When attribution summary data are transferred
    Then no attribution summary data are saved to reporting tables

  @IntegrationTest
  Scenario: no data validation is done
    Given target tables contain attribution summary data for multiple port ids and multiple effective dates
    And target tables contain attribution summary data with name "RHuisdgFO%ICHF31as0943&$aAWEG"
    And one of the included effective dates is targeted
    When attribution summary data are transferred
    Then the attribution summary data for the targeted effective dates are saved to reporting tables
    And no attribution summary data for other effective dates are saved to reporting tables
    And the saved attribution summary data exactly match the source data
    And attribution summary data with name "RHuisdgFO%ICHF31as0943&$aAWEG" are saved to reporting tables

  @EndToEndTest
  Scenario: transfer of attribution summary values
    Given test attribution summary data are loaded into target tables
    When transfer of attribution summary data is requested
    Then the system indicates successful completion of the attribution Summary transfer
    And the test attribution summary data are saved in reporting tables
    And the test attribution summary data are cleaned up from the target tables
    And the test attribution summary data are cleaned up from the reporting tables


	characteristics
		characteristics.feature

@Characteristics
Feature: characteristics functionality
  
  Specifications:
  1. Calculating characteristics values:
     a. read value from L2 (Target) table
     b. transformation as required, per characteristics type
     c. write value to L1 (Reporting) table
  
  Assumptions:
  1. AsOfDate is a required input parameter.

  @IntegrationTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And one of the included as of dates is targeted
    When characteristics data are transferred
    Then the characteristics data for the targeted as of date are saved to reporting tables
    And no characteristics data for other as of dates are saved to reporting tables
    And the saved characteristics codes are based on the source characteristics codes
    And the saved characteristics numeric values are rounded to one decimal place
    And the saved characteristics last updated user id is set appropriately
    And the other saved characteristics data exactly match the source data
    And the system indicates a successful data transfer

  @IntegrationTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And one of the included as of dates is targeted
    And one of the included port ids is targeted
    When characteristics data are transferred
    Then the characteristics data for the targeted port id and as of date are saved to reporting tables
    And no characteristics data for other port ids or as of dates are saved to reporting tables
    And the saved characteristics codes are based on the source characteristics codes
    And the saved characteristics numeric values are rounded to one decimal place
    And the saved characteristics last updated user id is set appropriately
    And the other saved characteristics data exactly match the source data
    And the system indicates a successful data transfer

  @IntegrationTest
  Scenario: no data found is fine
    Given target tables contain no characteristics data for a specific as of date
    And that as of date is targeted anyway
    When characteristics data are transferred
    Then no characteristics data are saved to reporting tables
    And the system indicates a successful data transfer

  @IntegrationTest
  Scenario: problems occur when reading from target tables
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And one of the included as of dates is targeted
    And a problem exists in the target table connection
    When characteristics data are transferred
    Then no characteristics data are saved to reporting tables
    And the system indicates a failed data transfer

  @IntegrationTest
  Scenario: problems occur when writing to reporting tables
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And one of the included as of dates is targeted
    And a problem exists in the reporting table connection
    When characteristics data are transferred
    Then no characteristics data are saved to reporting tables
    And the system indicates a failed data transfer

  @UnitTest
  Scenario Outline: characteristics code translation mapping
    Given a characteristics record from target tables
    And the characteristics type code is <target table code>
    And the name is <target table name>
    When the characteristics code is translated
    Then the translated characteristics name is <expected name>
    And the translated characteristics type is <expected type>
    And the translated characteristics code is <expected code>

    Examples: 
      | target table code     | target table name | expected name | expected type              | expected code |
      | CountryAllocation     | missing           | missing       | Country Allocation         | CONALOCN      |
      | CountryAllocation     | any other value   | given value   | Country Allocation         | CONALOCN      |
      | CurrencyAllocation    | missing           | missing       | Currency Allocation        | CURALOCN      |
      | CurrencyAllocation    | any other value   | given value   | Currency Allocation        | CURALOCN      |
      | RegionalAllocation    | missing           | missing       | Regional Allocation        | REGALOCN      |
      | RegionalAllocation    | any other value   | given value   | Regional Allocation        | REGALOCN      |
      | SectorAllocation      | missing           | missing       | Sector Allocation          | SECALOCN      |
      | SectorAllocation      | any other value   | given value   | Sector Allocation          | SECALOCN      |
      | TopTenHoldings        | missing           | missing       | Top Ten Holdings           | TOP10HOL      |
      | TopTenHoldings        | any other value   | given value   | Top Ten Holdings           | TOP10HOL      |
      | MarketCharacteristics | Large Cap         | Large         | Market Segmentation By Cap | MKTSGMNT      |
      | MarketCharacteristics | Medium/Large Cap  | Large/Medium  | Market Segmentation By Cap | MKTSGMNT      |
      | MarketCharacteristics | Medium Cap        | Medium        | Market Segmentation By Cap | MKTSGMNT      |
      | MarketCharacteristics | Medium/Small Cap  | Small/Medium  | Market Segmentation By Cap | MKTSGMNT      |
      | MarketCharacteristics | Small Cap         | Small         | Market Segmentation By Cap | MKTSGMNT      |
      | MarketCharacteristics | missing           | missing       | Portfolio Characteristics  | CHARSTCS      |
      | MarketCharacteristics | any other value   | given value   | Portfolio Characteristics  | CHARSTCS      |
      | missing               | any value         | given value   | Unknown                    | UNKNOWNN      |
      | any other value       | any value         | given value   | Unknown                    | UNKNOWNN      |

  @EndToEndTest
  Scenario: transfer of characteristics values
    Given test characteristics data are loaded into target tables
    When transfer of characteristics data is requested
    Then the system indicates successful completion of the characteristics transfer
    And the test characteristics data are saved in reporting tables
    And the test characteristics data are cleaned up from the target tables
    And the test characteristics data are cleaned up from the reporting tables


		rounding.feature

@Characteristics @Rounding
Feature: Magic and Mundane Rounding
  
  1. Magic rounding happens every time data is moved for the following sections:
     Market Segmentation by Capitalization
     Regional Allocation
     Country Allocation
     Sector Allocation
     Currency Allocation
  
  2. Mundane rounding happens every time data is moved for the following sections:
     Portfolio Characteristics
  
  3. Rounding type is determined based on the number of data points for the port id
     in the section for the following sections:
     Top 10 Holdings
     
       a. if less than 10 data points: magic rounding
       
       b. if greater than or equal to 10 data points: mundane rounding
  
  4. Mundane rounding changes the portfolio value and benchmark value by rounding half away
     from zero to one digit after the decimal place.
  
  5. Magic rounding forces the sum of the mundanely rounded portfolio values and the sum of
     the mundanely rounded benchmark values for each port id to equal 100.0 by adding the
     difference from 100.0 to the greatest portfolio value and the greatest benchmark value.
     
     Note: The greatest benchmark value may not correspond to the greatest portfolio value.
     
     a. When the sum of the portfolio values after mundane rounding for a port id is greater
        than 100.0, the difference is subtracted from the greatest portfolio value for that
        port id.
     
     b. When the sum of the benchmark values after mundane rounding for a port id is greater
        than 100.0, the difference is subtracted from the greatest benchmark value for that
        port id.
     
     c. When the sum of the portfolio values after mundane rounding for a port id is less
        than 100.0, the difference is added to the greatest portfolio value for that port id.
     
     d. When the sum of the benchmark values after mundane rounding for a port id is less
        than 100.0, the difference is added to the greatest benchmark value for that port id.
     
     e. When the sum of the portfolio values after mundane rounding for a port id is exactly
        equal to 100.0, none of the portfolio values are adjusted for that port id.
     
     f. When the sum of the benchmark values after mundane rounding for a port id is exactly
        equal to 100.0, none of the benchmark values are adjusted for that port id.
     
     g. When the sum of the portfolio values after mundane rounding differs from 100.0 and two
        or more portfolio values after mundane rounding are tied as the greatest portfolio
        value, one of them is arbitrarily selected as the greatest and is adjusted as
        specified above.
     
     h. When the sum of the benchmark values after mundane rounding differs from 100.0 and two
        or more benchmark values after mundane rounding are tied as the greatest benchmark
        value, one of them is arbitrarily selected as the greatest and is adjusted as
        specified above.
     
     i. When one or more portfolio values for a port id is missing data (has a null value),
        the portfolio values for that port id are NOT magically rounded, but are instead
        saved to be displayed in their mundanely rounded form, including the null value. 
     
     j. When one or more benchmark values for a port id is missing data (has a null value),
        the benchmark values for that port id are NOT magically rounded, but are instead
        saved to be displayed in their mundanely rounded form, including the null value.

  @IntegrationTest
  Scenario Outline: magic rounding when the greatest value for each port id needs not to be adjusted
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                                  |
      | 1111    | 59.49999        | 59.49999        |                                          |
      | 1111    | 30.34999        | 30.34999        |                                          |
      | 1111    | 10.15011        | 10.15011        |                                          |
      | 1111    | 0.04999         | 0.04999         |                                          |
      | 2222    | 44.85001        | 55.14999        | portfolio and benchmark values different |
      | 2222    | 55.14999        | 44.85001        | portfolio and benchmark values different |
      | 3333    | 30.64999        | 30.64999        |                                          |
      | 3333    | 69.35001        | 69.35001        |                                          |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 59.50000        | 59.50000        |
      | 1111    | 30.30000        | 30.30000        |
      | 1111    | 10.20000        | 10.20000        |
      | 1111    | 0.00000         | 0.00000         |
      | 2222    | 44.90000        | 55.10000        |
      | 2222    | 55.10000        | 44.90000        |
      | 3333    | 30.60000        | 30.60000        |
      | 3333    | 69.40000        | 69.40000        |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: magic rounding when the greatest value for each port id needs to be adjusted
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                            |
      | 1111    | 59.40000        | 59.40000        | max portfolio and benchmark values |
      | 1111    | 30.30001        | 30.30001        |                                    |
      | 1111    | 10.20001        | 10.20001        |                                    |
      | 1111    | 0.04999         | 0.04999         |                                    |
      | 1111    | 0.04999         | 0.04999         |                                    |
      | 2222    | 54.99999        | 54.99999        | max portfolio and benchmark values |
      | 2222    | 44.90003        | 44.90003        |                                    |
      | 2222    | 0.04999         | 0.04999         |                                    |
      | 2222    | 0.04999         | 0.04999         |                                    |
      | 3333    | 21.05000        | 20.05000        | max portfolio value                |
      | 3333    | 20.05000        | 21.05000        | max benchmark value                |
      | 3333    | 20.05000        | 20.05000        |                                    |
      | 3333    | 20.05000        | 20.05000        |                                    |
      | 3333    | 18.80000        | 18.80000        |                                    |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                                      |
      | 1111    | 59.5            | 59.5            | portfolio and benchmark mundane values: 59.4 |
      | 1111    | 30.3            | 30.3            |                                              |
      | 1111    | 10.2            | 10.2            |                                              |
      | 1111    | 0.0             | 0.0             |                                              |
      | 1111    | 0.0             | 0.0             |                                              |
      | 2222    | 55.1            | 55.1            | portfolio and benchmark mundane values: 55.0 |
      | 2222    | 44.9            | 44.9            |                                              |
      | 2222    | 0.0             | 0.0             |                                              |
      | 2222    | 0.0             | 0.0             |                                              |
      | 3333    | 20.9            | 20.1            | portfolio mundane value: 21.1                |
      | 3333    | 20.1            | 20.9            | benchmark mundane value: 21.1                |
      | 3333    | 20.1            | 20.1            |                                              |
      | 3333    | 20.1            | 20.1            |                                              |
      | 3333    | 18.8            | 18.8            |                                              |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: missing data, a.k.a. nulls, prevents magic rounding of the values
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                            |
      | 1111    | 59.40000        | 59.40000        |                                    |
      | 1111    | 30.30001        | 30.30001        |                                    |
      | 1111    | 10.20001        | 10.20001        |                                    |
      | 1111    | null            | 0.04999         | portfolio values have missing data |
      | 1111    | 0.04999         | 0.04999         |                                    |
      | 2222    | 54.99999        | 54.99999        |                                    |
      | 2222    | 44.90003        | 44.90003        |                                    |
      | 2222    | 0.04999         | null            | benchmark values have missing data |
      | 2222    | 0.04999         | 0.04999         |                                    |
      | 3333    | 21.05000        | 20.05000        |                                    |
      | 3333    | 20.05000        | 21.05000        |                                    |
      | 3333    | 20.05000        | 20.05000        |                                    |
      | 3333    | 20.05000        | null            | both benchmark and portfolio       |
      | 3333    | null            | 18.80000        | values have missing data           |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                       |
      | 1111    | 59.4            | 59.5            | benchmark mundane value: 59.4 |
      | 1111    | 30.3            | 30.3            |                               |
      | 1111    | 10.2            | 10.2            |                               |
      | 1111    | null            | 0.0             |                               |
      | 1111    | 0.0             | 0.0             |                               |
      | 2222    | 55.1            | 55.0            | portfolio mundane value: 55.0 |
      | 2222    | 44.9            | 44.9            |                               |
      | 2222    | 0.0             | null            |                               |
      | 2222    | 0.0             | 0.0             |                               |
      | 3333    | 21.1            | 20.1            |                               |
      | 3333    | 20.1            | 21.1            |                               |
      | 3333    | 20.1            | 20.1            |                               |
      | 3333    | 20.1            | null            |                               |
      | 3333    | null            | 18.8            |                               |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: If numbers are tied as the largest number only modify one. The one chosen for modification does not matter.
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.00004         | 0.00004         |
      | 1111    | 49.90000        | 49.90000        |
      | 1111    | 49.90000        | 49.90000        |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 49.9            | 49.9            |
      | 1111    | 50.1            | 50.1            |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: magic rounding occurs even if incoming data does not add up to approximately 100
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 1.21020         | 5.21020         |
      | 1111    | 2.43039         | 2.43039         |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                      |
      | 1111    | 1.2             | 97.6            | benchmark mundane value: 5.2 |
      | 1111    | 98.8            | 2.4             | portfolio mundane value: 2.4 |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario: magic and mundane rounding for Top 10 Holdings - sometimes needs to sum to 100.0
    Given target tables contain the following Top 10 Holdings section data
      | port id | portfolio value | benchmark value | comment                                         |
      | 1111    | 33.90002        | 33.90002        | port id has 14 values                           |
      | 1111    | 11.00000        | 11.00000        |                                                 |
      | 1111    | 10.00000        | 10.00000        |                                                 |
      | 1111    | 9.00000         | 9.00000         |                                                 |
      | 1111    | 8.00000         | 2.00000         | portfolio and benchmark values different        |
      | 1111    | 7.00000         | 7.00000         |                                                 |
      | 1111    | 6.00000         | 6.00000         |                                                 |
      | 1111    | 5.00000         | 5.00000         |                                                 |
      | 1111    | 4.00000         | 4.00000         |                                                 |
      | 1111    | 3.00000         | 3.00000         |                                                 |
      | 1111    | 2.00000         | 8.00000         | portfolio and benchmark values different        |
      | 1111    | 1.00000         | 1.00000         |                                                 |
      | 1111    | 0.04999         | 0.04999         |                                                 |
      | 1111    | 0.04999         | 0.04999         |                                                 |
      | 2222    | 33.90002        | 33.90002        | port id has 10 values                           |
      | 2222    | 11.00000        | 11.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 5.00000         | 5.00000         |                                                 |
      | 2222    | 0.04999         | 0.04999         |                                                 |
      | 2222    | 0.04999         | 0.04999         |                                                 |
      | 3333    | 0.04999         | 0.04999         | port id has 5 values (magic rounding in effect) |
      | 3333    | 0.04999         | 0.04999         |                                                 |
      | 3333    | 59.40000        | 39.40000        | max portfolio value                             |
      | 3333    | 30.30001        | 50.30001        | max benchmark value                             |
      | 3333    | 10.20001        | 10.20001        |                                                 |
    When characteristics data are transferred
    Then reporting tables contain the following Top 10 Holdings section data
      | port id | portfolio value | benchmark value | comment                                                |
      | 1111    | 33.9            | 33.9            | sum for ten (of 14) displayed portfolio values is 96.9 |
      | 1111    | 11.0            | 11.0            | sum for ten (of 14) displayed benchmark values is 90.9 |
      | 1111    | 10.0            | 10.0            |                                                        |
      | 1111    | 9.0             | 9.0             |                                                        |
      | 1111    | 8.0             | 2.0             |                                                        |
      | 1111    | 7.0             | 7.0             |                                                        |
      | 1111    | 6.0             | 6.0             |                                                        |
      | 1111    | 5.0             | 5.0             |                                                        |
      | 1111    | 4.0             | 4.0             |                                                        |
      | 1111    | 3.0             | 3.0             |                                                        |
      | 1111    | 2.0             | 8.0             |                                                        |
      | 1111    | 1.0             | 1.0             |                                                        |
      | 1111    | 0.0             | 0.0             |                                                        |
      | 1111    | 0.0             | 0.0             |                                                        |
      | 2222    | 33.9            | 33.9            | sum for ten (of ten) displayed (both) values is 99.9   |
      | 2222    | 11.0            | 11.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 5.0             | 5.0             |                                                        |
      | 2222    | 0.0             | 0.0             |                                                        |
      | 2222    | 0.0             | 0.0             |                                                        |
      | 3333    | 0.0             | 0.0             | sum for five displayed (both) values is 100.0          |
      | 3333    | 0.0             | 0.0             |                                                        |
      | 3333    | 59.5            | 39.4            | portfolio mundane value: 59.4                          |
      | 3333    | 30.3            | 50.4            | benchmark mundane value: 50.3                          |
      | 3333    | 10.2            | 10.2            |                                                        |

  @IntegrationTest
  Scenario: mundane rounding for Portfolio Characteristics - does not need to sum to 100.0
    Given target tables contain the following Portfolio Characteristics section data
      | port id | portfolio value | benchmark value | comment                                  |
      | 1111    | 59.40000        | 59.40000        |                                          |
      | 1111    | 30.30001        | 30.30001        |                                          |
      | 1111    | 10.20001        | 10.20001        |                                          |
      | 1111    | 0.04999         | 0.04999         |                                          |
      | 1111    | 0.04999         | 0.04999         |                                          |
      | 2222    | 54.99999        | 54.99999        |                                          |
      | 2222    | 44.90003        | 44.90003        |                                          |
      | 2222    | 0.04999         | 0.04999         |                                          |
      | 2222    | 0.04999         | 0.04999         |                                          |
      | 3333    | 21.05000        | 20.05000        | portfolio and benchmark values different |
      | 3333    | 20.05000        | 21.05000        | portfolio and benchmark values different |
      | 3333    | 20.05000        | 20.05000        |                                          |
      | 3333    | 20.05000        | 20.05000        |                                          |
      | 3333    | 18.80000        | 18.80000        |                                          |
    When characteristics data are transferred
    Then reporting tables contain the following Portfolio Characteristics section data
      | port id | portfolio value | benchmark value | comment                |
      | 1111    | 59.4            | 59.4            |                        |
      | 1111    | 30.3            | 30.3            |                        |
      | 1111    | 10.2            | 10.2            |                        |
      | 1111    | 0.0             | 0.0             |                        |
      | 1111    | 0.0             | 0.0             |                        |
      | 2222    | 55.0            | 55.0            |                        |
      | 2222    | 44.9            | 44.9            |                        |
      | 2222    | 0.0             | 0.0             |                        |
      | 2222    | 0.0             | 0.0             |                        |
      | 3333    | 21.1            | 20.1            | portfolio not adjusted |
      | 3333    | 20.1            | 21.1            | benchmark not adjusted |
      | 3333    | 20.1            | 20.1            |                        |
      | 3333    | 20.1            | 20.1            |                        |
      | 3333    | 18.8            | 18.8            |                        |


	performancesummary
		performanceSummary.feature

@PerformanceSummary
Feature: Performance Summary functionality
  
  Specifications:
  1. Calculating Performance Summary values:
     a. read value from L2 (Target) table
     b. write value to L1 (Reporting) table
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for Performance Summary.
  2. Effective Date is a required input parameter.
  
  Definitions:
  1. Diff = Portfolio (Gross) - Bmk (Net)
  2. Required Performance Summary types 
  	a. Portfolio (Gross)
  	b. Bmk (Net)
  	c. Diff
  3. Optional Performance Summary types
  	a. Bmk (Div Return)
    b. Bmk (Price Return)
    c. Portfolio (Net)
    d. Bmk (Gross)
  4. Invalid Performance Summary types 
  	a. Any type name other than Required and Optional specified above  

  @IntegrationTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contain performance summary data for multiple port ids and multiple effective dates
    And one of the included performance summary effective date is targeted
    When performance summary data are transferred
    Then the performance summary data for the targeted effective dates are saved to reporting tables
    And no performance summary data for other effective dates are saved to reporting tables
    And data rounded off to 2 decimal places are saved to the reporting table
    And performance summary data with type name "Diff" are saved to the reporting table

  @IntegrationTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contain performance summary data for multiple port ids and multiple effective dates
    And one of the included performance summary effective date is targeted
    And one of the included performance summary port ids is targeted
    When performance summary data are transferred
    Then the performance summary data for the targeted effective date and port id are saved to reporting tables
    And no performance summary data for other effective dates or port ids are saved to reporting tables
    And data rounded off to 2 decimal places are saved to the reporting table
    And performance summary data with type name "Diff" are saved to the reporting table

  @IntegrationTest
  Scenario: no data found in the target table
    Given target tables contain no performance summary data
    And a performance summary effective date is targeted anyway
    And a performance summary port id is targeted anyway
    When performance summary data are transferred
    Then data with type name "Portfolio (Gross)" with NULL values are saved into report table
  	Then data with type name "Bmk (Net)" with NULL values are saved into report table  
  	Then data with type name "Diff" with NULL values are saved into report table

  @IntegrationTest
  Scenario: validate the performance summary type name
    Given target tables contain performance summary data for multiple port ids and multiple effective dates
    And one of the included performance summary effective date is targeted
    And one of the included performance summary port ids is targeted
    And target tables contain performance summary data with type name "Portfolio (Gross)"
    And target tables contain performance summary data with type name "Portfolio (GrossSSSS)"
    When performance summary data are transferred
    Then performance summary data with valid name "Portfolio (Gross)" are saved to reporting tables
    And performance summary data with invalid name "Portfolio (GrossSSSS)" are not saved to reporting tables
    
  @IntegrationTest
  Scenario: performance summary data in the reporting table should have required data
    Given target tables contain performance summary data for multiple port ids and multiple effective dates
    And target tables does not contain the required type name "Portfolio (Gross)"
    And one of the included performance summary effective date is targeted
    When performance summary data are transferred
    Then the performance summary data for the targeted effective dates are saved to reporting tables
    And performance summary data with null values for the type name "Portfolio (Gross)" is saved to the reporting table
    And performance summary data with null values are saved for the type name "Diff" 
    
  @IntegrationTest
  Scenario: performance summary data is rouded off to 2 decimal places
  	Given target tables contain performance summary data for multiple port ids and multiple effective dates
  	And target tables contains data for the required type name "Portfolio (Gross)" with value "10.0149999"
  	And target tables contains data for the required type name "Bmk (Net)" with value "10.0050000"
  	And one of the included performance summary effective date is targeted
  	When performance summary data are transferred
  	Then data are rounded off to 2 decimal places
  	Then data with type name "Portfolio (Gross)" with value 10.01 is saved into report table
  	Then data with type name "Bmk (Net)" with value 10.01 is saved into report table  
  	Then data with type name "Diff" with value 0.00 is saved into report table
  	
  @IntegrationTest
  Scenario Outline: drop optional records if all values are null 
  	Given target tables contain performance summary data for multiple port ids and multiple effective dates
  	And target tables contains data for the <optional row> with all values "null"
  	And one of the included performance summary effective date is targeted
  	And a performance summary port id is targeted anyway
  	When performance summary data are transferred
  	Then the data with type name <optional row> is not saved into the report table
  	
  Examples:
  | optional row       |
  | Bmk (Div Return)   |
  | Bmk (Price Return) |
  | Portfolio (Net)    |
  | Bmk (Gross)        |


  @EndToEndTest
  Scenario: transfer of performance summary values
    Given test performance summary data are loaded into target tables
    When transfer of performance summary data is requested
    Then the system indicates successful completion of the performance summary transfer
    And the test performance summary data are saved in reporting tables
    And the test performance summary data are cleaned up from the target tables
    And the test performance summary data are cleaned up from the reporting tables


	valuations
		brokerageAndTaxes.feature
@EquityIndex @BrokerageAndTaxes
Feature: Brokerage and Taxes
  
  Feature Files for Brokerage and Taxes/Fees (Report Sections)
  
  Specifications:
  1. Calculating brokerage and taxes values:
  a. read value from L2 (Target) table
  b. transformation as required, per brokerage and taxes type
  c. write value to L1 (Reporting) table
  
  2. Rules for transformation
    a.Amounts can only be positive 
    b.Values will be round up to a whole number  
    3.Null charge amount values will stay null
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for brokerage and taxes.
  2. AsOfDate is a required input parameter.

  @IntegrationTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contains positive and whole brokerage and taxes data for multiple port ids and multiple as of dates
    When brokerage and taxes data are transferred with as of date targeted
    Then the brokerage and taxes data for the targeted as of date are saved to reporting tables
    And no brokerage and taxes data for other as of dates are saved to reporting tables
    And the saved brokerage and taxes data exactly match the source data

  @IntegrationTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contains positive and whole brokerage and taxes data for multiple port ids and multiple as of dates
    When brokerage and taxes data are transferred with as of date and port id targeted
    Then the brokerage and taxes data for the targeted port id and as of date are saved to reporting tables
    And no brokerage and taxes data for other port ids or as of dates are saved to reporting tables

  @IntegrationTest
  Scenario: no data found is fine
    Given target tables contain no brokerage and taxes data
    When brokerage and taxes data are transferred with as of date targeted anyway
    Then no brokerage and taxes data are saved to reporting tables

  @IntegrationTest
  Scenario: Fund Charge amount is null in target table
    Given target tables contain a null value for fund charge amount
    When brokerage and taxes data are transferred
    Then fund charge amount in report table should be null

  @IntegrationTest
  Scenario: Update BrokerageAndTaxes data in report table
    Given target tables contains positive and whole brokerage and taxes data for multiple port ids and multiple as of dates
    And an active portfolio with the same portfolio code and as of date exists in the reporting table
    When brokerage and taxes data are transferred with as of date and port id targeted
    Then the existing record in the reporting table is end dated
    And the new record is saved into the reporting table

  @IntegrationTest
  Scenario: no data validation is done 
    Given target tables contains positive and whole brokerage and taxes data for multiple port ids and multiple as of dates
    And target tables contain brokerage and taxes data with value of 999999999999999999999
    When brokerage and taxes data are transferred with as of date targeted
    Then the brokerage and taxes data for the targeted as of date are saved to reporting tables
    And no brokerage and taxes data for other as of dates are saved to reporting tables
    And the saved brokerage and taxes data exactly match the source data
    And brokerage and taxes data with value of 999999999999999999999 are saved to reporting tables

  @IntegrationTest
  Scenario Outline: Rounding rules (Round half away from zero) 
    Given target table data has the value of <value>
    When brokerage and taxes data are transferred
    Then the value should be rounded to <displayed value>
    And the brokerage and taxes data are saved to reporting table

    Examples: Round half away from zero
      | value          | displayed value |
      | 1.50000000001  | 2               |
      | 1.5            | 2               |
      | 1.49999999999  | 1               |
      | .49            | 0               |
      | -1.49999999999 | -1              |
      | -.49           | 0               |
      | -1.5           | -2              |
      | -1.50000000001 | -2              |

  @EndToEndTest
  Scenario: transfer of brokerage and taxes values
    Given test brokerage and taxes data are loaded into target tables
    When transfer of brokerage and taxes data is requested
    Then the system indicates successful completion of the brokerage and taxes transfer
    And the test brokerage and taxes data are saved in reporting tables
    And the test brokerage and taxes data are cleaned up from the target tables
    And the test brokerage and taxes data are cleaned up from the reporting tables
		calculation.feature

@UnitTest
Feature: Calculation engine unit test

	Scenario: Run calculation engine without portfolio
	When user calls calculation resource without protfolio
	Then calculation engine is called
	

	Scenario Outline: Run calculation engine with portfolio 
	When user calls calculation resource portfolio <portfolio name>
	Then calculation engine is called with <portfolio name>
	
	 Examples: 
      | portfolio name 	|
      | ABC			   	|
      | DEF				|
	

	commentary.feature

@Commentary
Feature: User can create or update commentary for a mandate through a REST call.

  @EndToEndTest
  Scenario: Create commentary entry for a mandate
    Given a mandate exists in the product portal
    When commentary is added for a mandate on a specified date
    Then the system indicates successful completion of the commentary entry

  @EndToEndTest
  Scenario: Update a commentary entry for a mandate
    Given a commentary entry exists for a mandate on a specified date
    When commentary is added for a mandate on a specified date
    Then the system indicates successful completion of the commentary update

  @EndToEndTest
  Scenario: Retrieve commentary for a mandate
    Given a commentary entry exists for a mandate on a specified date
    When commentary is requested for a manadate on a specified date
    Then the system indicates successful completion of the commentary retrieval


	investmentObjective.feature

@EquityIndex @InvestmentObjective
Feature: File for Investment Objective (Report Sections)

  @IntegrationTest
  Scenario: Investment Objective for portfolio
    Given a portfolio with Investment Objective that exists in Product Portal
    When user runs the report service
    Then the table shall contain Investment Objective

  @IntegrationTest
  Scenario: Update Investment Objective in reporting table
    Given a portfolio with Investment Objective that exists in Product Portal
    And an active portfolio with the same portfolio code exists in the reporting table
    When user runs the report service
    Then the existing record in the report table is end dated
    And the new record is saved into the report table
 
  @EndToEndTest @IgnoreTest
  Scenario: transfer of Investment Objective value
    Given test Investment Objective data exists in Product Portal
    When transfer of Product Portal data is requested
    Then the system indicates successful completion of the Product Portal data transfer
    And the test investment objective value is saved in the reporting table


	portfolioActivity.feature

@EquityIndex @PortfolioActivity_PortfolioSummary
Feature: Portfolio Activity
  
  Feature Files for Portfolio Activity (Report Sections)
  
  Specifications:
  1. Calculating Portfolio Activity values:
  a. read value from L2 (Target) table
  b. transformation as required, per Portfolio Activity type
  c. write value to L1 (Reporting) table
  
  2. Rules for transformation
     
    a.Values will be round up to a whole number  
    b.Null charge amount values will stay null
    c.Portfolio values can be both positive and negative
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for Portfolio Activity.
  2. AsOfDate is a required input parameter.

  @IntegrationTest
  @IgnoreTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contains whole Portfolio Activity data for multiple port ids and multiple as of dates
    When Portfolio Activity data are transferred with as of date targeted
    Then the Portfolio Activity data for the targeted as of date are saved to reporting tables
    And no Portfolio Activity data for other as of dates are saved to reporting tables
    And the saved Portfolio Activity data exactly match the source data

  @IntegrationTest @IgnoreTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contains whole Portfolio Activity data for multiple port ids and multiple as of dates
    When Portfolio Activity data are transferred with as of date and port id targeted
    Then the Portfolio Activity data for the targeted port id and as of date are saved to reporting tables
    And no Portfolio Activity data for other port ids or as of dates are saved to reporting tables

  @IntegrationTest @IgnoreTest
  Scenario: no data found is fine
    Given target tables contain no Portfolio Activity data
    When Portfolio Activity data are transferred with as of date targeted anyway
    Then no Portfolio Activity data are saved to reporting tables

  @IntegrationTest @IgnoreTest
  Scenario: Portfolio Activity amount is null in target table
    Given target tables contain a null value for Portfolio Activity amount
    When Portfolio Activity data are transferred
    Then Portfolio Activity amount in report table should be null

  @IntegrationTest @IgnoreTest
  Scenario: Update Portfolio Activity data in report table
    Given target tables contains whole Portfolio Activity data for multiple port ids and multiple as of dates
    And an active portfolio with the same portfolio code and as of date exists in the reporting table
    When Portfolio Activity data are transferred with as of date and port id targeted
    Then the existing record in the report table is end dated
    And the new record is saved into the report table

  @IntegrationTest @IgnoreTest
  Scenario: no data validation is done
    Given target tables contains whole Portfolio Activity data for multiple port ids and multiple as of dates
    And target tables contain Portfolio Activity data with value of 999999999999999999999
    When Portfolio Activity data are transferred with as of date targeted
    Then the Portfolio Activity data for the targeted as of date are saved to reporting tables
    And no Portfolio Activity data for other as of dates are saved to reporting tables
    And the saved Portfolio Activity data exactly match the source data
    And Portfolio Activity data with value of 999999999999999999999 are saved to reporting tables

  @IntegrationTest @IgnoreTest
  Scenario Outline: Rounding rules (Round half away from zero)
    Given target table data has the value of <value>
    When Portfolio Activity data are transferred
    Then the value should be rounded to <displayed value>
    And the Portfolio Activity data are saved to reporting table

    Examples: Round half away from zero
      | value          | displayed value |
      | 1.50000000001  | 2               |
      | 1.5            | 2               |
      | 1.49999999999  | 1               |
      | .49            | 0               |
      | -1.49999999999 | -1              |
      | -.49           | 0               |
      | -1.5           | -2              |
      | -1.50000000001 | -2              |

  @EndToEndTest @IgnoreTest
  Scenario: transfer of Portfolio Activity values
    Given test Portfolio Activity data are loaded into target tables
    When transfer of Portfolio Activity data is requested
    Then the system indicates successful completion of the Portfolio Activity transfer
    And the test Portfolio Activity data are saved in reporting tables
    And the test Portfolio Activity data are cleaned up from the target tables
    And the test Portfolio Activity data are cleaned up from the reporting tables


	portfolioOverview.feature

@EquityIndex @PortfolioOverview
Feature: Portfolio Overview (Report Sections)

  @IntegrationTest
  Scenario: Portfolio Overview data load service
    Given a portfolio with the following attributes which exists in Product Portal
      | Product Code | Portfolio Manager       | Inception Date | Benchmark                             | Portfolio Currency |
      | ONE90        | Equity Investment Group | 08-Mar-2016    | S&P/ASX 300 A-REIT Accumulation Index | AUD                |
    When report service is run by user
    Then the table shall contain the following information
      | Product Code | Portfolio Manager       | Inception Date | Benchmark                             | Portfolio Currency |
      | ONE90        | Equity Investment Group | 08-Mar-2016    | S&P/ASX 300 A-REIT Accumulation Index | AUD                |

  @IntegrationTest
  Scenario: Update Portfolio Overview in reporting table
    Given a portfolio with the following attributes which exists in Product Portal
      | Product Code | Portfolio Manager       | Inception Date | Benchmark                             | Portfolio Currency |
      | ONE90        | Equity Investment Group | 08-Mar-2016    | S&P/ASX 300 A-REIT Accumulation Index | AUD                |
    And an active portfolio with the same product code exists in the report table
    When report service is run by user
    Then the table shall contain the following information
      | Product Code | Portfolio Manager       | Inception Date | Benchmark                             | Portfolio Currency |
      | ONE90        | Equity Investment Group | 08-Mar-2016    | S&P/ASX 300 A-REIT Accumulation Index | AUD                |
    And the existing records in the report table are end dated

  @EndToEndTest @IgnoreTest
  Scenario: transfer of portfolio overview values
    Given test portfolio overview data exists in Product Portal
    When transfer of Product Portal data is requested
    Then the system indicates successful completion of the Product Portal data transfer
    And the test Portfolio Overview values are saved in the reporting table


	reportHeader.feature

@EquityIndex @ReportHeader
Feature: Report Header (Report Section)

  @IntegrationTest
  Scenario Outline: Report Header data load service
    Given a portfolio with <Product Code> that has <Client Name> and <Mandate Name> which exists in Product Portal
    When report service is run by user for <Product Code>
    Then the table shall contain <Client Name> and <Mandate Name> for <Product Code>

  @IntegrationTest
  Scenario Outline: Update Report Header in reporting table
    Given a portfolio with <Product Code> that has <Client Name> and <Mandate Name> which exists in Product Portal
    And an active portfolio with the same <Product Code> product code exists in the reporting table
    When report service is run by user for <Product Code>
    Then the existing records in the report tables are end dated
    And the table shall contain <Client Name> and <Mandate Name> for <Product Code>

    Examples: 
      | Product Code | Client Name | Mandate Name                      |
      | CBUS39       | CBUS        | CBUS Australian Fixed Income Fund |

  @EndToEndTest @IgnoreTest 
  Scenario: transfer of Report Header values
    Given test Report Header data exists in Product Portal
    When transfer of Product Portal data is requested
    Then the system indicates successful completion of the Product Portal data transfer
    And the test report header values are saved in the reporting table


	riskSummaryLimits.feature

@IntegrationTest
Feature: Risk Summary (Report Sections)

  Scenario Outline: Limits for Portfolio with analytics
    Given a portfolio with <Analytic Type> and <portal limit> that exists in Product Portal
    When user runs the Risk Summary calculations
    Then the reporting table shall show <table limit>

    Examples: 
      | portal limit | table limit | Analytic Type               |
      | 5            | 0.05        | Ex Ante- Tracking Error     |
      | 10           | 0.1         | Ex Ante- Tracking Error     |
      | 0            | 0.0         | Ex Ante- Tracking Error     |
      | -10          | -0.1        | Ex Ante- Tracking Error     |
      | 5            | 0.05        | 1 yr Ex-Post Tracking Error |
      | 10           | 0.1         | 1 yr Ex-Post Tracking Error |
      | 0            | 0.0         | 1 yr Ex-Post Tracking Error |
      | -10          | -0.1        | 1 yr Ex-Post Tracking Error |
      | 5            | 0.05        | 3 yr Ex-Post Tracking Error |
      | 10           | 0.1         | 3 yr Ex-Post Tracking Error |
      | 0            | 0.0         | 3 yr Ex-Post Tracking Error |
      | -10          | -0.1        | 3 yr Ex-Post Tracking Error |

  Scenario Outline: Split Limits for Portfolio with Analytics
    Given a portfolio with <Analytic Type>, <portal lower limit>, <portal upper limit>, and <portal split limit> that exists in Product Portal
    When user runs the Risk Summary calculations
    Then the reporting table shall show <table lower limit> and <table upper limit> and <table split limit>

    Examples: 
      | portal lower limit | table lower limit | Analytic Type               | portal upper limit | table upper limit | portal split limit | table split limit |
      | 5                  | 0.05              | Ex Ante- Tracking Error     | 10                 | 0.1               | 50                 | 50                |
      | 10                 | 0.1               | Ex Ante- Tracking Error     | 20                 | 0.2               | 50                 | 50                |
      | 0                  | 0.0               | Ex Ante- Tracking Error     | 0                  | 0.0               | 50                 | 50                |
      | -10                | -0.1              | Ex Ante- Tracking Error     | -20                | -0.2              | 50                 | 50                |
      | 5                  | 0.05              | 1 yr Ex-Post Tracking Error | 10                 |                   | 50                 |                   |
      | 10                 | 0.1               | 1 yr Ex-Post Tracking Error | 20                 |                   | 50                 |                   |
      | 0                  | 0.0               | 1 yr Ex-Post Tracking Error | 0                  |                   | 50                 |                   |
      | -10                | -0.1              | 1 yr Ex-Post Tracking Error | -20                |                   | 50                 |                   |
      | 5                  | 0.05              | 3 yr Ex-Post Tracking Error | 10                 |                   | 50                 |                   |
      | 10                 | 0.1               | 3 yr Ex-Post Tracking Error | 20                 |                   | 50                 |                   |
      | 0                  | 0.0               | 3 yr Ex-Post Tracking Error | 0                  |                   | 50                 |                   |
      | -10                | -0.1              | 3 yr Ex-Post Tracking Error | -20                |                   | 50                 |                   |

  Scenario Outline: Update / delete risk summary limits
    Given a portfolio with <Analytic Type> and <portal limit> that exists in Product Portal
    And the same portfolio exists in the reporting table
    When user runs the Risk Summary calculations
    Then the existing reporting record should be end-dated
    And the reporting table shall show <table limit>

    Examples: 
      | portal limit | table limit | Analytic Type               |
      | 5            | 0.05        | Ex Ante- Tracking Error     |
      | 10           | 0.1         | Ex Ante- Tracking Error     |
      | 0            | 0.0         | Ex Ante- Tracking Error     |
      | -10          | -0.1        | Ex Ante- Tracking Error     |
      | 5            | 0.05        | 1 yr Ex-Post Tracking Error |
      | 10           | 0.1         | 1 yr Ex-Post Tracking Error |
      | 0            | 0.0         | 1 yr Ex-Post Tracking Error |
      | -10          | -0.1        | 1 yr Ex-Post Tracking Error |
      | 5            | 0.05        | 3 yr Ex-Post Tracking Error |
      | 10           | 0.1         | 3 yr Ex-Post Tracking Error |
      | 0            | 0.0         | 3 yr Ex-Post Tracking Error |
      | -10          | -0.1        | 3 yr Ex-Post Tracking Error |

  @EndToEndTest @IgnoreTest
  Scenario: transfer of Risk Summary values
    Given test Risk Summary data exists in Product Portal
    When transfer of Product Portal data is requested
    Then the system indicates successful completion of the Product Portal data transfer
    And the calculated Risk Summary data is saved in the reporting table


	riskSummaryPortfolio.feature

@RiskSummaryPortfolio
Feature: Risk Summary functionality
  
  Specifications:
  1. Calculating Risk Summary values:
     a. read value from L2 (Target) table
     b. write value to L1 (Reporting) table
  
   
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for Risk Summary.
  2. Effective Date is a required input parameter.
  
  Definitions:
  1. Required Risk Analytic types
     a. Ex-Ante Tracking Error
     b. 1yr Ex- Post Tracking Error
     c. 3yr Ex- Post Tracking Error
     d. 1yr Standard Deviation
     e. 3yr Standard Deviation

  
  2. Invalid Risk Analytic types 
  	a. Any type name other than Required above

  @IntegrationTest @IgnoreTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contain risk summary data for multiple port ids and multiple effective dates
    And one of the included risk summary effective date is targeted
    When risk summary data are transferred
    Then the risk summary data for the targeted effective dates are saved to reporting tables
    And no risk summary data for other effective dates are saved to reporting tables
    And data rounded off to 2 decimal places are saved to the reporting table
   

  @IntegrationTest  @IgnoreTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contain risk summary data for multiple port ids and multiple effective dates
    And one of the included risk summary effective date is targeted
    And one of the included risk summary port ids is targeted
    When risk summary data are transferred
    Then the risk summary data for the targeted effective date and port id are saved to reporting tables
    And no risk summary data for other effective dates or port ids are saved to reporting tables
    And data rounded off to 2 decimal places are saved to the reporting table
    

  @IntegrationTest  @IgnoreTest
  Scenario: no data found in the target table
    Given target tables contain no risk summary data
    And a risk summary effective date is targeted anyway
    And a risk summary port id is targeted anyway
    When risk summary data are transferred
    Then data with type name "Ex-Ante Tracking Error" with NULL values are saved into report table
  	Then data with type name "1yr Ex- Post Tracking Error" with NULL values are saved into report table  
  	Then data with type name "3yr Ex- Post Tracking Error" with NULL values are saved into report table
        Then data with type name  " 1yr Standard Deviation" with NULL values are saved into report table
        Then data with type name "3yr Standard Deviation" with NULL values are saved into report table
       

  @IntegrationTest  @IgnoreTest
  Scenario: validate the risk summary type name
    Given target tables contain risk summary data for multiple port ids and multiple effective dates
    And target tables contain risk summary data with type name "Ex-Ante Tracking Error"
    And target tables contain risk summary data with type name "Ex-Ante Tracking Errorrrrrrr"
    And one of the included effective dates is targeted
    When risk summary data are transferred
    Then risk summary data with valid name "Ex-Ante Tracking Error" are saved to reporting tables
    And risk summary data with invalid name "Ex-Ante Tracking Errorrrrrr" are not saved to reporting tables
    
  @IntegrationTest  @IgnoreTest
  Scenario: risk summary data in the reporting table should have required data
    Given target tables contain risk summary data for multiple port ids and multiple effective dates
    And target tables does not contain the required type name "Ex-Ante Tracking Error"
    And one of the included effective dates is targeted
    When risk summary data are transferred
    Then the risk summary data for the targeted effective dates are saved to reporting tables
    And risk summary data with null values for the type name "Ex-Ante Tracking Error" is saved to the reporting table
     
    
  @IntegrationTest  @IgnoreTest
  Scenario: risk summary data is rouded off to 2 decimal places
  	Given target tables contain risk summary data for multiple port ids and multiple effective dates
  	And target tables contains data for the required type name "Ex-Ante Tracking Error" with value ".0149999"
  	And target tables contains data for the required type name "1yr Ex- Post Tracking Error" with value ".0050000"
  	When risk summary data are transferred
  	Then data are rounded off to 2 decimal places
  	Then data with type name "Ex-Ante Tracking Error" with value .01 is saved into report table
  	Then data with type name "1yr Ex- Post Tracking Error" with value .01 is saved into report table  
  	

  @EndToEndTest  @IgnoreTest
  Scenario: transfer of risk summary values
    Given test risk summary data are loaded into target tables
    When transfer of risk summary data is requested
    Then the system indicates successful completion of the risk summary transfer
    And the test risk summary data are saved in reporting tables
    And the test risk summary data are cleaned up from the target tables
    And the test risk summary data are cleaned up from the reporting tables

	security.feature

@Security
Feature: security and permissions functionality
  
  Specifications:
  1. 
  
  Assumptions:
  1. We will have one or more SBFs that grant permission to transfer data.
  
  Definitions:
  1. IgnoreTest - eventually we will implement this

  @EndToEndTest @IgnoreTest
  Scenario: user has permission to transfer data
    Given test data are loaded into target tables
    And a user with valid permission to request transfer of data
    When transfer of data is requested
    Then the system indicates successful completion of the transfer
    And the test data are saved in reporting tables
    And the test data are cleaned up from the target tables
    And the test data are cleaned up from the reporting tables

  @EndToEndTest @IgnoreTest
  Scenario: negative test - user without permission to transfer data
    Given test data are loaded into target tables
    And a user without valid permission to request transfer of data
    When transfer of data is requested
    Then the system indicates failure due to no permission
    And the test data are not saved in reporting tables
    And the test data are cleaned up from the target tables
						
