---------------------------------------
src main java


com.vanguard.corp.ics.dao.target
	FakeAttributionSummaryDAO.java

package com.vanguard.corp.ics.dao.target;

import java.math.BigDecimal;
import java.util.Date;

public class FakeAttributionSummaryDAO {
	
	private String portId;
	private Date effectiveDate;
	private String name;
	private BigDecimal oneMonthVal;
	private BigDecimal thrMonthVal;
	private BigDecimal sixMonthVal;
	private BigDecimal nineMonthVal;
	private BigDecimal twlveMonthVal;
	private BigDecimal yyToDTVal;
	private String lastUpdatedUserId;
	private Date effectiveBeginDate;
	private Date effectiveEndDate;
	private Date lastUpdatedDate;
	

	private Long id;
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getPortId() {
		return portId;
	}
	public void setPortId(String portId) {
		this.portId = portId;
	}
	public Date getEffectiveDate() {
		return effectiveDate;
	}
	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = effectiveDate;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public BigDecimal getOneMonthVal() {
		return oneMonthVal;
	}
	public void setOneMonthVal(BigDecimal oneMonthVal) {
		this.oneMonthVal = oneMonthVal;
	}
	public BigDecimal getThrMonthVal() {
		return thrMonthVal;
	}
	public void setThrMonthVal(BigDecimal thrMonthVal) {
		this.thrMonthVal = thrMonthVal;
	}
	public BigDecimal getSixMonthVal() {
		return sixMonthVal;
	}
	public void setSixMonthVal(BigDecimal sixMonthVal) {
		this.sixMonthVal = sixMonthVal;
	}
	public BigDecimal getNineMonthVal() {
		return nineMonthVal;
	}
	public void setNineMonthVal(BigDecimal nineMonthVal) {
		this.nineMonthVal = nineMonthVal;
	}
	public BigDecimal getTwlveMonthVal() {
		return twlveMonthVal;
	}
	public void setTwlveMonthVal(BigDecimal twlveMonthVal) {
		this.twlveMonthVal = twlveMonthVal;
	}
	public BigDecimal getYyToDTVal() {
		return yyToDTVal;
	}
	public void setYyToDTVal(BigDecimal yyToDTVal) {
		this.yyToDTVal = yyToDTVal;
	}
	
	public String getLastUpdatedUserId() {
		return lastUpdatedUserId;
	}
	public void setLastUpdatedUserId(String lastUpdatedUserId) {
		this.lastUpdatedUserId = lastUpdatedUserId;
	}
	public Date getEffectiveBeginDate() {
		return effectiveBeginDate;
	}
	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = effectiveBeginDate;
	}
	public Date getEffectiveEndDate() {
		return effectiveEndDate;
	}
	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = effectiveEndDate;
	}
	public Date getLastUpdatedDate() {
		return lastUpdatedDate;
	}
	public void setLastUpdatedDate(Date lastUpdatedDate) {
		this.lastUpdatedDate = lastUpdatedDate;
	}
	
	
	
	

}


com.vanguard.corp.ics.repository.target
	FakeAttributionSummaryRepository.java


package com.vanguard.corp.ics.repository.target;

import java.util.Date;
import java.util.List;

import com.vanguard.corp.ics.dao.target.FakeAttributionSummaryDAO;

public interface FakeAttributionSummaryRepository {
	
	List<FakeAttributionSummaryDAO> findAllByeffectiveDate(Date effectiveDate);

	List<FakeAttributionSummaryDAO> findAllByeffectiveDateAndPortId(Date effectiveDate, String portId);

}


	FakeAttributionSummaryRepositoryImpl.java


package com.vanguard.corp.ics.repository.target;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

import com.vanguard.corp.ics.dao.target.FakeAttributionSummaryDAO;

public class FakeAttributionSummaryRepositoryImpl implements FakeAttributionSummaryRepository  {
	
	private Map<Date, Map<String, Queue<FakeAttributionSummaryDAO>>> dateMap = new ConcurrentHashMap<>(64);
	private Random generator = new Random((new Date()).getTime());

	@Override
	public List<FakeAttributionSummaryDAO> findAllByeffectiveDate(final Date effectiveDate) {
		Map<String, Queue<FakeAttributionSummaryDAO>> portIdMap = getDateMap(effectiveDate);
		loadDefaultPortIdQueues(portIdMap, effectiveDate);

		final List<FakeAttributionSummaryDAO> attributionSummary = new ArrayList<>();

		Iterator<String> iterator = portIdMap.keySet().iterator();
		while (iterator.hasNext()) {
			attributionSummary .addAll(portIdMap.get(iterator.next()));
		}
		return attributionSummary ;
	}
	
	
	@Override
	public List<FakeAttributionSummaryDAO> findAllByeffectiveDateAndPortId(final Date effectiveDate, final String portId) {
		Map<String, Queue<FakeAttributionSummaryDAO>> portIdMap = getDateMap(effectiveDate);
		loadDefaultPortIdQueues(portIdMap, effectiveDate);
		Queue<FakeAttributionSummaryDAO> found = getPortIdQueue(portIdMap, effectiveDate, portId);

		return new ArrayList<>(found);
	}
	
	private Queue<FakeAttributionSummaryDAO> getPortIdQueue(final Map<String, Queue<FakeAttributionSummaryDAO>> portIdMap, final Date asOfDate, final String portfolioCode) {
		Queue<FakeAttributionSummaryDAO> found = portIdMap.get(portfolioCode);
		if (found == null) {
			found = buildAttributionSummaryQueue(asOfDate, portfolioCode);
			portIdMap.put(portfolioCode, found);
		}
		return found;
	}
	
	
	private Map<String, Queue<FakeAttributionSummaryDAO>> getDateMap(final Date effectiveDate) {
		Map<String, Queue<FakeAttributionSummaryDAO>> portIdMap = dateMap.get(effectiveDate);
		if (portIdMap == null) {
			portIdMap = new HashMap<>();
			dateMap.put(effectiveDate, portIdMap);
		}
		return portIdMap;
	}
	
	private void loadDefaultPortIdQueues(final Map<String, Queue<FakeAttributionSummaryDAO>> portIdMap, final Date effectiveDate) {
		if (portIdMap.isEmpty()) {
			portIdMap.put("TEST01", buildAttributionSummaryQueue(effectiveDate, "TEST01"));
			portIdMap.put("TEST02", buildAttributionSummaryQueue(effectiveDate, "TEST02"));
		}
	}
	
	private Queue<FakeAttributionSummaryDAO> buildAttributionSummaryQueue(final Date effectiveDate, final String portId) {
		Queue<FakeAttributionSummaryDAO> fakeAttributionSummaryDAO = new ConcurrentLinkedQueue<>();

		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Stock Selection Impact", Integer.MAX_VALUE));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Futures Impact", Integer.MAX_VALUE));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Liquidity Management Impact", Integer.MAX_VALUE));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Security Price Execution", 100));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Trading Cost", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Currency Price Execution", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Dividend Withholding Impact", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Security Lending Income", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Mgm't & Custody Fees", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Substitutes Impact", 100));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Restrictions Impact", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Internal Liquidity", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Residual", 5000));
		fakeAttributionSummaryDAO.add(buildAttributionSummary(effectiveDate, portId,"Fake Attribution Summary", 5000));
		return fakeAttributionSummaryDAO;
	}
	
	private FakeAttributionSummaryDAO buildAttributionSummary(final Date effectiveDate, final String portId, final String name, final int max) {
		FakeAttributionSummaryDAO c = new FakeAttributionSummaryDAO();
		c.setId(generator.nextLong());
		c.setEffectiveDate(effectiveDate);
		c.setPortId(portId);
		c.setName(name);
		c.setThrMonthVal(getRandomBigDecimal(max));
		c.setSixMonthVal(getRandomBigDecimal(max));
		c.setNineMonthVal(getRandomBigDecimal(max));
		c.setTwlveMonthVal(getRandomBigDecimal(max));
		c.setYyToDTVal(getRandomBigDecimal(max));
		return c;
	}

	private BigDecimal getRandomBigDecimal(final int max) {
		double val = generator.nextDouble() * 2.0 * (double) max;
		val -= max;
		return new BigDecimal(String.format("%.5f", val));
	}
	
	

}



com.vanguard.corp.ics.sdt.dao.api.constants
	DatabaseConstants.java

package com.vanguard.corp.ics.sdt.dao.api.constants;

public interface DatabaseConstants {

	public static final String PORTFOLIO_VALUATION_TYPE_CODE_CURRENT = "CurrentM";

}


	RestServiceConstants.java


package com.vanguard.corp.ics.sdt.dao.api.constants;

public interface RestServiceConstants {

	public static final String PRODUCT_PORTAL_INCEPTION_DATE_FORMAT = "dd-MMM-yyyy";
}



com.vanguard.corp.ics.sdt.dao.api.domain.portal


package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class Currency implements Serializable {

	private static final long serialVersionUID = -7830143657509915836L;

	private Long currencyId;

	private String currencyCode;

	private String currencyName;

	public Long getCurrencyId() {
		return currencyId;
	}

	public void setCurrencyId(Long currencyId) {
		this.currencyId = currencyId;
	}

	public String getCurrencyCode() {
		return currencyCode;
	}

	public void setCurrencyCode(String currencyCode) {
		this.currencyCode = currencyCode;
	}

	public String getCurrencyName() {
		return currencyName;
	}

	public void setCurrencyName(String currencyName) {
		this.currencyName = currencyName;
	}

}

	InvestmentGroup.java


package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class InvestmentGroup implements Serializable {

	private static final long serialVersionUID = -7578991813592252231L;

	private Long investmentGroupId;
	
	private String investmentGroupCode;
	
	private String investmentGroupName;

	public Long getInvestmentGroupId() {
		return investmentGroupId;
	}

	public void setInvestmentGroupId(Long investmentGroupId) {
		this.investmentGroupId = investmentGroupId;
	}

	public String getInvestmentGroupCode() {
		return investmentGroupCode;
	}

	public void setInvestmentGroupCode(String investmentGroupCode) {
		this.investmentGroupCode = investmentGroupCode;
	}

	public String getInvestmentGroupName() {
		return investmentGroupName;
	}

	public void setInvestmentGroupName(String investmentGroupName) {
		this.investmentGroupName = investmentGroupName;
	}

}


	PortalProduct.java


package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonFormat.Shape;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class PortalProduct {

	private Long productID;

	private Long productTypeID;

	private String productName;

	private String clientID;

	private String productCode;

	private String investmentStyleID;

	private Long assetClassID;

	private Long investmentMarketID;
	
	private String investmentObjective;

	private Long investmentGroupID;

	private Long baseCurrencyID;

	private Long hedgeTypeID;

	private Double hedgePercentage;

	private Long hedgeCurrencyID;

	private Long benchMarkProviderID;

	private String benchMarkName;

	private Long custodianID;

	private Long futuresClearingAgentID;

	private Double initialAUM;

	private Long initialAUMCurrencyID;

	private String perfInceptionDate;
	
	private Long productFundingTypeID;

	private Long investmentManagementEntityID;

	private Long contactingEntityID;

	private Long salesTeamEntityID;

	private String targetLaunchDate;

	private Long statusID;

	private String modifiedBy;
	
	private Currency currency;
	
	private InvestmentGroup investmentGroup;

	private String exAnteMaxBreachIMA;
	
	private String exPostMaxBreachIMA;
	
	private Double exAnteFumSplitLimit;
	
	private String exAnteMaxBreachIMAAbvLmt;

	@JsonFormat(shape = Shape.STRING, pattern = "yyyy-MM-dd")
	private LocalDate modifiedDate;

	public Long getProductID() {
		return productID;
	}

	public void setProductID(Long productID) {
		this.productID = productID;
	}

	public Long getProductTypeID() {
		return productTypeID;
	}

	public void setProductTypeID(Long productTypeID) {
		this.productTypeID = productTypeID;
	}

	public String getProductName() {
		return productName;
	}

	public void setProductName(String productName) {
		this.productName = productName;
	}

	public String getClientID() {
		return clientID;
	}

	public void setClientID(String clientID) {
		this.clientID = clientID;
	}

	public String getProductCode() {
		return productCode;
	}

	public void setProductCode(String productCode) {
		this.productCode = productCode;
	}

	public String getInvestmentStyleID() {
		return investmentStyleID;
	}

	public void setInvestmentStyleID(String investmentStyleID) {
		this.investmentStyleID = investmentStyleID;
	}

	public Long getAssetClassID() {
		return assetClassID;
	}

	public void setAssetClassID(Long assetClassID) {
		this.assetClassID = assetClassID;
	}

	public Long getInvestmentMarketID() {
		return investmentMarketID;
	}

	public void setInvestmentMarketID(Long investmentMarketID) {
		this.investmentMarketID = investmentMarketID;
	}
	
	public String getInvestmentObjective() {
		return investmentObjective;
	}
	
	public void setInvestmentObjective(String investmentObjective) {
		this.investmentObjective = investmentObjective;
	}

	public Long getInvestmentGroupID() {
		return investmentGroupID;
	}

	public void setInvestmentGroupID(Long investmentGroupID) {
		this.investmentGroupID = investmentGroupID;
	}

	public Long getBaseCurrencyID() {
		return baseCurrencyID;
	}

	public void setBaseCurrencyID(Long baseCurrencyID) {
		this.baseCurrencyID = baseCurrencyID;
	}

	public Long getHedgeTypeID() {
		return hedgeTypeID;
	}

	public void setHedgeTypeID(Long hedgeTypeID) {
		this.hedgeTypeID = hedgeTypeID;
	}

	public Double getHedgePercentage() {
		return hedgePercentage;
	}

	public void setHedgePercentage(Double hedgePercentage) {
		this.hedgePercentage = hedgePercentage;
	}

	public Long getHedgeCurrencyID() {
		return hedgeCurrencyID;
	}

	public void setHedgeCurrencyID(Long hedgeCurrencyID) {
		this.hedgeCurrencyID = hedgeCurrencyID;
	}

	public Long getBenchMarkProviderID() {
		return benchMarkProviderID;
	}

	public void setBenchMarkProviderID(Long benchMarkProviderID) {
		this.benchMarkProviderID = benchMarkProviderID;
	}

	public String getBenchMarkName() {
		return benchMarkName;
	}

	public void setBenchMarkName(String benchMarkName) {
		this.benchMarkName = benchMarkName;
	}

	public Long getCustodianID() {
		return custodianID;
	}

	public void setCustodianID(Long custodianID) {
		this.custodianID = custodianID;
	}

	public Long getFuturesClearingAgentID() {
		return futuresClearingAgentID;
	}

	public void setFuturesClearingAgentID(Long futuresClearingAgentID) {
		this.futuresClearingAgentID = futuresClearingAgentID;
	}

	public Double getInitialAUM() {
		return initialAUM;
	}

	public void setInitialAUM(Double initialAUM) {
		this.initialAUM = initialAUM;
	}

	public Long getInitialAUMCurrencyID() {
		return initialAUMCurrencyID;
	}

	public void setInitialAUMCurrencyID(Long initialAUMCurrencyID) {
		this.initialAUMCurrencyID = initialAUMCurrencyID;
	}

	public String getPerfInceptionDate() {
		return perfInceptionDate;
	}
	
	public void setPerfInceptionDate(String perfInceptionDate) {
		this.perfInceptionDate = perfInceptionDate;
	}
	
	public Long getProductFundingTypeID() {
		return productFundingTypeID;
	}

	public void setProductFundingTypeID(Long productFundingTypeID) {
		this.productFundingTypeID = productFundingTypeID;
	}

	public Long getInvestmentManagementEntityID() {
		return investmentManagementEntityID;
	}

	public void setInvestmentManagementEntityID(Long investmentManagementEntityID) {
		this.investmentManagementEntityID = investmentManagementEntityID;
	}

	public Long getContactingEntityID() {
		return contactingEntityID;
	}

	public void setContactingEntityID(Long contactingEntityID) {
		this.contactingEntityID = contactingEntityID;
	}

	public Long getSalesTeamEntityID() {
		return salesTeamEntityID;
	}

	public void setSalesTeamEntityID(Long salesTeamEntityID) {
		this.salesTeamEntityID = salesTeamEntityID;
	}

	public String getTargetLaunchDate() {
		return targetLaunchDate;
	}

	public void setTargetLaunchDate(String targetLaunchDate) {
		this.targetLaunchDate = targetLaunchDate;
	}

	public Long getStatusID() {
		return statusID;
	}

	public void setStatusID(Long statusID) {
		this.statusID = statusID;
	}

	public String getModifiedBy() {
		return modifiedBy;
	}

	public void setModifiedBy(String modifiedBy) {
		this.modifiedBy = modifiedBy;
	}

	public LocalDate getModifiedDate() {
		return modifiedDate;
	}

	public void setModifiedDate(LocalDate modifiedDate) {
		this.modifiedDate = modifiedDate;
	}

	public void setModifiedDate(String modifiedDate) {
		setModifiedDate(LocalDate.parse(modifiedDate, DateTimeFormatter.ISO_LOCAL_DATE));
	}

	public Currency getCurrency() {
		return currency;
	}

	public void setCurrency(Currency currency) {
		this.currency = currency;
	}
	
	public InvestmentGroup getInvestmentGroup() {
		return investmentGroup;
	}

	public void setInvestmentGroup(InvestmentGroup investmentGroup) {
		this.investmentGroup = investmentGroup;
	}
	
	public String getExAnteMaxBreachIMA() {
		return exAnteMaxBreachIMA;
	}

	public void setExAnteMaxBreachIMA(String exAnteMaxBreachIMA) {
		this.exAnteMaxBreachIMA = exAnteMaxBreachIMA;
	}

	public String getExPostMaxBreachIMA() {
		return exPostMaxBreachIMA;
	}

	public void setExPostMaxBreachIMA(String exPostMaxBreachIMA) {
		this.exPostMaxBreachIMA = exPostMaxBreachIMA;
	}

	public Double getExAnteFumSplitLimit() {
		return exAnteFumSplitLimit;
	}

	public void setExAnteFumSplitLimit(Double exAnteFumSplitLimit) {
		this.exAnteFumSplitLimit = exAnteFumSplitLimit;
	}

	public String getExAnteMaxBreachIMAAbvLmt() {
		return exAnteMaxBreachIMAAbvLmt;
	}

	public void setExAnteMaxBreachIMAAbvLmt(String exAnteMaxBreachIMAAbvLmt) {
		this.exAnteMaxBreachIMAAbvLmt = exAnteMaxBreachIMAAbvLmt;
	}
}

com.vanguard.corp.ics.sdt.dao.api.portal

	PortalProductService.java


package com.vanguard.corp.ics.sdt.dao.api.portal;

import java.util.List;

import javax.servlet.http.HttpServletRequest;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;

public interface ProductPortalService {

	public List<PortalProduct> getProducts(HttpServletRequest request);
	
	public PortalProduct getProduct(List<PortalProduct> products, String productCode);
	
	public Currency getProductCurrency(PortalProduct product, HttpServletRequest request);
	
	public InvestmentGroup getInvestmentGroup(PortalProduct product, HttpServletRequest request);
}

com.vanguard.corp.ics.sdt.dao.impl.config
	PortalConfiguration.java	




package com.vanguard.corp.ics.sdt.dao.impl.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PortalConfiguration {

	@Value("$sma-data-transformer.webservice-{portal.products.endpoint}")
	private String portalProductEndpoint;

	@Value("$sma-data-transformer.webservice-{portal.references.endpoint}")
	private String portalReferenceEndpoint;

	@Value("$sma-data-transformer.webservice-{portal.maxConnectionAttempts}")
	private int maxConnectionAttempts;

	public String getPortalProductEndpoint() {
		return portalProductEndpoint;
	}

	public void setPortalProductEndpoint(String portalProductEndpoint) {
		this.portalProductEndpoint = portalProductEndpoint;
	}

	public String getPortalReferenceEndpoint() {
		return portalReferenceEndpoint;
	}

	public void setPortalReferenceEndpoint(String portalReferenceEndpoint) {
		this.portalReferenceEndpoint = portalReferenceEndpoint;
	}

	public int getMaxConnectionAttempts() {
		return maxConnectionAttempts;
	}

	public void setMaxConnectionAttempts(int attempts) {
		this.maxConnectionAttempts = attempts;
	}

}

	ReportingDatabaseConfiguration.java



package com.vanguard.corp.ics.sdt.dao.impl.config;

import java.util.Properties;

import org.apache.tomcat.jdbc.pool.DataSource;
import org.apache.tomcat.jdbc.pool.PoolProperties;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories(basePackages = { "com.vanguard.corp.ics.repository", "com.vanguard.corp.ics.sdt.dao.impl.repository" }, entityManagerFactoryRef = "reportingEntityManagerFactory", transactionManagerRef = "reportingTransactionManager")
@EnableTransactionManagement
public class ReportingDatabaseConfiguration {

	@Value("$sma-data-transformer.webservice-{sdt.datasource.reportingConnectionURL}")
	private String sdtReportingConnectionUrl;

	@Value("$sma-data-transformer.webservice-{sdt.datasource.reportingUsername}")
	private String sdtDataSourceReportingUsername;

	@Value("$sma-data-transformer.webservice-{sdt.datasource.reportingPassword}")
	private String sdtDataSourceReportingPassword;

	@Bean(name = "reportingEntityManagerFactory")
	public LocalContainerEntityManagerFactoryBean getReportingEntityManagerFactory() {

		LocalContainerEntityManagerFactoryBean reportingEntityManagerFactory = new LocalContainerEntityManagerFactoryBean();
		reportingEntityManagerFactory.setPersistenceUnitName("GRMDB");
		reportingEntityManagerFactory.setDataSource(dataSource());
		reportingEntityManagerFactory.setJpaVendorAdapter(hibernateJpaVendorAdapter());
		reportingEntityManagerFactory.setPackagesToScan(new String[] { "com.vanguard.corp.ics.dao", "com.vanguard.corp.ics.sdt.dao.impl.entity" });
		
		//TODO Read property values from RTE properties.
		Properties jpaProperties = new Properties();
		jpaProperties.put("hibernate.dialect", "org.hibernate.dialect.Oracle10gDialect");
		jpaProperties.put("hibernate.show_sql", "true");
		jpaProperties.put("hibernate.format_sql", "true");
		jpaProperties.put("hibernate.use_sql_comments", "false");
		jpaProperties.put("hibernate.enable_lazy_load_no_trans", "true");

		reportingEntityManagerFactory.setJpaProperties(jpaProperties);

		return reportingEntityManagerFactory;
	}

	@Bean
	public DataSource dataSource() {

		PoolProperties poolProperties = new PoolProperties();
		poolProperties.setUrl(sdtReportingConnectionUrl);
		poolProperties.setDriverClassName("oracle.jdbc.OracleDriver");
		poolProperties.setUsername(sdtDataSourceReportingUsername);
		poolProperties.setPassword(sdtDataSourceReportingPassword);
		poolProperties.setDefaultAutoCommit(false);
		poolProperties.setDefaultReadOnly(false);
		poolProperties.setDefaultTransactionIsolation(2);
		poolProperties.setJmxEnabled(false);
		poolProperties.setTestWhileIdle(true);
		poolProperties.setTestOnBorrow(true);
		poolProperties.setValidationQuery("SELECT 1 FROM DUAL");
		poolProperties.setTestOnReturn(false);
		poolProperties.setValidationInterval(30000);
		poolProperties.setTimeBetweenEvictionRunsMillis(30000);
		poolProperties.setMaxActive(1000);
		poolProperties.setInitialSize(5);
		poolProperties.setMaxWait(10000);
		poolProperties.setRemoveAbandonedTimeout(30);
		poolProperties.setMinEvictableIdleTimeMillis(30000);
		poolProperties.setMinIdle(10);
		poolProperties.setLogAbandoned(true);
		poolProperties.setRemoveAbandoned(true);
		poolProperties.setJdbcInterceptors("org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;"
				+ "org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");

		DataSource dataSource = new DataSource();
		dataSource.setPoolProperties(poolProperties);

		return dataSource;
	}

	@Bean
	public HibernateJpaVendorAdapter hibernateJpaVendorAdapter() {

		return new HibernateJpaVendorAdapter();
	}

	@Bean(name = "reportingTransactionManager")
	public PlatformTransactionManager transactionManager() {
		JpaTransactionManager tm = new JpaTransactionManager();
		tm.setEntityManagerFactory(getReportingEntityManagerFactory().getObject());
		tm.setDataSource(dataSource());

		return tm;
	}
}

com.vanguard.corp.ics.sdt.dao.impl.entity.report
	AccountBenchmarkAssociation.java	


package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.DAO;

@Entity
@Table(name = "GMRADM.TACCT_BCHMRK_ASSOCN")
public class AccountBenchmarkAssociation implements DAO<Long> {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1ACCTBCHMRKASSOCNID")
	@SequenceGenerator(name = "GMRADM.SEQ1ACCTBCHMRKASSOCNID", sequenceName = "GMRADM.SEQ1ACCTBCHMRKASSOCNID", initialValue = 1, allocationSize = 1)
	@Column(name = "ACCT_BCHMRK_ASSOCN_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;
	
	@Column(name = "BCHMRK_EIP_ID")
	private String benchmarkEipId;
	
	@Column(name = "BCHMRK_ASSOCN_TYP")
	private String benchmarkAssociationType;
	
	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String updatedUser;
	
	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;
	
	@Column(name = "BCHMRK_NM")
	private String benchmarkName;

	@Override
	public Long getId() {
		return id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	public String getPortfolioId() {
		return portfolioId;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

	public String getBenchmarkEipId() {
		return benchmarkEipId;
	}

	public void setBenchmarkEipId(String benchmarkEipId) {
		this.benchmarkEipId = benchmarkEipId;
	}

	public String getBenchmarkAssociationType() {
		return benchmarkAssociationType;
	}

	public void setBenchmarkAssociationType(String benchmarkAssociationType) {
		this.benchmarkAssociationType = benchmarkAssociationType;
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}

	public Date getUpdatedDate() {
		return updatedDate;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = updatedDate;
	}

	public String getBenchmarkName() {
		return benchmarkName;
	}

	public void setBenchmarkName(String benchmarkName) {
		this.benchmarkName = benchmarkName;
	}

}

	AccountFund.java



package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.DAO;

@Entity
@Table(name = "GMRADM.TACCT_FND")
public class AccountFund implements DAO<Long> {
	
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1ACCTFNDID")
	@SequenceGenerator(name = "GMRADM.SEQ1ACCTFNDID", sequenceName = "GMRADM.SEQ1ACCTFNDID", initialValue = 1, allocationSize = 1)
	@Column(name = "ACCT_FND_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;

	@Column(name = "ACCT_NM", nullable = false)
	private String accountName;
	
	@Column(name = "ACCT_SHRT_NM", nullable = false)
	private String accountShortName;
	
	@Column(name = "ACCT_TYP_CD", nullable = false)
	private String accountType;
	
	@Column(name = "ASSET_CLASSFN_ID", nullable = false)
	private Long assetClassificationId;
	
	@Column(name = "EIP_ID", nullable = false)
	private double productEipID;

	@Column(name = "PORT_MGR", nullable = false)
	private String portfolioManager;
	
	@Column(name = "MGMT_STRTGY", nullable = true)
	private String managementStrategy;
	
	@Column(name = "CURRCY_CD", nullable = false)
	private String portfolioBaseCurrency;
	
	@Column(name = "INCPT_DT", nullable = false)
	private Date inceptionDate;
	
	@Column(name = "PORT_SZ_NO", nullable = true)
	private Long portfolioSize;
	
	@Column(name = "PORT_MGR_ID", nullable = false)
	private Long portfolioManagerId;
	
	@Column(name = "INV_OBJ_DESC", nullable = false)
	private String investmentObjective;
	
	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String updatedUser;
	
	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;
	
	@Override
	public Long getId() {
		return id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}
	
	public String getPortfolioId() {
		return portfolioId;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

	public String getAccountName() {
		return accountName;
	}

	public void setAccountName(String accountName) {
		this.accountName = accountName;
	}
	
	public String getAccountShortName() {
		return accountShortName;
	}

	public void setAccountShortName(String accountShortName) {
		this.accountShortName = accountShortName;
	}

	public String getAccountType() {
		return accountType;
	}

	public void setAccountType(String accountType) {
		this.accountType = accountType;
	}

	public Long getAssetClassificationId() {
		return assetClassificationId;
	}

	public void setAssetClassificationId(Long assetClassificationId) {
		this.assetClassificationId = assetClassificationId;
	}

	public double getProductEipID() {
		return productEipID;
	}

	public void setProductEipID(double productEipID) {
		this.productEipID = productEipID;
	}

	public Long getPortfolioSize() {
		return portfolioSize;
	}

	public void setPortfolioSize(Long portfolioSize) {
		this.portfolioSize = portfolioSize;
	}

	public String getManagementStrategy() {
		return managementStrategy;
	}

	public void setManagementStrategy(String managementStrategy) {
		this.managementStrategy = managementStrategy;
	}

	public String getPortfolioBaseCurrency() {
		return portfolioBaseCurrency;
	}

	public void setPortfolioBaseCurrency(String portfolioBaseCurrency) {
		this.portfolioBaseCurrency = portfolioBaseCurrency;
	}

	public Date getInceptionDate() {
		return inceptionDate;
	}

	public void setInceptionDate(Date inceptionDate) {
		this.inceptionDate = inceptionDate;
	}

	public String getInvestmentObjective() {
		return investmentObjective;
	}
	
	public Long getPortfolioManagerId() {
		return portfolioManagerId;
	}

	public void setPortfolioManagerId(Long portfolioManagerId) {
		this.portfolioManagerId = portfolioManagerId;
	}

	public void setInvestmentObjective(String investmentObjective) {
		this.investmentObjective = investmentObjective;
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}

	public Date getUpdatedDate() {
		return updatedDate;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = updatedDate;
	}

	public String getPortfolioManager() {
		return portfolioManager;
	}

	public void setPortfolioManager(String portfolioManager) {
		this.portfolioManager = portfolioManager;
	}

}
	AccountSetup.java


package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.DAO;

@Entity
@Table(name = "GMRADM.TACCT_SETUP")
public class AccountSetup implements DAO<Long> {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1ACCTSMAID")
	@SequenceGenerator(name = "GMRADM.SEQ1ACCTSMAID", sequenceName = "GMRADM.SEQ1ACCTSMAID", initialValue = 1, allocationSize = 1)
	@Column(name = "ACCT_SMA_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioId;

	@Column(name = "ACCT_CLNT_NM", nullable = false)
	private String accountClientName;
	
	@Column(name = "RGN_LN_1_ADDR")
	private String addressLineOne;
	
	@Column(name = "RGN_LN_2_ADDR")
	private String addressLineTwo;
	
	@Column(name = "RGN_LN_3_ADDR")
	private String addressLineThree;
	
	@Column(name = "RGN_CNTRY_NM") 
	private String countryName;
	
	@Column(name = "RGN_POSTL_CD")
	private String postalCode;
	
	@Column(name = "AGRMT_BGN_DT")
	private Date agreementBeginDate;
	
	@Column(name = "AGRMT_END_DT")
	private Date agreementEndDate;
	
	@Column(name = "STATUS_CD", nullable = false)
	private String statusCode;
	
	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String updatedUser;
	
	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;

	@Override
	public Long getId() {
		return id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	public String getPortfolioId() {
		return portfolioId;
	}

	public void setPortfolioId(String portfolioId) {
		this.portfolioId = portfolioId;
	}

	public String getAccountClientName() {
		return accountClientName;
	}

	public void setAccountClientName(String accountClientName) {
		this.accountClientName = accountClientName;
	}

	public String getAddressLineOne() {
		return addressLineOne;
	}

	public void setAddressLineOne(String addressLineOne) {
		this.addressLineOne = addressLineOne;
	}

	public String getAddressLineTwo() {
		return addressLineTwo;
	}

	public void setAddressLineTwo(String addressLineTwo) {
		this.addressLineTwo = addressLineTwo;
	}

	public String getAddressLineThree() {
		return addressLineThree;
	}

	public void setAddressLineThree(String addressLineThree) {
		this.addressLineThree = addressLineThree;
	}

	public String getCountryName() {
		return countryName;
	}

	public void setCountryName(String countryName) {
		this.countryName = countryName;
	}

	public String getPostalCode() {
		return postalCode;
	}

	public void setPostalCode(String postalCode) {
		this.postalCode = postalCode;
	}

	public Date getAgreementBeginDate() {
		return agreementBeginDate;
	}

	public void setAgreementBeginDate(Date agreementBeginDate) {
		this.agreementBeginDate = agreementBeginDate;
	}

	public Date getAgreementEndDate() {
		return agreementEndDate;
	}

	public void setAgreementEndDate(Date agreementEndDate) {
		this.agreementEndDate = agreementEndDate;
	}

	public String getStatusCode() {
		return statusCode;
	}

	public void setStatusCode(String statusCode) {
		this.statusCode = statusCode;
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}

	public Date getUpdatedDate() {
		return updatedDate;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = updatedDate;
	}

}

	AttributionSummary.java



package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "GMRADM.TPORT_ATTRTN_SUM", uniqueConstraints = @UniqueConstraint(columnNames = { "ATTRTN_ID", "PORT_ID", "EFFTV_DT", "ATTRTN_NM", "ONE_MM_VAL", "THR_MM_VAL", "SIX_MM_VAL", "NINE_MM_VAL", "TWLVE_MM_VAL", "YY_TO_DT_VAL", "EFFTV_END_DT" }))
public class AttributionSummary {
	
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ1ATTRTNID")
	@SequenceGenerator(name = "SEQ1ATTRTNID", sequenceName = "GMRADM.SEQ1ATTRTNID", initialValue = 1, allocationSize = 1)
	@Column(name = "ATTRTN_ID")
	private Long id;
	
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(String portId) {
		this.portId = portId;
	}

	public Date getEffectiveDate() {
		return effectiveDate;
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = effectiveDate;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public BigDecimal getOneMonthVal() {
		return oneMonthVal;
	}

	public void setOneMonthVal(BigDecimal oneMonthVal) {
		this.oneMonthVal = oneMonthVal;
	}

	public BigDecimal getThrMonthVal() {
		return thrMonthVal;
	}

	public void setThrMonthVal(BigDecimal thrMonthVal) {
		this.thrMonthVal = thrMonthVal;
	}

	public BigDecimal getSixMonthVal() {
		return sixMonthVal;
	}

	public void setSixMonthVal(BigDecimal sixMonthVal) {
		this.sixMonthVal = sixMonthVal;
	}

	public BigDecimal getNineMonthVal() {
		return nineMonthVal;
	}

	public void setNineMonthVal(BigDecimal nineMonthVal) {
		this.nineMonthVal = nineMonthVal;
	}

	public BigDecimal getTwlveMonthVal() {
		return twlveMonthVal;
	}

	public void setTwlveMonthVal(BigDecimal twlveMonthVal) {
		this.twlveMonthVal = twlveMonthVal;
	}

	public BigDecimal getYyToDTVal() {
		return yyToDTVal;
	}

	public void setYyToDTVal(BigDecimal yyToDTVal) {
		this.yyToDTVal = yyToDTVal;
	}

	public String getLastUpdatedUserId() {
		return lastUpdatedUserId;
	}

	public void setLastUpdatedUserId(String lastUpdatedUserId) {
		this.lastUpdatedUserId = lastUpdatedUserId;
	}

	public Date getLastUpdatedDate() {
		return lastUpdatedDate;
	}

	public void setLastUpdatedDate(Date lastUpdatedDate) {
		this.lastUpdatedDate = lastUpdatedDate;
	}

	public Date getEffectiveBeginDate() {
		return effectiveBeginDate;
	}

	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = effectiveBeginDate;
	}

	public Date getEffectiveEndDate() {
		return effectiveEndDate;
	}

	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = effectiveEndDate;
	}

	@Column(name = "PORT_ID", nullable = false)
	private String portId;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;
		
	@Column(name = "ATTRTN_NM", nullable = false)
	private String name;


	@Column(name = "ONE_MM_VAL")
	private BigDecimal oneMonthVal;
	
	@Column(name = "THR_MM_VAL")
	private BigDecimal thrMonthVal;
	
	@Column(name = "SIX_MM_VAL")
	private BigDecimal sixMonthVal;
	
	@Column(name = "NINE_MM_VAL")
	private BigDecimal nineMonthVal;
	
	@Column(name = "TWLVE_MM_VAL")
	private BigDecimal twlveMonthVal;
	
	@Column(name = "YY_TO_DT_VAL")
	private BigDecimal yyToDTVal;

	@Column(name = "LST_UPDTD_USER_ID", insertable = false)
	private String lastUpdatedUserId;

	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date lastUpdatedDate;

	@Column(name = "EFFTV_BGN_DT", insertable = false)
	private Date effectiveBeginDate;

	@Column(name = "EFFTV_END_DT")
	private Date effectiveEndDate;


	
}

	Characteristics.java


package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.math.BigDecimal;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

/**
 * @author UT0T
 *
 */
@Entity
@Table(name = "GMRADM.TPORT_CHARACTERISTICS", uniqueConstraints = @UniqueConstraint(columnNames = { "PORT_ID", "CHAR_TYP_CD", "EFFTV_DT", "CHAR_NM", "EFFTV_END_DT" }))
public class Characteristics {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ1CHARID")
	@SequenceGenerator(name = "SEQ1CHARID", sequenceName = "GMRADM.SEQ1CHARID", initialValue = 1, allocationSize = 1)
	@Column(name = "CHAR_ID")
	private Long id;

	@Column(name = "PORT_ID", nullable = false)
	private String portId;

	@Column(name = "CHAR_TYP_CD", length = 8, nullable = false)
	private String type;

	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;

	@Column(name = "PORT_VAL_NO")
	private BigDecimal portfolio;

	@Column(name = "BCHMRK_VAL_NO")
	private BigDecimal benchmark;

	@Column(name = "CHAR_NM")
	private String name;

	@Column(name = "LST_UPDTD_USER_ID", insertable = false)
	private String lastUpdatedUserId;

	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date lastUpdatedDate;

	@Column(name = "EFFTV_BGN_DT", insertable = false)
	private Date effectiveBeginDate;

	@Column(name = "EFFTV_END_DT")
	private Date effectiveEndDate;

	/**
	 * @return the portfolio
	 */
	public BigDecimal getPortfolio() {
		return portfolio;
	}

	/**
	 * @param portfolio
	 *            the portfolio to set
	 */
	public void setPortfolio(BigDecimal portfolio) {
		this.portfolio = portfolio;
	}

	/**
	 * @return the benchmark
	 */
	public BigDecimal getBenchmark() {
		return benchmark;
	}

	/**
	 * @param benchmark
	 *            the benchmark to set
	 */
	public void setBenchmark(BigDecimal benchmark) {
		this.benchmark = benchmark;
	}

	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}

	/**
	 * @param name
	 *            the name to set
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * @return the lastUpdatedUserId
	 */
	public String getLastUpdatedUserId() {
		return lastUpdatedUserId;
	}

	/**
	 * @param lastUpdatedUserId
	 *            the lastUpdatedUserId to set
	 */
	public void setLastUpdatedUserId(String lastUpdatedUserId) {
		this.lastUpdatedUserId = lastUpdatedUserId;
	}

	/**
	 * @return the lastUpdatedDate
	 */
	public Date getLastUpdatedDate() {
		return lastUpdatedDate;
	}

	/**
	 * @param lastUpdatedDate
	 *            the lastUpdatedDate to set
	 */
	public void setLastUpdatedDate(Date lastUpdatedDate) {
		this.lastUpdatedDate = lastUpdatedDate;
	}

	/**
	 * @return the id
	 */
	public Long getId() {
		return id;
	}

	/**
	 * @param id
	 *            the id to set
	 */
	public void setId(Long id) {
		this.id = id;
	}

	/**
	 * @return the portId
	 */
	public String getPortId() {
		return portId;
	}

	/**
	 * @param portId
	 *            the portId to set
	 */
	public void setPortId(String portId) {
		this.portId = portId;
	}

	/**
	 * @return the type
	 */
	public String getType() {
		return type;
	}

	/**
	 * @param type
	 *            the type to set
	 */
	public void setType(String type) {
		this.type = type;
	}

	/**
	 * @return the effectiveBeginDate
	 */
	public Date getEffectiveBeginDate() {
		return effectiveBeginDate;
	}

	/**
	 * @param effectiveBeginDate
	 *            the effectiveBeginDate to set
	 */
	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = effectiveBeginDate;
	}

	/**
	 * @return the effectiveEndDate
	 */
	public Date getEffectiveEndDate() {
		return effectiveEndDate;
	}

	/**
	 * @param effectiveEndDate
	 *            the effectiveEndDate to set
	 */
	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = effectiveEndDate;
	}

	/**
	 * @return the effectiveDate
	 */
	public Date getEffectiveDate() {
		return effectiveDate;
	}

	/**
	 * @param effectiveDate the effectiveDate to set
	 */
	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = effectiveDate;
	}

}


	Commentary.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.DAO;

@Entity
@Table(name = "GMRADM.TPORT_PRFMC_CMNT")
public class Commentary implements DAO<Long>{

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1CMNTID")
	@SequenceGenerator(name = "GMRADM.SEQ1CMNTID", sequenceName = "GMRADM.SEQ1CMNTID", initialValue = 1, allocationSize = 1)
	@Column(name = "CMNT_ID", nullable = false)
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portId;
	
	@Column(name = "EFFTV_DT", nullable = false) 
	private Date asOfDate;
	
	@Column(name = "CMNT_TX")
	private String commentaryText;
	
	@Column(name = "CMNT_RSN_TYP_CD")
	private String commentaryReason;
	
	@Column(name = "EFFTV_BGN_DT")
	private Date effectiveBeginDate;

	@Column(name = "EFFTV_END_DT")
	private Date effectiveEndDate;
	
	@Column(name = "LST_UPDTD_USER_ID", insertable = false) 
	private String updatedUser;
	
	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;
	
	public Date getEffectiveEndDate() {
		return effectiveEndDate;
	}

	public String getCommentaryReason() {
		return commentaryReason;
	}

	public Date getEffectiveBeginDate() {
		return effectiveBeginDate;
	}

	public String getCommentaryText() {
		return commentaryText;
	}

	public Date getEffectiveDate() {
		return asOfDate;
	}

	public Long getId() {
		return id;
	}

	public String getPortfolioId() {
		return portId;
	}

	public Date getUpdatedDate() {
		return updatedDate;
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = effectiveEndDate;
	}

	public void setCommentaryReason(String commentaryReason) {
		this.commentaryReason = commentaryReason;
	}

	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = effectiveBeginDate;
	}

	public void setCommentaryText(String commentaryText) {
		this.commentaryText = commentaryText;
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.asOfDate = effectiveDate;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setPortfolioId(String portfolioId) {
		this.portId = portfolioId;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = updatedDate;
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}
}

	Limit.java


package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

@Entity
@Table(name="GMRADM.TPORT_LIMIT")
public class Limit {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1PORTLIMID")
	@SequenceGenerator(name = "GMRADM.SEQ1PORTLIMID", sequenceName = "GMRADM.SEQ1PORTLIMID", initialValue = 1,allocationSize = 1)
	@Column(name = "LIM_ID")
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioCode;
	
	@Column(name = "LIM_TYP_CD", nullable = false)
	private String limitTypeCode;
	
	@Column(name = "LIM_NM", nullable = false)
	private String limitName;
	
	@Column(name = "LOWR_LIM_VAL")
	private Double lowerLimitValue;
	
	@Column(name = "UPR_LIM_VAL")
	private Double upperLimitValue;
	
	@Column(name = "FUM_SPLT_LIM_VAL")
	private Double fumSplitLimitValue;
	
	@Column(name = "EFFTV_BGN_DT", nullable = false) 
	private Date effectiveBeginDate;
	
	@Column(name = "EFFTV_END_DT", nullable = false) 
	private Date effectiveEndDate;
	
	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String updatedUser;
	
	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getPortfolioCode() {
		return portfolioCode;
	}

	public void setPortfolioCode(String portfolioCode) {
		this.portfolioCode = portfolioCode;
	}

	public String getLimitTypeCode() {
		return limitTypeCode;
	}

	public void setLimitTypeCode(String limitTypeCode) {
		this.limitTypeCode = limitTypeCode;
	}

	public Date getEffectiveBeginDate() {
		return effectiveBeginDate;
	}

	public void setEffectiveBeginDate(Date effectiveBeginDate) {
		this.effectiveBeginDate = effectiveBeginDate;
	}

	public Date getEffectiveEndDate() {
		return effectiveEndDate;
	}

	public void setEffectiveEndDate(Date effectiveEndDate) {
		this.effectiveEndDate = effectiveEndDate;
	}

	public String getLimitName() {
		return limitName;
	}

	public void setLimitName(String limitName) {
		this.limitName = limitName;
	}

	public Double getLowerLimitValue() {
		return lowerLimitValue;
	}

	public void setLowerLimitValue(Double lowerLimitValue) {
		this.lowerLimitValue = lowerLimitValue;
	}

	public Double getUpperLimitValue() {
		return upperLimitValue;
	}

	public void setUpperLimitValue(Double upperLimitValue) {
		this.upperLimitValue = upperLimitValue;
	}

	public Double getFumSplitLimitValue() {
		return fumSplitLimitValue;
	}

	public void setFumSplitLimitValue(Double fumSplitLimitValue) {
		this.fumSplitLimitValue = fumSplitLimitValue;
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}

	public Date getUpdatedDate() {
		return updatedDate;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = updatedDate;
	}
}

	ValuationsReport.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import com.vanguard.corp.ics.dao.PortfolioDAO;
import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;

@Entity
@Table(name = "GMRADM.TPORT_VALUTN_SUM")
public class ValuationsReport implements PortfolioDAO<Long> {

	private static final long serialVersionUID = 8059542176119580685L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "GMRADM.SEQ1PORTSUMID")
	@SequenceGenerator(name = "GMRADM.SEQ1PORTSUMID", sequenceName = "GMRADM.SEQ1PORTSUMID", initialValue = 1, allocationSize = 1)
	@Column(name = "PORT_SUM_ID")
	private Long id;
	
	@Column(name = "PORT_ID", nullable = false)
	private String portfolioCode;
	
	@Column(name = "EFFTV_DT", nullable = false)
	private Date effectiveDate;
	
	@Column(name = "RUN_TS", nullable = false)
	private Date runTimestamp;
	
	@Column(name = "SECTY_TYP_CD", nullable = false)
	private String securityTypeCode;
	
	@Column(name = "VALUTN_VAL")
	private double valuationValue;
	
	@Column(name = "TOT_VAL")
	private double totalValue;
	
	@ManyToOne
	@JoinColumn(name = "DATA_SRC_FILE_ID")
	private DatasourceFileDAO datasourceFileDAO;
	
	@Column(name = "CREATD_BY_USER_ID", nullable = false)
	private String createdUser;
	
	@Column(name = "CREATD_DT", nullable = false)
	private Date createdDate;
	
	@Column(name = "LST_UPDTD_USER_ID", nullable = false)
	private String updatedUser;
	
	@Column(name = "LST_UPDTD_TS", insertable = false)
	private Date updatedDate;
	
	@Column(name = "PORT_VALUTN_TYP_CD", nullable = false)
	private String portfolioValuationTypeCode;

	@Override
	public Long getId() {
		return id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	@Override
	public String getPortfolioCode() {
		return portfolioCode;
	}

	@Override
	public void setPortfolioCode(String portfolioCode) {
		this.portfolioCode = portfolioCode;
	}

	public Date getEffectiveDate() {
		return effectiveDate;
	}

	public void setEffectiveDate(Date effectiveDate) {
		this.effectiveDate = effectiveDate;
	}

	public Date getRunTimestamp() {
		return runTimestamp;
	}

	public void setRunTimestamp(Date runTimestamp) {
		this.runTimestamp = runTimestamp;
	}

	public String getSecurityTypeCode() {
		return securityTypeCode;
	}

	public void setSecurityTypeCode(String securityTypeCode) {
		this.securityTypeCode = securityTypeCode;
	}

	public double getValuationValue() {
		return valuationValue;
	}

	public void setValuationValue(double valuationValue) {
		this.valuationValue = valuationValue;
	}

	public double getTotalValue() {
		return totalValue;
	}

	public void setTotalValue(double totalValue) {
		this.totalValue = totalValue;
	}

	public DatasourceFileDAO getDatasourceFileDAO() {
		return datasourceFileDAO;
	}

	public void setDatasourceFileDAO(DatasourceFileDAO datasourceFileDAO) {
		this.datasourceFileDAO = datasourceFileDAO;
	}
	
	public String getCreatedUser() {
		return createdUser;
	}

	public void setCreatedUser(String createdUser) {
		this.createdUser = createdUser;
	}

	public Date getCreatedDate() {
		return createdDate;
	}

	public void setCreatedDate(Date createdDate) {
		this.createdDate = createdDate;
	}

	public String getUpdatedUser() {
		return updatedUser;
	}

	public void setUpdatedUser(String updatedUser) {
		this.updatedUser = updatedUser;
	}

	public Date getUpdatedDate() {
		return updatedDate;
	}

	public void setUpdatedDate(Date updatedDate) {
		this.updatedDate = updatedDate;
	}

	public String getPortfolioValuationTypeCode() {
		return portfolioValuationTypeCode;
	}

	public void setPortfolioValuationTypeCode(String portfolioValuationTypeCode) {
		this.portfolioValuationTypeCode = portfolioValuationTypeCode;
	}

	
}


com.vanguard.corp.ics.sdt.dao.impl.portal
	ProductPortalHelper.java


package com.vanguard.corp.ics.sdt.dao.impl.portal;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.MediaType;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

@Named
public class ProductPortalHelper {

	private static final Logger LOG = LoggerFactory.getLogger(ProductPortalHelper.class);

	@Inject
	private PortalConfiguration config;
	
	public <T> T getRequest(String url, Class<T> returnClass, HttpServletRequest request) {
		
		Client client = getClient();
		client = client.register(SecureClientRequestFeature.class);
		
		for (int i=0; i < config.getMaxConnectionAttempts(); ) {
			try {
				return client.target(url)
						.request(MediaType.APPLICATION_JSON)
						.property(SecureClientRequestFeature.FORWARD_HTTP_SERVLET_REQUEST, request)
						.accept(MediaType.APPLICATION_JSON)
						.get(returnClass);

			} catch (final Exception e) {
				LOG.error("Error connecting to portal.", e);
				if (++i < config.getMaxConnectionAttempts()) {
					LOG.info("Retrying Portal Connection {}/{}", i, config.getMaxConnectionAttempts());
				} else {
					LOG.error("Error making request to: {}", url);
				}
			}			
		}
		
		return null;
	}

	/**
	 * extracted for testing only
	 * 
	 * @return
	 */
	protected Client getClient() {
		return ClientBuilder.newClient();
	}
}

	ProductPortalServiceImpl.java
/
package com.vanguard.corp.ics.sdt.dao.impl.portal;

import java.util.Arrays;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;

@Named
public class ProductPortalServiceImpl implements ProductPortalService {

	private static final Logger LOG = LoggerFactory.getLogger(ProductPortalServiceImpl.class);

	@Inject
	private PortalConfiguration config;
	
	@Inject
	private ProductPortalHelper productPortalHelper;
	
	public List<PortalProduct> getProducts(HttpServletRequest request) {
		
		LOG.info("Using endpoint: {}", config.getPortalProductEndpoint());
		final String productEndpoint = config.getPortalProductEndpoint();
		final List<PortalProduct> products = Arrays.asList(productPortalHelper.getRequest(productEndpoint, PortalProduct[].class, request));
		return products;
	}

	public PortalProduct getProduct(List<PortalProduct> products, String productCode) {	
		return products.stream().filter(p -> p.getProductCode().equalsIgnoreCase(productCode)).findFirst().get();
	}
	
	public Currency getProductCurrency(PortalProduct product, HttpServletRequest request) {
		
		String currencyEndpoint = config.getPortalReferenceEndpoint()
				+ "/currency/" + product.getBaseCurrencyID();
		
		return productPortalHelper.getRequest(currencyEndpoint, Currency.class, request);
	}

	public InvestmentGroup getInvestmentGroup(PortalProduct product, HttpServletRequest request) {
		
		String investmentGroupEndpoint = config.getPortalReferenceEndpoint()
				+ "/investmentGroup/" + product.getInvestmentGroupID();
		
		return productPortalHelper.getRequest(investmentGroupEndpoint, InvestmentGroup.class, request);
	}

}


package com.vanguard.corp.ics.sdt.dao.impl.repository
	AccountBenchmarkAssociationRepository.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.dao.impl.repository;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;

@Repository("accountBenchmarkAssociationReportRepository")
public interface AccountBenchmarkAssociationRepository extends JpaRepository<AccountBenchmarkAssociation, Long> {
	
	AccountBenchmarkAssociation findByPortfolioIdIs(String portfolioId);
}


		AccountFundRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;

@Repository("accountFundReportRepository")
public interface AccountFundRepository extends JpaRepository<AccountFund, Long> {
	
	AccountFund findByPortfolioIdIs(String portfolioId);
}

		AccountSetupRepository.java


package com.vanguard.corp.ics.sdt.dao.impl.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;

@Repository("accountSetupReportRepository")
public interface AccountSetupRepository extends JpaRepository<AccountSetup, Long> {
	
	AccountSetup findByPortfolioIdIs(String portfolioId);
}


		AttributionSummaryRepository.java


package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;

public interface AttributionSummaryRepository extends JpaRepository<AttributionSummary, Long> {
	List<AttributionSummary> findByEffectiveDate(Date effectiveDate);
	
	List<AttributionSummary> findByEffectiveDateAndPortId(Date effectiveDate, String portId);

	List<AttributionSummary> findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(Date effectiveDate, String portId);
	
}

		CharacteristicsRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

/**
 * @author UT0T
 *
 */
public interface CharacteristicsRepository extends JpaRepository<Characteristics, Long> {
	
	List<Characteristics> findByEffectiveDate(Date effectiveDate);
	
	List<Characteristics> findByEffectiveDateAndPortId(Date effectiveDate, String portId);

	List<Characteristics> findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(Date effectiveDate, String portId, String type);
}

	CommentaryRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;

@Repository("commentaryRepository")
public interface CommentaryRepository extends JpaRepository<Commentary, Long>{
	
	Commentary findByAsOfDateAndPortId(Date asOfDate, String portfolioId);
}

		PortfolioLimitRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;

public interface PortfolioLimitRepository extends JpaRepository<Limit, Long> {

	Limit findOneById(Long id);
	
	Limit findByPortfolioCodeAndLimitTypeCodeAndEffectiveBeginDate(String portfolioCode, String limitTypeCode, Date effectiveBeginDate);
}

		ValuationsReportRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;

import org.springframework.data.jpa.repository.JpaRepository;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;

public interface ValuationsReportRepository extends JpaRepository<ValuationsReport, Long> {
	
	ValuationsReport findOneById(Long id);

	ValuationsReport findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIs(String portfolioCode, String securityTypeCode, Date effectiveDate);
}

com.vanguard.corp.ics.sdt.service.api
		CommentaryService.java

package com.vanguard.corp.ics.sdt.service.api;

import java.util.Date;

import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

public interface CommentaryService {

	public CommentaryDTO getCommentary(String portId, Date asOfDate);
	
	public void saveOrUpdateCommentary(CommentaryDTO commentary);
	
}


		DataTransferService.java

package com.vanguard.corp.ics.sdt.service.api;

import java.util.Date;

import javax.servlet.http.HttpServletRequest;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;

public interface DataTransferService {

	void transfer(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request);

}

		TransferService.java

package com.vanguard.corp.ics.sdt.service.api;

import java.util.Date;

import javax.servlet.http.HttpServletRequest;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;

public interface TransferService {

	boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request);

	void transfer(Date asOfDate, String portId, HttpServletRequest request);

	TransferService.Priority getPriority();

	public enum Priority {
		HIGHEST
		, HIGH
		, MEDIUM
		, LOW
		, LOWEST
		;
	}
}

	TransferServiceComparator.java


package com.vanguard.corp.ics.sdt.service.api;

import java.util.Comparator;


public class TransferServiceComparator implements Comparator<TransferService> {

	@Override
	public int compare(final TransferService o1, final TransferService o2) {
		return o1.getPriority().ordinal() - o2.getPriority().ordinal();
	}

}


com.vanguard.corp.ics.sdt.service.api.constants

		AnalyticsTypeCode.java

package com.vanguard.corp.ics.sdt.service.api.constants;

public enum AnalyticsTypeCode {

	EX_ANTE_RISK("Ex Ante- Tracking Error", "EATE"),
	ONE_YR_EX_POST("1 yr Ex-Post Tracking Error", "1YEP"),
	THREE_YR_EX_POST("3 yr Ex-Post Tracking Error", "3YEP"),
	ONE_YR_STANDARD_DEV("1 yr Standard Deviation", "1YSD"),
	THREE_YR_STANDARD_DEV("3 yr Standard Deviation", "3YSD");
	
	private final String name;
	private final String code;
	
	AnalyticsTypeCode(String name, String code) {
		this.name = name;
		this.code = code;
	}

	public String getName() {
		return name;
	}

	public String getCode() {
		return code;
	}
}

		CharacteristicsType.java

package com.vanguard.corp.ics.sdt.service.api.constants;

public enum CharacteristicsType {

	PORTFOLIO_CHARACTERISTICS	("CHARSTCS")
	, COUNTRY_ALLOCATION		("CONALOCN")
	, CURRENCY_ALLOCATION		("CURALOCN")
	, MARKET_SEGMENTATION		("MKTSGMNT")
	, REGIONAL_ALLOCATION		("REGALOCN")
	, SECTOR_ALLOCATION			("SECALOCN")
	, TOP_TEN_HOLDINGS			("TOP10HOL")
	;

	private final String code;

	private CharacteristicsType(String code) {
		this.code = code;
	}

	public String getCode() {
		return code;
	}
}


		DataSetType.java

package com.vanguard.corp.ics.sdt.service.api.constants;


public enum DataSetType {

	CHARACTERISTICS
	, PRODUCT_DATA
	, RISK_SUMMARY
	, VALUATIONS
	,ATTRIBUTION_SUMMARY
	;
}

		SecurityTypeCode.java


package com.vanguard.corp.ics.sdt.service.api.constants;

public enum SecurityTypeCode {

	DERIVATIVES("Derivatives", "DERI"),
	EQUITY("Equity", "EQUI"),
	FUTURES("Futures", "FUTU"),
	FORWARD_FOREX("Forward Forex", "FWFX"),
	LIQUIDITY("Liquidity", "LIQU"),
	FIXED_INTEREST("Securities", "SECU");
	
	private final String name;
	private final String code;
	
	SecurityTypeCode(String name, String code) {
		this.name = name;
		this.code = code;
	}

	public String getName() {
		return name;
	}

	public String getCode() {
		return code;
	}
}

com.vanguard.corp.ics.sdt.service.api.exception
		DataTransferException.java		


package com.vanguard.corp.ics.sdt.service.api.exception;


public class DataTransferException extends RuntimeException {

	private static final long serialVersionUID = 1L;

	public DataTransferException(final String message) {
		super(message);
	}

	public DataTransferException(final String message, final Throwable cause) {
		super(message, cause);
	}
}

		ReadCharacteristicsException.java

package com.vanguard.corp.ics.sdt.service.api.exception;

public class ReadCharacteristicsException extends DataTransferException {

	private static final long serialVersionUID = 1L;

	public ReadCharacteristicsException(final String message, final Throwable cause) {
		super(message, cause);
	}

}

		SaveCharacteristicsException.java

package com.vanguard.corp.ics.sdt.service.api.exception;

public class SaveCharacteristicsException extends DataTransferException {

	private static final long serialVersionUID = 1L;

	public SaveCharacteristicsException(final String message) {
		super(message);
	}

	public SaveCharacteristicsException(final String message, final Throwable cause) {
		super(message, cause);
	}

}

com.vanguard.corp.ics.sdt.service.api.util
			DateParser.java


package com.vanguard.corp.ics.sdt.service.api.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateParser {

	public static final String DATE_FORMAT = "yyyy-MM-dd";

	public Date parse(final String strDate) {
		final SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		
		Date actualDate;
		try {
			actualDate = formatter.parse(strDate);
		}
		catch (ParseException e) {
			throw new DateParserException(String.format("Failed to parse \"%s\"", strDate), e);
		}

		// SimpleDateFormat automatically modifies the date when
		// the date is out of range for the month,
		// e.g. 2017-06-31 becomes 2017-07-01
		//
		// check to make sure that didn't happen here
		int expectedMonth = Integer.parseInt(strDate.substring(5, 7), 10);
		Calendar cal = Calendar.getInstance();
		cal.setTime(actualDate);
		int actualMonth = cal.get(Calendar.MONTH) + 1;
		if (expectedMonth != actualMonth) {
			throw new DateParserException(String.format("Invalid date %s converted to %s", strDate, formatter.format(actualDate)));
		}

		return actualDate;
	}

	public static class DateParserException extends RuntimeException {
		
		private static final long serialVersionUID = 1L;

		public DateParserException(final String msg) {
			super(msg);
		}
		
		public DateParserException(final String msg, final Throwable cause) {
			super(msg, cause);
		}
	}
}

		Utilities.java

package com.vanguard.corp.ics.sdt.service.api.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;

import javax.inject.Named;

import com.vanguard.services.suds.entity.VGUser;
import com.vanguard.services.suds.factory.VGUserFactory;

@Named
public class Utilities {

	// we cannot maintain state in an autowired object
	// lest we encounter threading issues

	public Date getPreviousMonthEnd(Date date) {

		Calendar cal = new GregorianCalendar();
		cal.setTime(date);
		cal.add(Calendar.MONTH, -1);
		cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));

		return cal.getTime();
	}

	// TODO Fix issue where getAuthenticatedUser returns a String instead of a
	// VGUser. May have to do with filter ordering?
	public String getCurrentUsername() {

		return getAuthenticatedUser().getUsername();
	}

	/**
	 * extracted for testing only
	 * 
	 * @return
	 */
	protected VGUser getAuthenticatedUser() {
		return VGUserFactory.getAuthenticatedUser();
	}

	
	public Date generateDateFromString(String dateString, String dateFormat) {

		DateFormat df = new SimpleDateFormat(dateFormat, Locale.ENGLISH);

		Date output = new Date();

		try {
			output = df.parse(dateString);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return output;
	}
}

com.vanguard.corp.ics.sdt.service.impl
			CommentaryServiceImpl.java

package com.vanguard.corp.ics.sdt.service.impl;

import java.util.Date;

import javax.inject.Inject;
import javax.inject.Named;

import org.springframework.transaction.annotation.Transactional;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.CommentaryRepository;
import com.vanguard.corp.ics.sdt.service.api.CommentaryService;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

@Named
@Transactional
public class CommentaryServiceImpl implements CommentaryService {

	@Inject
	private CommentaryRepository commentaryRepository;

	private final DateParser dateParser = new DateParser();

	@Override
	public CommentaryDTO getCommentary(String portId, Date asOfDate) {
		
		// find existing commentary record
		Commentary commentaryEntity = commentaryRepository.findByAsOfDateAndPortId(asOfDate, portId);

		//if no commentary found return null
		if(commentaryEntity == null){
			return null;
		}
		
		CommentaryDTO retrievedCommentary = new CommentaryDTO();
		
		retrievedCommentary.setPortId(commentaryEntity.getPortfolioId());
		retrievedCommentary.setAsOfDate(commentaryEntity.getEffectiveDate().toString()); 
		retrievedCommentary.setCommentary(commentaryEntity.getCommentaryText());
		

		return retrievedCommentary;
	}

	@Override
	public void saveOrUpdateCommentary(CommentaryDTO commentary) {
		
		//flag for new commentary in table
		boolean isNewCommentary = false;
		
		// find existing commentary record
		Commentary commentaryEntity = commentaryRepository.findByAsOfDateAndPortId(dateParser.parse(commentary.getAsOfDate()), commentary.getPortId());
		
		if (commentaryEntity == null){
			isNewCommentary = true;
			commentaryEntity = new Commentary();
		}
		
		commentaryEntity.setPortfolioId(commentary.getPortId());
		commentaryEntity.setEffectiveDate(dateParser.parse(commentary.getAsOfDate()));
		commentaryEntity.setCommentaryText(commentary.getCommentary());
		commentaryEntity.setEffectiveBeginDate(new Date());
		
		if(isNewCommentary){
			commentaryRepository.save(commentaryEntity);
		}

	}

}

		DataTransferServiceImpl.java


package com.vanguard.corp.ics.sdt.service.impl;

import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferServiceComparator;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.DataTransferException;

@Named
public class DataTransferServiceImpl implements DataTransferService {

	private static final String DATE_FORMAT = "yyyy-MM-dd";
	private static final String IDENTIFIER = "[DataTransferServiceImpl.transfer]";
	private static final Logger LOGGER = LoggerFactory.getLogger(DataTransferServiceImpl.class);

	@Inject
	private List<TransferService> services;

	@Override
	public void transfer(final Date asOfDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		final SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);

		Collections.sort(services, new TransferServiceComparator());
		for (TransferService service : services) {
			try {
				LOGGER.info(String.format("%s checking %s; asOfDate:%s, portId:%s, dataSet:%s"
						, IDENTIFIER, service.getClass().getSimpleName()
						, formatter.format(asOfDate), portId, dataSetType));
				
				if (service.handles(asOfDate, portId, dataSetType, request)) {
					service.transfer(asOfDate, portId, request);
					LOGGER.info(String.format("%s %s completed successfully"
							, IDENTIFIER, service.getClass().getSimpleName()));
				}
			}
			catch (Exception e) {
				LOGGER.error(String.format("%s %s thrown; msg:%s", IDENTIFIER
						, e.getClass().getSimpleName(), e.getMessage()), e);
				throw new DataTransferException(String.format("Exception thrown in %s during data transfer"
						, service.getClass().getSimpleName()), e);
			}
		}
	}

}

		ProductDataServiceImpl.java


package com.vanguard.corp.ics.sdt.service.impl;

import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.collections.CollectionUtils;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;


@Named
public class ProductDataServiceImpl implements TransferService {

	@Inject
	ProductPortalService productPortal;
	
	@Inject
	Utilities utilities;
	
	@Inject
	private AccountFundRepository accountFundRepository;
	
	@Inject
	private AccountSetupRepository accountSetupRepository;
	
	@Inject
	private AccountBenchmarkAssociationRepository accountBenchmarkAssociationRepository;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.HIGHEST;
	}
	
	@Override
	public boolean handles(final Date asOfDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.PRODUCT_DATA;
	}
	
	@Override
	public void transfer(final Date asOfDate, final String portId, final HttpServletRequest request) {
		List<PortalProduct> products = productPortal.getProducts(request);
		if (StringUtils.isEmpty(portId)) {
			
			if(CollectionUtils.isNotEmpty(products)){
				for(PortalProduct product : products) {
					moveProductPortalDataToReport(product, request);
				}
			}
		}
		else {
			PortalProduct portProduct = productPortal.getProduct(products, portId);
			moveProductPortalDataToReport(portProduct, request);
		}
	}
	
	public void moveProductPortalDataToReport(PortalProduct product, HttpServletRequest request) {
		
		if(product != null) {
			// TODO How should we handle currency IDs that don't Exist in PWS? Right now they only have 3 currencies.
			if( !(product.getBaseCurrencyID() == 1 || product.getBaseCurrencyID() == 2 || product.getBaseCurrencyID() == 3) ) {
				Currency currency = new Currency();
				currency.setCurrencyCode("N/A");
				product.setCurrency(currency);
			} else {
				product.setCurrency(productPortal.getProductCurrency(product, request));
			}
			
			product.setInvestmentGroup(productPortal.getInvestmentGroup(product, request));

			AccountFund accountFundRecord = generateAccountFundRecord(product);
			accountFundRepository.save(accountFundRecord);
			
			AccountSetup accountSetupRecord = generateAccountSetupRecord(product);
			accountSetupRepository.save(accountSetupRecord);
			
			AccountBenchmarkAssociation accountBenchmarkAssociationRecord = generateAccountBenchmarkAssociationRecord(product);
			accountBenchmarkAssociationRepository.save(accountBenchmarkAssociationRecord);
			
		} else {
			// TODO Return some exception?
		}
	}
	
	private AccountFund generateAccountFundRecord(PortalProduct product) {
		
		AccountFund output;
		
		AccountFund existingAccountFundRecord = accountFundRepository.findByPortfolioIdIs(product.getProductCode());
		
		if(existingAccountFundRecord != null){
			output = accountFundRepository.findOne(existingAccountFundRecord.getId());
		}else{
			output = new AccountFund();
		}
		
		output.setPortfolioId(product.getProductCode());
		output.setAccountName(product.getProductName());
		output.setAccountShortName(product.getProductName());
		output.setPortfolioManagerId(product.getInvestmentGroupID());
		output.setPortfolioBaseCurrency(product.getCurrency().getCurrencyCode());
	
		// TODO Is it valid for Product Portal to return no Investment Group ID?
		if(product.getInvestmentGroup() != null)
		{
			output.setPortfolioManager(product.getInvestmentGroup().getInvestmentGroupName());
		} else {
			
		}
		
		// TODO How should we handle products with no PerfInceptionDate?
		if(product.getPerfInceptionDate() != null && !product.getPerfInceptionDate().isEmpty())
		{
			output.setInceptionDate(utilities.generateDateFromString(product.getPerfInceptionDate(), RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT));
		} else {
			output.setInceptionDate(new Date());
		}
		
		output.setInvestmentObjective(product.getInvestmentObjective());
		output.setUpdatedUser(utilities.getCurrentUsername());
		
		// TODO Below are not in one of Cognos Sections. These fields cannot be null in the database.
		output.setAccountType("TEST");
		output.setAssetClassificationId(Long.valueOf(3));
		output.setProductEipID(0);
		
		return output;
	}
	
	private AccountSetup generateAccountSetupRecord(PortalProduct product) {
		
		AccountSetup output;
		
		AccountSetup existingAccountSetupRecord = accountSetupRepository.findByPortfolioIdIs(product.getProductCode());
		
		if(existingAccountSetupRecord != null){
			output = accountSetupRepository.findOne(existingAccountSetupRecord.getId());
		}else{
			output = new AccountSetup();
		}
		
		output.setPortfolioId(product.getProductCode());
		output.setAccountClientName(product.getClientID());
		output.setUpdatedUser(utilities.getCurrentUsername());
		
		// TODO Below is not in one of Cognos Sections. This field cannot be null in the database.
		output.setStatusCode("ACTIVE");
		
		return output;
	}
	
	private AccountBenchmarkAssociation generateAccountBenchmarkAssociationRecord(PortalProduct product) {
		
		AccountBenchmarkAssociation output;
		
		AccountBenchmarkAssociation existingAccountBenchmarkAssociationRecord = accountBenchmarkAssociationRepository.findByPortfolioIdIs(product.getProductCode());
		
		if(existingAccountBenchmarkAssociationRecord != null){
			output = accountBenchmarkAssociationRepository.findOne(existingAccountBenchmarkAssociationRecord.getId());
		}else{
			output = new AccountBenchmarkAssociation();
		}
		
		output.setPortfolioId(product.getProductCode());
		output.setBenchmarkName(product.getBenchMarkName());
		output.setUpdatedUser(utilities.getCurrentUsername());
		
		return output;
	}

}

		ValuationsServiceImpl.java

package com.vanguard.corp.ics.sdt.service.impl;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;

import com.vanguard.corp.ics.repository.target.ValuationsRepository;
import com.vanguard.corp.ics.sdt.dao.api.constants.DatabaseConstants;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;
import com.vanguard.corp.ics.sdt.dao.impl.repository.ValuationsReportRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.constants.SecurityTypeCode;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.dao.target.ValuationsTargetDAO;

@Named
public class ValuationsServiceImpl implements TransferService {
	
	@Inject 
	Utilities utilities;

	@Inject
	private ValuationsRepository valuationsTargetRepository;
	
	@Inject
	private ValuationsReportRepository valuationsReportRepository;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}
	
	@Override
	public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.VALUATIONS;
	}
	
	@Override
	public void transfer(Date asOfDate, String portId, HttpServletRequest request) {
		org.springframework.util.Assert.notNull(asOfDate);
		
		List<String> portIds = valuationsTargetRepository.findPortIdByDate(asOfDate);
		if (StringUtils.isEmpty(portId)) {	
			for (String portfolioId : portIds) {
				moveValuationsFromTargetToReport(portfolioId, asOfDate);
			}
		}
		else {
			moveValuationsFromTargetToReport(portId, asOfDate);
		}
	}

	public void moveValuationsFromTargetToReport(String portfolioId, Date valuationDate) {
		
		Date previousMonthEnd = utilities.getPreviousMonthEnd(valuationDate);
		
		ValuationsTargetDAO currentValuationTarget = getValuationTargetRecord(portfolioId, valuationDate);
		ValuationsTargetDAO previousValuationTarget = getValuationTargetRecord(portfolioId, previousMonthEnd);

		saveReportRecords(currentValuationTarget);
		saveReportRecords(previousValuationTarget);
	}
	
	public ValuationsTargetDAO getValuationTargetRecord(String portfolioId, Date valuationDate) {

		return valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valuationDate, portfolioId);
	}
	
	private void saveReportRecords(ValuationsTargetDAO targetRecord){
		
		if(targetRecord != null){
			List<ValuationsReport> targetRecords = generateValuationReportRecords(targetRecord);
			
			for(ValuationsReport valutionReportRecord: targetRecords) {
				valuationsReportRepository.save(valutionReportRecord);
			}
		}
	}

	private List<ValuationsReport> generateValuationReportRecords(ValuationsTargetDAO valuationTarget) {
		
		List<ValuationsReport> output = new ArrayList<ValuationsReport>();
		
		for (SecurityTypeCode value : SecurityTypeCode.values()) {
			
			ValuationsReport valuationReport;
			
			ValuationsReport existingValuationReport = valuationsReportRepository.findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIs(valuationTarget.getPortfolioCode(), value.getCode(), valuationTarget.getValueDate());
			
			if (existingValuationReport != null) {
				valuationReport = valuationsReportRepository.findOne(existingValuationReport.getId());
			} else {
				valuationReport = new ValuationsReport();
				valuationReport.setCreatedUser(utilities.getCurrentUsername());
				valuationReport.setCreatedDate(valuationTarget.getCreatedDate());
			}
			
			// UQRC: LST_UPDTD_TS isn't triggered on GMRADM.TPORT_VALUTN_SUM
			valuationReport.setPortfolioCode(valuationTarget.getPortfolioCode());
			valuationReport.setEffectiveDate(valuationTarget.getValueDate());
			valuationReport.setRunTimestamp(new Date());
			valuationReport.setTotalValue(valuationTarget.getTotalValue());
			valuationReport.setDatasourceFileDAO(valuationTarget.getDatasourceFileDAO());
			valuationReport.setUpdatedUser(utilities.getCurrentUsername());
			// UQRC: Remove below column from database table?
			valuationReport.setPortfolioValuationTypeCode(DatabaseConstants.PORTFOLIO_VALUATION_TYPE_CODE_CURRENT);

			switch (value) {
				case DERIVATIVES :	
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getDerivitivesValue());
					output.add(valuationReport);
					
					break;
				case EQUITY :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getEquityValue());
					output.add(valuationReport);
					
					break;
				case FUTURES :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getFuturesValue());
					output.add(valuationReport);
					
					break;
				case FORWARD_FOREX :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getForwardForiegnExchangeValue());
					output.add(valuationReport);
					
					break;
				case LIQUIDITY :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getLiquidityValue());
					output.add(valuationReport);
					
					break;
				case FIXED_INTEREST :
					valuationReport.setSecurityTypeCode(value.getCode());
					valuationReport.setValuationValue(valuationTarget.getFixedInterestValue());
					output.add(valuationReport);
					
			}

		}

		return output;
	}
}

com.vanguard.corp.ics.sdt.service.impl.attributionsummary
		AttributionSummaryConverter.java

package com.vanguard.corp.ics.sdt.service.impl.attributionsummary;

import java.util.ArrayList;
import java.util.List;

import com.vanguard.corp.ics.dao.target.FakeAttributionSummaryDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;

public interface AttributionSummaryConverter {
	
	
	boolean handles(String attributionSummaryTypeCode);

	List<AttributionSummary> convert(List<FakeAttributionSummaryDAO> list);
	
	
	public abstract class BaseConverter implements AttributionSummaryConverter {

		@Override
		public final List<AttributionSummary> convert(final List<FakeAttributionSummaryDAO> list) {

			final List<FakeAttributionSummaryDAO> modified = doPreConversionModification(list);
			final List<AttributionSummary> converted = new ArrayList<>(modified.size());

			AttributionSummary attributionSummary;
			for (FakeAttributionSummaryDAO dao : modified) {
				attributionSummary = new AttributionSummary();
				attributionSummary.setEffectiveDate(dao.getEffectiveDate());
				attributionSummary.setPortId(dao.getPortId());
				attributionSummary.setName(dao.getName());
                attributionSummary.setOneMonthVal(dao.getOneMonthVal());
				attributionSummary.setThrMonthVal(dao.getThrMonthVal());
				attributionSummary.setSixMonthVal(dao.getSixMonthVal());
				attributionSummary.setNineMonthVal(dao.getNineMonthVal());
				attributionSummary.setTwlveMonthVal(dao.getTwlveMonthVal());
				attributionSummary.setYyToDTVal(dao.getYyToDTVal());
				attributionSummary.setEffectiveBeginDate(dao.getEffectiveBeginDate());
				attributionSummary.setEffectiveEndDate(dao.getEffectiveEndDate());
				attributionSummary.setLastUpdatedUserId(dao.getLastUpdatedUserId());
				attributionSummary.setLastUpdatedDate(dao.getLastUpdatedDate());
				converted.add(attributionSummary);
			}

			return doPostConversionModification(converted);
		}

		private List<FakeAttributionSummaryDAO> doPreConversionModification(List<FakeAttributionSummaryDAO> list)
		{
			return list;
		}
		
		protected List<AttributionSummary> doPostConversionModification(List<AttributionSummary> converted) {
			return converted;
		}

		
	}

}

		AttributionSummaryRepoWrapper.java

package com.vanguard.corp.ics.sdt.service.impl.attributionsummary;

import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.inject.Inject;
import javax.inject.Named;
import javax.transaction.Transactional;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.dao.impl.repository.AttributionSummaryRepository;


public interface AttributionSummaryRepoWrapper {
	
	List<AttributionSummary> retrieveAll(Date effectiveDate);

	List<AttributionSummary> retrieveAll(Date effectiveDate, String portId);

	void logicalDelete(Date effectiveDate, String portId);

	List<AttributionSummary> saveAll(List<AttributionSummary> saveList);
	
	
	@Named
	public static class Impl implements AttributionSummaryRepoWrapper {
		
		@Inject
		private AttributionSummaryRepository repo;
		
		@Override
		public List<AttributionSummary> retrieveAll(final Date effectiveDate) {
			return repo.findByEffectiveDate(effectiveDate);
		}
		
		@Override
		public List<AttributionSummary> retrieveAll(final Date effectiveDate, final String portId) {
			return repo.findByEffectiveDateAndPortId(effectiveDate, portId);
		}
		
		@Override
		@Transactional
		public void logicalDelete(final Date effectiveDate, final String portId) {

			List<AttributionSummary> storedAttributionSummary = repo.findByEffectiveDateAndPortIdAndEffectiveEndDateIsNull(effectiveDate, portId);
			for (AttributionSummary attributionSummary : storedAttributionSummary) {
				attributionSummary.setEffectiveEndDate(new Date());
			}
		}
		
		@Override
		@Transactional
		public List<AttributionSummary> saveAll(final List<AttributionSummary> saveList) {
			if (saveList.isEmpty()) {
				return saveList;
			}

			logicalDeleteBeforeSaving(saveList);
			return repo.save(saveList);
		}

		private void logicalDeleteBeforeSaving(final List<AttributionSummary> saveList) {
			Set<DeleteCombo> toBeDeleted = new HashSet<>();

			for (AttributionSummary attributionSummary : saveList) {
				toBeDeleted.add(new DeleteCombo(attributionSummary.getPortId()));
			}

			Date asOfDate = saveList.get(0).getEffectiveDate();
			Iterator<DeleteCombo> iterator = toBeDeleted.iterator();
			while (iterator.hasNext()) {
				DeleteCombo deleteMe = iterator.next();
				logicalDelete(asOfDate, deleteMe.portId);
			}
		}
		
	}
	
	public static class DeleteCombo {

		final String portId;
		
		DeleteCombo(final String portId) {
			Assert.notNull(portId);
			this.portId = portId;
			
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (!(obj instanceof AttributionSummaryRepoWrapper.DeleteCombo)) {
				return false;
			}
			DeleteCombo that = (DeleteCombo) obj;
			return this.portId.equals(that.portId);
		}

		@Override
		public int hashCode() {
			int hash = 17;
			hash = hash * 31 + this.portId.hashCode();
			return hash;
		}
	}


	

}

		AttributionSummaryTransferService.java


package com.vanguard.corp.ics.sdt.service.impl.attributionsummary;

import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.FakeAttributionSummaryDAO;
import com.vanguard.corp.ics.repository.target.FakeAttributionSummaryRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AttributionSummary;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveCharacteristicsException;

public class AttributionSummaryTransferService implements TransferService {
	
//	@Inject
//	private FactsetMonthlyAttributionSummaryRepository readRepo;
	
	@Inject
	private FakeAttributionSummaryRepository readRepo;

	@Inject
	private AttributionSummaryConverter converter;

	@Inject
	private AttributionSummaryRepoWrapper writeRepo;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}

	@Override
	public boolean handles(final Date effectiveDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.ATTRIBUTION_SUMMARY;
	}

	@Override
	public void transfer(final Date effectiveDate, final String portId, final HttpServletRequest request) {

		Assert.notNull(effectiveDate, "[AttributionSummaryTransferService.transfer] asOfDate cannot be null");

		List<FakeAttributionSummaryDAO> readList = readAttributionSummary(effectiveDate, portId);
		if (!readList.isEmpty()) {
			saveAttributionSummary(readList);
		}
	}

	private List<FakeAttributionSummaryDAO> readAttributionSummary(final Date effectiveDate, final String portId) {
		List<FakeAttributionSummaryDAO> readList;
		try {
			if (StringUtils.isEmpty(portId)) {
				readList = readRepo.findAllByeffectiveDate(effectiveDate);
			}
			else {
				readList = readRepo.findAllByeffectiveDateAndPortId(effectiveDate, portId);
			}
			
			Assert.notNull(readList, "Target attribution summary list is null");
		}
		catch (Exception e) {
			final String msg = String.format(
					"[AttributionSummaryTransferService.transfer] %s thrown while reading attribution summary; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new ReadCharacteristicsException(msg, e);
		}
		
		return readList;
	}

	private void saveAttributionSummary(List<FakeAttributionSummaryDAO> readList) {
	
		if (!readList.isEmpty()) {
			final List <AttributionSummary> converted = converter.convert(readList);
		
		
		try {
			writeRepo.saveAll(converted);
		}
		catch (Exception e) {
			final String msg = String.format(
					"[AttributionSummaryTransferService.transfer] %s thrown while saving Attribution; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new SaveCharacteristicsException(msg, e);
			}
		}
	}



}
		FactsetMonthlyAttributionSummaryTargetDAO.java


package com.vanguard.corp.ics.sdt.service.impl.attributionsummary;

public class FactsetMonthlyAttributionSummaryTargetDAO {

}


com.vanguard.corp.ics.sdt.service.impl.characteristics
	
		CharacteristicsConverter.java


package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

public interface CharacteristicsConverter {

	public static final int CHARACTERISTICS_SCALE = 1;

	boolean handles(String characteristicsTypeCode);

	List<Characteristics> convert(List<FactsetMonthlyCharacteristicsTargetDAO> list);

	public abstract class BaseConverter implements CharacteristicsConverter {

		@Override
		public final List<Characteristics> convert(final List<FactsetMonthlyCharacteristicsTargetDAO> list) {

			final List<FactsetMonthlyCharacteristicsTargetDAO> modified = doPreConversionModification(list);
			final List<Characteristics> converted = new ArrayList<>(modified.size());

			Characteristics ch;
			for (FactsetMonthlyCharacteristicsTargetDAO dao : modified) {
				ch = new Characteristics();
				ch.setEffectiveDate(dao.getEffectiveDate());
				ch.setPortId(dao.getPortfolioCode());
				ch.setType(dao.getCharacteristicsType());
				ch.setName(dao.getCharacteristicsName());

				ch.setPortfolio(round(dao.getPortfolioValue()));
				ch.setBenchmark(round(dao.getBenchMarkValue()));

				converted.add(ch);
			}

			return doPostConversionModification(converted);
		}

		/**
		 * default implementation, can be overridden in subclass
		 * 
		 * @param list
		 * @return
		 */
		protected List<FactsetMonthlyCharacteristicsTargetDAO> doPreConversionModification(List<FactsetMonthlyCharacteristicsTargetDAO> list) {
			return list;
		}

		/**
		 * default implementation, can be overridden in subclass
		 * 
		 * @param converted
		 * @return
		 */
		protected List<Characteristics> doPostConversionModification(List<Characteristics> converted) {
			return converted;
		}

		private BigDecimal round(Double value) {
			if (value == null) {
				return null;
			}
			
			BigDecimal bigDecimalForm = new BigDecimal(String.format("%.5f", value));
			return bigDecimalForm.setScale(CHARACTERISTICS_SCALE, RoundingMode.HALF_UP);

		}

	}

}

		CharacteristicsRepoWrapper.java


package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.inject.Inject;
import javax.inject.Named;
import javax.transaction.Transactional;

import org.springframework.util.Assert;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.dao.impl.repository.CharacteristicsRepository;

public interface CharacteristicsRepoWrapper {

	List<Characteristics> retrieveAll(Date asOfDate);

	List<Characteristics> retrieveAll(Date asOfDate, String portId);

	void logicalDelete(Date asOfDate, String portId, String characteristicsType);

	List<Characteristics> saveAll(List<Characteristics> saveList);

	@Named
	public static class Impl implements CharacteristicsRepoWrapper {

		@Inject
		private CharacteristicsRepository repo;

		@Override
		public List<Characteristics> retrieveAll(final Date asOfDate) {
			return repo.findByEffectiveDate(asOfDate);
		}

		@Override
		public List<Characteristics> retrieveAll(final Date asOfDate, final String portId) {
			return repo.findByEffectiveDateAndPortId(asOfDate, portId);
		}

		@Override
		@Transactional
		public void logicalDelete(final Date asOfDate, final String portId, final String characteristicsType) {

			List<Characteristics> storedCharacteristics = repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, portId, characteristicsType);
			for (Characteristics characteristics : storedCharacteristics) {
				characteristics.setEffectiveEndDate(new Date());
			}
		}

		@Override
		@Transactional
		public List<Characteristics> saveAll(final List<Characteristics> saveList) {
			if (saveList.isEmpty()) {
				return saveList;
			}

			logicalDeleteBeforeSaving(saveList);
			return repo.save(saveList);
		}

		private void logicalDeleteBeforeSaving(final List<Characteristics> saveList) {
			Set<DeleteCombo> toBeDeleted = new HashSet<>();

			for (Characteristics characteristics : saveList) {
				toBeDeleted.add(new DeleteCombo(characteristics.getPortId(), characteristics.getType()));
			}

			Date asOfDate = saveList.get(0).getEffectiveDate();
			Iterator<DeleteCombo> iterator = toBeDeleted.iterator();
			while (iterator.hasNext()) {
				DeleteCombo deleteMe = iterator.next();
				logicalDelete(asOfDate, deleteMe.portId, deleteMe.type);
			}
		}

	}

	public static class DeleteCombo {

		final String portId;
		final String type;

		DeleteCombo(final String portId, final String type) {
			Assert.notNull(portId);
			Assert.notNull(type);
			this.portId = portId;
			this.type = type;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (!(obj instanceof CharacteristicsRepoWrapper.DeleteCombo)) {
				return false;
			}
			DeleteCombo that = (DeleteCombo) obj;
			return this.portId.equals(that.portId) && this.type.equals(that.type);
		}

		@Override
		public int hashCode() {
			int hash = 17;
			hash = hash * 31 + this.portId.hashCode();
			hash = hash * 31 + this.type.hashCode();
			return hash;
		}
	}
}
	
		CharacteristicsTransferService.java


package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.springframework.util.Assert;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveCharacteristicsException;

@Named
public class CharacteristicsTransferService implements TransferService {

	@Inject
	private FactsetMonthlyCharacteristicsRepository readRepo;

	@Inject
	private List<CharacteristicsConverter> converters;

	@Inject
	private CharacteristicsRepoWrapper writeRepo;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}

	@Override
	public boolean handles(final Date asOfDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.CHARACTERISTICS;
	}

	@Override
	public void transfer(final Date asOfDate, final String portId, final HttpServletRequest request) {

		Assert.notNull(asOfDate, "[PortfolioCharacteristicsTransferService.transfer] asOfDate cannot be null");

		List<FactsetMonthlyCharacteristicsTargetDAO> readList = readCharacteristics(asOfDate, portId);
		if (!readList.isEmpty()) {
			saveCharacteristics(readList);
		}
	}

	private List<FactsetMonthlyCharacteristicsTargetDAO> readCharacteristics(final Date asOfDate, final String portId) {
		List<FactsetMonthlyCharacteristicsTargetDAO> readList;
		try {
			if (StringUtils.isEmpty(portId)) {
				readList = readRepo.findByEffectiveDate(asOfDate);
			}
			else {
				readList = readRepo.findByEffectiveDateAndPortfolioCode(asOfDate, portId);
			}
			
			Assert.notNull(readList, "Target characteristics list is null");
		}
		catch (Exception e) {
			final String msg = String.format(
					"[PortfolioCharacteristicsTransferService.transfer] %s thrown while reading characteristics; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new ReadCharacteristicsException(msg, e);
		}
		
		return readList;
	}

	private void saveCharacteristics(List<FactsetMonthlyCharacteristicsTargetDAO> readList) {
		final List<Characteristics> converted = new ArrayList<>();
		final Map<String, List<FactsetMonthlyCharacteristicsTargetDAO>> targetDaosByCharacteristicsCode = groupCharacteristicsByType(readList);
		
		boolean foundConverter;
		for (Entry<String, List<FactsetMonthlyCharacteristicsTargetDAO>> characteristicsByType : targetDaosByCharacteristicsCode.entrySet()) {
			foundConverter = false;
			for (CharacteristicsConverter converter : converters) {
				if (converter.handles(characteristicsByType.getKey())) {
					converted.addAll(converter.convert(characteristicsByType.getValue()));
					foundConverter = true;
					break;
				}
			}
			if (!foundConverter) {
				final String msg = String.format(
						"[PortfolioCharacteristicsTransferService.transfer] Unknown characteristics type code: %s"
						, characteristicsByType.getKey()
						);
				throw new SaveCharacteristicsException(msg);
			}
		}
		
		try {
			writeRepo.saveAll(converted);
		}
		catch (Exception e) {
			final String msg = String.format(
					"[PortfolioCharacteristicsTransferService.transfer] %s thrown while saving characteristics; msg:%s"
					, e.getClass().getSimpleName()
					, e.getMessage()
					);
			throw new SaveCharacteristicsException(msg, e);
		}
	}

	private Map<String, List<FactsetMonthlyCharacteristicsTargetDAO>> groupCharacteristicsByType(final List<FactsetMonthlyCharacteristicsTargetDAO> readList) {
		final Map<String, List<FactsetMonthlyCharacteristicsTargetDAO>> map = new HashMap<>();
		
		List<FactsetMonthlyCharacteristicsTargetDAO> list;
		for (FactsetMonthlyCharacteristicsTargetDAO dao : readList) {
			list = map.get(dao.getCharacteristicsType());
			if (list == null) {
				list = new ArrayList<>();
				map.put(dao.getCharacteristicsType(), list);
			}
			
			list.add(dao);
		}
		
		return map;
	}

}

		CountryAllocationConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class CountryAllocationConverter extends MagicRoundingConverter {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.COUNTRY_ALLOCATION.getCode().equals(characteristicsTypeCode);
	}

}

		CurrencyAllocationConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class CurrencyAllocationConverter extends MagicRoundingConverter {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.CURRENCY_ALLOCATION.getCode().equals(characteristicsTypeCode);
	}

}

		MagicRoundingConverter.java


package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

public abstract class MagicRoundingConverter extends CharacteristicsConverter.BaseConverter {

	private static final BigDecimal ONE_HUNDRED = new BigDecimal("100.0");

	@Override
	protected List<Characteristics> doPostConversionModification(final List<Characteristics> list) {
		final List<Characteristics> converted = new ArrayList<>(list.size());

		Map<String, List<Characteristics>> byPortId = groupCharacteristicsByPortId(list);
		for (Entry<String, List<Characteristics>> entry : byPortId.entrySet()) {
			converted.addAll(magicRound(entry.getValue()));
		}

		return converted;
	}

	protected Map<String, List<Characteristics>> groupCharacteristicsByPortId(List<Characteristics> list) {
		final Map<String, List<Characteristics>> map = new HashMap<>();

		String portId;
		List<Characteristics> characteristicsByPortId;
		for (Characteristics ch : list) {
			portId = ch.getPortId();
			characteristicsByPortId = map.get(portId);

			if (characteristicsByPortId == null) {
				characteristicsByPortId = new ArrayList<>();
				map.put(portId, characteristicsByPortId);
			}

			characteristicsByPortId.add(ch);
		}

		return map;
	}

	protected List<Characteristics> magicRound(final List<Characteristics> characteristicsByPortId) {
		Characteristics maxPortfolioOb = null;
		Characteristics maxBenchmarkOb = null;
		BigDecimal maxPortfolioValue = new BigDecimal("-999999999999.9");
		BigDecimal maxBenchmarkValue = new BigDecimal("-999999999999.9");
		BigDecimal totalPortfolioValue = new BigDecimal("0.0");
		BigDecimal totalBenchmarkValue = new BigDecimal("0.0");
		BigDecimal portfolioValue;
		BigDecimal benchmarkValue;
		boolean foundNullPortfolio = false;
		boolean foundNullBenchmark = false;

		for (Characteristics ch : characteristicsByPortId) {
			portfolioValue = ch.getPortfolio();
			if (portfolioValue == null) {
				foundNullPortfolio = true;
			}
			else {
				totalPortfolioValue = totalPortfolioValue.add(portfolioValue);
				
				if (portfolioValue.compareTo(maxPortfolioValue) > 0) {
					maxPortfolioValue = portfolioValue;
					maxPortfolioOb = ch;
				}
			}
			
			benchmarkValue = ch.getBenchmark();
			if (benchmarkValue == null) {
				foundNullBenchmark = true;
			}
			else {
				totalBenchmarkValue = totalBenchmarkValue.add(benchmarkValue);
				
				if (benchmarkValue.compareTo(maxBenchmarkValue) > 0) {
					maxBenchmarkValue = benchmarkValue;
					maxBenchmarkOb = ch;
				}
			}
		}
		
		if (!foundNullPortfolio) {
			BigDecimal diffPortfolio = ONE_HUNDRED.subtract(totalPortfolioValue);
			if (diffPortfolio.compareTo(BigDecimal.ZERO) != 0) {
				maxPortfolioOb.setPortfolio(maxPortfolioOb.getPortfolio().add(diffPortfolio));
			}
		}
		
		if (!foundNullBenchmark) {
			BigDecimal diffBenchmark = ONE_HUNDRED.subtract(totalBenchmarkValue);
			if (diffBenchmark.compareTo(BigDecimal.ZERO) != 0) {
				maxBenchmarkOb.setBenchmark(maxBenchmarkOb.getBenchmark().add(diffBenchmark));
			}
		}

		return characteristicsByPortId;
	}
}


		MarketSegmentationByCapAllocationConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class MarketSegmentationByCapAllocationConverter extends MagicRoundingConverter {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.MARKET_SEGMENTATION.getCode().equals(characteristicsTypeCode);
	}

}


		PortfolioCharacteristicsConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class PortfolioCharacteristicsConverter extends CharacteristicsConverter.BaseConverter {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode().equals(characteristicsTypeCode);
	}

}

		RegionalAllocationConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class RegionalAllocationConverter extends MagicRoundingConverter {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.REGIONAL_ALLOCATION.getCode().equals(characteristicsTypeCode);
	}

}

	SectorAllocationConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class SectorAllocationConverter extends MagicRoundingConverter {

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.SECTOR_ALLOCATION.getCode().equals(characteristicsTypeCode);
	}

}

	TopTenHoldingsCharacteristicsConverter.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import java.util.List;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;

@Named
public class TopTenHoldingsCharacteristicsConverter extends MagicRoundingConverter {

	private static final int MAGIC_ROUNDING_MAX_COUNT = 9;

	@Override
	public boolean handles(String characteristicsTypeCode) {
		return CharacteristicsType.TOP_TEN_HOLDINGS.getCode().equals(characteristicsTypeCode);
	}

	@Override
	protected List<Characteristics> magicRound(List<Characteristics> characteristicsByPortId) {
		if (characteristicsByPortId.size() > MAGIC_ROUNDING_MAX_COUNT) {
			return characteristicsByPortId;
		}
		
		return super.magicRound(characteristicsByPortId);
	}
}


com.vanguard.corp.ics.sdt.service.impl.risksummary
	LimitValidator.java

package com.vanguard.corp.ics.sdt.service.impl.risksummary;

import javax.inject.Named;

import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;

@Named
public class LimitValidator {

	public boolean isValid(AnalyticsTypeCode analyticType, Double lowerLimit, Double upperLimit,
			Double splitLimit) {

		// Analytic type is not ExAnte. This is independent of upper limit and split limit. Lower limit can be empty or populated
		boolean valid = analyticType != AnalyticsTypeCode.EX_ANTE_RISK;

		// Analytic type is ExAnte and all limits are empty
		valid = valid || (analyticType == AnalyticsTypeCode.EX_ANTE_RISK
				&& (lowerLimit == null && upperLimit == null && splitLimit == null));

		// Analytic type is ExAnte. Only lower limit is populated or lower, upper, and split are all populated
		valid = valid || (analyticType == AnalyticsTypeCode.EX_ANTE_RISK && lowerLimit != null
				&& ((upperLimit == null && splitLimit == null) || (upperLimit != null && splitLimit != null)));

		return valid;
	}
}

	RiskSummaryServiceImpl.java

package com.vanguard.corp.ics.sdt.service.impl.risksummary;

import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.repository.PortfolioLimitRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;

@Named
public class RiskSummaryServiceImpl implements TransferService {
	
	private static final Logger LOG = LoggerFactory.getLogger(RiskSummaryServiceImpl.class);
	
	@Inject 
	Utilities utilities;
	
	@Inject
	ProductPortalService productPortalService;
	
	@Inject
	PortfolioLimitRepository portfolioLimitRepository;
	
	@Inject
	LimitValidator limitValidator;
	
	@Override
	public Priority getPriority() {
		return TransferService.Priority.MEDIUM;
	}
	
	@Override
	public boolean handles(final Date asOfDate, final String portId, final DataSetType dataSetType, final HttpServletRequest request) {
		return dataSetType == null || dataSetType == DataSetType.RISK_SUMMARY;
	}
	
	@Override
	public void transfer(Date asOfDate, String portId, HttpServletRequest request) {
		List<PortalProduct> products = productPortalService.getProducts(request);
		
		if (StringUtils.isEmpty(portId)) {
			for (PortalProduct product : products) {
				moveRiskSummaryDataToReport(product, asOfDate, request);
			}
		}
		else {
			moveRiskSummaryDataToReport(productPortalService.getProduct(products,portId), asOfDate, request);
		}
	}

	private void moveRiskSummaryDataToReport(PortalProduct product, Date reportDate, HttpServletRequest request) {
		org.springframework.util.Assert.notNull(product);
		
		String portId = product.getProductCode();
		
		for (AnalyticsTypeCode analyticType : AnalyticsTypeCode.values()) {
			Limit limit = portfolioLimitRepository.findByPortfolioCodeAndLimitTypeCodeAndEffectiveBeginDate(portId, analyticType.getCode(), reportDate);
			
			if (limit == null) {
				limit = new Limit();
				limit.setEffectiveBeginDate(reportDate);
			}
			
			limit.setPortfolioCode(portId);
			limit.setLimitTypeCode(analyticType.getCode());
			limit.setLimitName(analyticType.getName());	
			limit.setUpdatedUser(utilities.getCurrentUsername());
			
			Double lowerLimit = getLowerLimit(product, analyticType);
			Double upperLimit = getUpperLimit(product, analyticType);
			Double splitLimit = (analyticType == AnalyticsTypeCode.EX_ANTE_RISK) ? product.getExAnteFumSplitLimit() : null;
			
			if (limitValidator.isValid(analyticType, lowerLimit, upperLimit, splitLimit)) {
				LOG.info("Valid limits lower:{} upper:{} split:{} for {} on {} portfolio", lowerLimit, upperLimit, splitLimit, analyticType, portId);
				
			    limit.setLowerLimitValue(lowerLimit);
			    limit.setUpperLimitValue(upperLimit);
			    limit.setFumSplitLimitValue(splitLimit);
			    
			    portfolioLimitRepository.save(limit);
			} else {
				LOG.error("Invalid limits lower:{} upper:{} split:{} for {} on {} portfolio", lowerLimit, upperLimit, splitLimit, analyticType, portId);
			}
		}
	}
	
	private Double getLowerLimit(PortalProduct product, AnalyticsTypeCode analyticType) {
		Double limit;
		
		if (analyticType == AnalyticsTypeCode.EX_ANTE_RISK && product.getExAnteMaxBreachIMA() != null) {
			Double benchmarkValue = Double.parseDouble(product.getExAnteMaxBreachIMA());	
			limit = benchmarkValue/100;
		}  else if ((analyticType == AnalyticsTypeCode.ONE_YR_EX_POST || analyticType == AnalyticsTypeCode.THREE_YR_EX_POST) && product.getExPostMaxBreachIMA() != null) {
			Double benchmarkValue = Double.parseDouble(product.getExPostMaxBreachIMA());
			limit = benchmarkValue/100;
		} else {
			limit = null;
		}

		return limit;
	}
	
	private Double getUpperLimit(PortalProduct product, AnalyticsTypeCode analyticType) {
		Double limit;
		
		if (analyticType == AnalyticsTypeCode.EX_ANTE_RISK && product.getExAnteMaxBreachIMAAbvLmt() != null) {
			Double benchmarkValue = Double.parseDouble(product.getExAnteMaxBreachIMAAbvLmt());
			limit = benchmarkValue/100;
		} else {
			limit = null;
		}
		
		return limit;
	}
}

com.vanguard.corp.ics.sdt.webservice
		Application.java

package com.vanguard.corp.ics.sdt.webservice;

import java.util.EnumSet;

import javax.inject.Inject;
import javax.servlet.DispatcherType;
import javax.servlet.Filter;
import javax.sql.DataSource;

import org.apache.catalina.core.StandardHost;
import org.apache.catalina.startup.Tomcat;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.actuate.autoconfigure.ManagementServerProperties;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.FilterRegistrationBean;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer;
import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.ImportResource;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.Environment;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

import com.vanguard.cto.aws.gemfire.GemfireConfig;
import com.vanguard.cto.support.SpringBootConfig;
import com.vanguard.servlet.filter.F5Filter;
import com.vanguard.spring.connector.VanguardTomcatConnectorCustomizer;

@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class,
		HibernateJpaAutoConfiguration.class })
@EnableCircuitBreaker
@ImportResource({ "classpath*:/META-INF/**/spring-bootstrap.xml", "classpath*:/META-INF/**/spring-bootstrap-standalone.xml" })
public class Application {

	public static final String BASE_PATH = "rs";
	protected static final boolean IS_OS_WINDOWS = SystemUtils.IS_OS_WINDOWS;
	protected static final String LOCAL_RTEID = "inte";
	protected static final String LOCAL_SPRING_PROFILE = "local";
	protected static final String KEY_RTEID = "RTEID";

	@Inject
	private Environment env;

	public static void main(String[] args) {
		GemfireConfig.initialize(Application.class);
		SpringBootConfig.initialize(Application.class);
		SpringApplication app = new SpringApplication(Application.class);
		setLocalProperties(app);
		app.run(args);
	}

	/**
	 * For local testing, default to RTE=inte and spring.profiles.active=local,
	 * both of which can be overriden from the command line
	 * 
	 * @param app
	 */
	protected static void setLocalProperties(SpringApplication app) {
		if (IS_OS_WINDOWS) {
			System.setProperty(KEY_RTEID, System.getProperty(KEY_RTEID, LOCAL_RTEID));
			app.setAdditionalProfiles(LOCAL_SPRING_PROFILE);
		}
	}

	@Bean
	public EmbeddedServletContainerFactory servletContainer() {
		TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory() {

			@Override
			protected TomcatEmbeddedServletContainer getTomcatEmbeddedServletContainer(Tomcat tomcat) {
				((StandardHost) tomcat.getHost()).setErrorReportValveClass(StringUtils.EMPTY);
				return super.getTomcatEmbeddedServletContainer(tomcat);
			}
		};
		tomcat.addConnectorCustomizers(new VanguardTomcatConnectorCustomizer());
		return tomcat;
	}

	/**
	 * Needed to FAKE Auth with SUDS lib, must to set to order 0 and MUST appear
	 * BEFORE ContextFilter in java source
	 */

	@Bean
	@Conditional({ WindowsCondition.class, NonProductionCondition.class })
	public FilterRegistrationBean ntFilter() {
		FilterRegistrationBean registration = new FilterRegistrationBean(new NTHeaderFilter());
		registration.setName("NTFilter");
		registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
		registration.addUrlPatterns("/*");
		return registration;
	}

	// Must be after ntfilter for SUDS lib

	@Bean
	public FilterRegistrationBean requestContextFilter() {
		FilterRegistrationBean registration = new FilterRegistrationBean(new org.springframework.web.filter.RequestContextFilter());
		registration.setName("RequestContextFilter");
		registration.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
		registration.addUrlPatterns("/*");
		return registration;
	}

	@Bean
	public FilterRegistrationBean f5Filter() {
		FilterRegistrationBean registration = new FilterRegistrationBean(new F5Filter());
		registration.setName("F5Filter");
		registration.addUrlPatterns("/" + BASE_PATH + "/*");
		return registration;
	}

	@Bean
	public FilterRegistrationBean springSecurityFilterChain() {
		FilterRegistrationBean filterRegistration = new FilterRegistrationBean(new org.springframework.web.filter.DelegatingFilterProxy());
		filterRegistration.setName("SpringSecurityFilterChain");
		filterRegistration.setOrder(Ordered.HIGHEST_PRECEDENCE + 2);
		filterRegistration.addUrlPatterns("/*");
		return filterRegistration;
	}

	/**
	 * This method is only used by the exemplar examples and can be safely
	 * removed
	 * 
	 * @return an H2 datasource
	 */
	@Bean
	public DataSource h2DataSource() {
		EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
		EmbeddedDatabase db = builder.setType(EmbeddedDatabaseType.H2).build();
		return db;
	}

	/**
	 * Initializes and registers the JAX-RS filter implementation, currently
	 * Jersey.
	 * 
	 * @return The JAX-RS filter registration.
	 * @throws ClassNotFoundException
	 * @throws IllegalAccessException
	 * @throws InstantiationException
	 */
	@Bean
	public FilterRegistrationBean jaxrsFilter() throws InstantiationException, IllegalAccessException, ClassNotFoundException {
		FilterRegistrationBean registration = new FilterRegistrationBean();
		Filter filter = (Filter) Class.forName("org.glassfish.jersey.servlet.ServletContainer").newInstance();
		registration.setFilter(filter);
		registration.setName("JerseyFilter");
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		// Set the Jersey filter mapping and context path
		registration.addUrlPatterns("/" + BASE_PATH + "/*");
		registration.addInitParameter("jersey.config.servlet.filter.contextPath", BASE_PATH);
		// Load the common package and application package
		registration.addInitParameter("jersey.config.server.provider.packages", "com.vanguard.jaxrs.feature;com.vanguard.corp.ics.sdt");
		// Enable media type mappings on the URI such as .xml and .json
		registration.addInitParameter("jersey.config.server.mediaTypeMappings", "xml:application/xml, json:application/json");
		// Enable Java bean validation integration
		registration.addInitParameter("jersey.config.beanValidation.enableOutputValidationErrorEntity.servers", "true");
		// Forward 404s to Spring MVC, which serves up the Actuator endpoints
		// and non-jersey resources
		registration.addInitParameter("jersey.config.servlet.filter.forwardOn404", "true");

		if (BooleanUtils.toBoolean(env.getProperty("jersey.config.server.debug"))) {
			// Debug parameter switches
			registration.addInitParameter("jersey.config.server.monitoring.statistics.enabled", "true");
			registration.addInitParameter("jersey.config.server.tracing.type", "ALL");
			registration.addInitParameter("jersey.config.server.tracing.threshold", "VERBOSE");
		}

		// TODO Remove below code after testing
		if (IS_OS_WINDOWS) {
			registration.addInitParameter("jaxrs.config.csrf.enableNullOriginBypass", "true");
			registration.addInitParameter("jaxrs.config.cors.allowedOrigins", "localhost.vanguard.com:8080");
			registration.addInitParameter("jaxrs.config.csrf.enableTokenCheck", "false");
		}
		return registration;
	}

	@Bean
	public ApplicationSecurity applicationSecurity() {
		return new ApplicationSecurity();
	}

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public static class ApplicationSecurity extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			// This disables Spring Security on only the Spring Boot Actuator
			// endpoints.
			http.authorizeRequests().antMatchers("/" + BASE_PATH + "/**").permitAll().and().csrf().disable();
		}
	}

}

		NonProductionCondition.java

package com.vanguard.corp.ics.sdt.webservice;

import java.util.Arrays;
import java.util.List;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class NonProductionCondition implements Condition{

	@Override
	public boolean matches(ConditionContext context,
			AnnotatedTypeMetadata metadata) {
		String environments = "dev,int,inte,sat,catp,prf,test";
		List<String> environmentsList = Arrays.asList(environments.split(","));
		String propertyValue = context.getEnvironment().getProperty("RTEID");
		return environmentsList.contains(propertyValue);
	}

}

	NTHeaderFilter.java

package com.vanguard.corp.ics.sdt.webservice;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

public class NTHeaderFilter implements Filter {
	
	private NTHeaderValues ntHeaderValues = new NTHeaderValues();
	
	public NTHeaderFilter() {
	}

	
	public void destroy() {
	}

	
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException 
	{
		HttpServletRequest req = (HttpServletRequest) request;
		FakeHeadersRequest sdsrw = new FakeHeadersRequest(req);
		chain.doFilter(sdsrw, response);
	}

	
	public void init(FilterConfig fConfig) throws ServletException {
	}

	
	public class FakeHeadersRequest extends HttpServletRequestWrapper {

		public FakeHeadersRequest(HttpServletRequest request) {
			super(request);
		}

		@Override
		public String getHeader(String name) {
			
			if(ntHeaderValues.headerValueMap.containsKey(name)){
				return ntHeaderValues.headerValueMap.get(name);
			}
			return super.getHeader(name);
		}
	}
	
	public class NTHeaderValues {
		
		public Map<String,String> headerValueMap;
		
		public NTHeaderValues(){
			headerValueMap = new HashMap<String,String>();
			headerValueMap.put("SM_UNIVERSALID","UWJA");
			headerValueMap.put("APP_CODE","SDT");
			headerValueMap.put("POID","1232135819");
			headerValueMap.put("SRV_TYPE","INTR");
			headerValueMap.put("Authorization","true");
		}		
	}
	
}

		WindowsCondition.java

package com.vanguard.corp.ics.sdt.webservice;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class WindowsCondition implements Condition{


	@Override
	public boolean matches(ConditionContext context,
			AnnotatedTypeMetadata metadata) {
		return context.getEnvironment().getProperty("os.name").contains("Windows");
	}	
}

com.vanguard.corp.ics.sdt.webservice.resource

		CommentaryDTO.java

package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;

import com.vanguard.validator.constraints.SafeString;

public class CommentaryDTO {
	public static final String PARM_AS_OF_DATE = "asOfDate";
	public static final String PARM_PORT_ID = "portId";
	public static final String PARM_DATA_SET = "dataSet";
	public static final String DATE_PATTERN = "^(\\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$"; // yyyy-MM-dd
	public static final String ALLOWED_CHARS = "_";

	private String Id;
	
	@NotNull
	@Pattern(regexp=DATE_PATTERN)
	private String asOfDate;

	@NotNull
	@SafeString
	private String portId;

	@NotNull
	@SafeString
	private String commentary;

	public String getAsOfDate() {
		return asOfDate;
	}

	public String getCommentary() {
		return commentary;
	}

	public String getId() {
		return Id;
	}

	public String getPortId() {
		return portId;
	}

	public void setAsOfDate(final String asOfDate) {
		this.asOfDate = asOfDate;
	}

	public void setCommentary(final String commentary) {
		this.commentary = commentary;
	}

	public void setId(String id) {
		Id = id;
	}

	public void setPortId(final String portId) {
		this.portId = portId;
	}
}


		CommentaryResource.java

package com.vanguard.corp.ics.sdt.webservice.resource;

import java.util.Date;

import javax.annotation.security.PermitAll;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.container.ResourceContext;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.service.api.CommentaryService;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;

@PermitAll
@Path(CommentaryResource.PATH)
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
@Consumes({ MediaType.APPLICATION_JSON })
public class CommentaryResource {

	public static final String PATH = "commentary";

	private static Logger LOGGER = LoggerFactory.getLogger(CommentaryResource.class);
	private final DateParser dateParser = new DateParser();

	@Context
	private ResourceContext resourceContext;

	@Context
	private HttpServletRequest request;

	@Inject
	private CommentaryService commentaryService;

	@GET
	public Response retrieveCommentary(@NotNull @Valid @QueryParam(value = "asOfDate") String asOfDate,
			@NotNull @Valid @QueryParam(value = "portId") String portId) {
		Date inputDate;

		try {
			inputDate = dateParser.parse(asOfDate);
		} catch (Exception e) {
			LOGGER.error(String.format("[CommentaryResource.retrieveCommentary] %s thrown; msg:%s",
					e.getClass().getSimpleName(), e.getMessage()), e);
			return Response.status(Response.Status.BAD_REQUEST).build();
		}

		CommentaryDTO commentary = commentaryService.getCommentary(portId, inputDate);

		if (commentary != null) {
			System.out.println("Commentary Id: " + commentary.getId());
			System.out.println("Commentary Port Id: " + commentary.getPortId());
			System.out.println("Commentary Date: " + commentary.getAsOfDate());
			System.out.println("Commentary Text: " + commentary.getCommentary());
			System.out.println("Status is: " + Response.ok().entity(commentary).build().getStatus());
			
			return Response.ok().entity(commentary).build();
			
		}else{
			System.out.println("Could not find Mandate with asOfDate: " + asOfDate + " and portId: " + portId);
			System.out.println("Reponse: " + Response.status(Response.Status.BAD_REQUEST).build());
			
			return Response.status(Response.Status.BAD_REQUEST).build();
		}
		
	}

	@POST
	public Response updateCommentary(@Valid CommentaryDTO commentary) {

		commentaryService.saveOrUpdateCommentary(commentary);

		return Response.ok().entity(commentary).build();
	}
}


		DataTransferParameters.java


package com.vanguard.corp.ics.sdt.webservice.resource;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.ws.rs.QueryParam;

import com.vanguard.validator.constraints.SafeString;

public class DataTransferParameters {

	public static final String PARM_AS_OF_DATE = "asOfDate";
	public static final String PARM_PORT_ID = "portId";
	public static final String PARM_DATA_SET = "dataSet";
	public static final String DATE_PATTERN = "^(\\d{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$"; // yyyy-MM-dd
	public static final String ALLOWED_CHARS = "_";

	@NotNull
	@Pattern(regexp=DATE_PATTERN)
	@QueryParam(PARM_AS_OF_DATE)
	private String asOfDate;

	@SafeString
	@QueryParam(PARM_PORT_ID)
	private String portId;

	@SafeString(allow=ALLOWED_CHARS)
	@QueryParam(PARM_DATA_SET)
	private String dataSet;

	public String getAsOfDate() {
		return asOfDate;
	}

	public void setAsOfDate(final String asOfDate) {
		this.asOfDate = asOfDate;
	}

	public String getPortId() {
		return portId;
	}

	public void setPortId(final String portId) {
		this.portId = portId;
	}

	public String getDataSet() {
		return dataSet;
	}

	public void setDataSet(final String dataSet) {
		this.dataSet = dataSet;
	}
}

		DataTransferResource.java


package com.vanguard.corp.ics.sdt.webservice.resource;

import java.util.Date;

import javax.annotation.security.PermitAll;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import javax.ws.rs.BeanParam;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.container.ResourceContext;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;

@PermitAll
@Path(DataTransferResource.PATH)
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public class DataTransferResource {

	public static final String PATH = "transfer";
	public static final String DATE_FORMAT = "yyyy-MM-dd";
	
	private static Logger LOGGER = LoggerFactory.getLogger(DataTransferResource.class);
	private final DateParser dateParser = new DateParser();

	@Context
	private ResourceContext resourceContext;

	@Context
	private HttpServletRequest request;

	@Inject
	private DataTransferService service;

	@GET
	public Response transfer(@Valid @BeanParam DataTransferParameters parms) {
		Date asOfDate;
		DataSetType dataSetType;

		try {
			asOfDate = dateParser.parse(parms.getAsOfDate());
			dataSetType = parseDataSet(parms.getDataSet());
		}
		catch (Exception e) {
			LOGGER.error(String.format("[DataTransferResource.transfer] %s thrown; msg:%s",
					e.getClass().getSimpleName(), e.getMessage()), e);
			return Response.status(Response.Status.BAD_REQUEST).build();
		}

		service.transfer(asOfDate, parms.getPortId(), dataSetType, request);
		return Response.ok().build();
	}

	private DataSetType parseDataSet(final String dataSet) {
		return dataSet == null ? null : DataSetType.valueOf(dataSet);
	}
}


		TomcatDefaultErrorResource.java


package com.vanguard.corp.ics.sdt.webservice.resource;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * Embedded tomcat is forwarding 500s to this url as the catch all error handler
 * This will inspect the incoming request and log something.
 * Removing this resource causes the 500s to convert to 404s.
 * 
 * TODO This should be moved to spring-boot-common
 * 
 * @author ush8
 *
 */
@Component
@Path("/error")
public class TomcatDefaultErrorResource {

	private static final String ERROR = "ERROR";
	private Logger logger = LoggerFactory.getLogger(TomcatDefaultErrorResource.class);

	@GET
	public String handleError(@Context HttpServletResponse response, @Context HttpServletRequest request) throws IOException {

		// this is from tomcat's default error handler logic. See StandardHostValve.throwable
		if (ERROR.equals(getDispatcherType(request))) {
			Integer originalStatusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
			String originalURL = (String) request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI);
			String originalMessage = (String) request.getAttribute(RequestDispatcher.ERROR_MESSAGE);
			Throwable originalThrown = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);

			response.setStatus(originalStatusCode.intValue());
			logger.error("Error From URL:" + originalURL + " Message:" + originalMessage + " StatusCode:" + originalStatusCode, originalThrown);
		} else {
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		response.setContentLength(0);
		response.getOutputStream().flush();
		response.getOutputStream().close();
		
		return null;
	}

	protected String getDispatcherType(HttpServletRequest request) {
		return request.getDispatcherType().toString();
	}
	
}



------------------------------------------------------
src/test/java

com.vanguard.corp.ics.sdt.behaviors
	
	CommentaryEndpointTest.java

package com.vanguard.corp.ics.sdt.behaviors;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import org.junit.Before;
import org.junit.Test;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.service.api.CommentaryService;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryResource;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;

public class CommentaryEndpointTest extends CommentaryServiceApplicationTester {

	private CommentaryService mockService;

	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		mockService = this.getMockService();
	}

	@Test
	public void endpointHandlesRetrieveWithAsOfDateAndPortIdParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		when(mockService.getCommentary(eq(portId), eq(asOfDate))).thenReturn(commentary);

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).getCommentary(eq(portId), eq(asOfDate));
	}
	
	@Test
	public void asOfDateIsRequiredOnRetrieve() {
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));
	}
	
	@Test
	public void asOfDateMustHaveCorrectFormatOnRetrieve() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "12/31/2016");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));;
	}

	@Test
	public void asOfDateMustBeAnActualDateOnRetrieve() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-02-29");
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));
	}

	@Test
	public void portIdIsRequiredOnRetrieve() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		when(mockService.getCommentary(any(String.class), any(Date.class))).thenReturn(commentary);
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).getCommentary(any(String.class), any(Date.class));		
	}
	
	@Test
	public void endpointHandlesUpdateWithCommentary() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).saveOrUpdateCommentary(any(CommentaryDTO.class));		
	}
	
	@Test
	public void asOfDateIsRequiredOnUpdate() {
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));		
	}
	
	@Test
	public void asOfDateMustHaveCorrectFormatOnUpdate() {
		String asOf = "17-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));
	}

	@Test
	public void asOfDateMustBeAnActualDateOnUpdate() {
		String asOf = "2017-07-32";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));
	}
	
	@Test
	public void portIdIsRequiredOnUpdate() {
		String asOf = "2017-07-04";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setCommentary(comments);
		
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));		
	}
	
	@Test
	public void commentaryIsRequiredOnUpdate() {
		String asOf = "2017-07-32";
		String portId = "ABC123";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
	
		doNothing().when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));
		
		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).saveOrUpdateCommentary(any(CommentaryDTO.class));	
	}
	
	@Test
	public void endpointRespondsWithInternalServerErrorIfExceptionsOccurDuringRetrieve() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		doThrow(new RuntimeException()).when(mockService).getCommentary(eq(portId), eq(asOfDate));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());

		verify(mockService, times(1)).getCommentary(eq(portId), eq(asOfDate));
	}
	
	@Test
	public void endpointRespondsWithInternalServerErrorIfExceptionsOccurDuringUpdate() {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String comments = "This is some commentary.";
		
		CommentaryDTO commentary = new CommentaryDTO();
		commentary.setAsOfDate(asOf);
		commentary.setPortId(portId);
		commentary.setCommentary(comments);
		doThrow(new RuntimeException()).when(mockService).saveOrUpdateCommentary(any(CommentaryDTO.class));

		WebTarget webTarget = this.target(CommentaryResource.PATH);
		Response response = webTarget.request().post(Entity.json(commentary));
		assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());

		verify(mockService, times(1)).saveOrUpdateCommentary(any(CommentaryDTO.class));	
	}
	
}


		CommentaryServiceApplicationTester.java

package com.vanguard.corp.ics.sdt.behaviors;

import static org.mockito.Mockito.mock;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.vanguard.corp.ics.sdt.dao.impl.repository.CommentaryRepository;
import com.vanguard.corp.ics.sdt.service.impl.CommentaryServiceImpl;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryResource;

public class CommentaryServiceApplicationTester extends JerseyTest {


	private CommentaryServiceImpl mockService;

	public CommentaryServiceImpl getMockService() {
		return mockService;
	}

	@Override
	protected Application configure() {

		forceSet(TestProperties.CONTAINER_PORT, "0");

		ApplicationContext context = new AnnotationConfigApplicationContext(CommentaryServiceApplicationTester.BeanConfig.class);
		mockService = context.getBean(CommentaryServiceImpl.class);

		return new ResourceConfig().register(CommentaryResource.class).property("contextConfig", context);
	}

	@Configuration
	public static class BeanConfig {

		@Bean
		public CommentaryServiceImpl commentaryService() {
			return mock(CommentaryServiceImpl.class);
		}
		
		@Bean
		public CommentaryRepository commentaryRepository() {
			return mock(CommentaryRepository.class);
		}
	}
}

		DataTransferEndpointTest.java


package com.vanguard.corp.ics.sdt.behaviors;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import org.junit.Before;
import org.junit.Test;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.test.characteristics.DataTransferServiceApplicationTester;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

public class DataTransferEndpointTest extends DataTransferServiceApplicationTester {

	private DataTransferService mockService;

	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		mockService = this.getMockService();
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateParameter() throws ParseException {
		String asOf = "2017-07-04";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		doNothing().when(mockService).transfer(eq(asOfDate), isNull(), isNull(), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), isNull(), isNull(), nullable(HttpServletRequest.class));
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateAndPortIdParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		doNothing().when(mockService).transfer(eq(asOfDate), eq(portId), isNull(), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), eq(portId), isNull(), nullable(HttpServletRequest.class));
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateAndDataSetParameters() throws ParseException {
		String asOf = "2017-07-04";
		String dataSet = DataSetType.CHARACTERISTICS.toString();
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		DataSetType dataSetType = DataSetType.valueOf(dataSet);
		doNothing().when(mockService).transfer(eq(asOfDate), isNull(), eq(dataSetType), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, dataSet);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), isNull(), eq(dataSetType), nullable(HttpServletRequest.class));
	}

	@Test
	public void endpointHandlesRequestWithAsOfDateAndPortIdAndDataSetParameters() throws ParseException {
		String asOf = "2017-07-04";
		String portId = "ABC123";
		String dataSet = DataSetType.CHARACTERISTICS.toString();
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		DataSetType dataSetType = DataSetType.valueOf(dataSet);
		doNothing().when(mockService).transfer(eq(asOfDate), eq(portId), eq(dataSetType), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, portId);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, dataSet);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());

		verify(mockService, times(1)).transfer(eq(asOfDate), eq(portId), eq(dataSetType), nullable(HttpServletRequest.class));
	}
	
	@Test
	public void asOfDateIsRequired() {
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));
		
		WebTarget webTarget = this.target(DataTransferResource.PATH);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));
	}
	
	@Test
	public void asOfDateMustHaveCorrectFormat() {
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));
		
		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "12/31/2016");
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());
		
		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));
	}

	@Test
	public void asOfDateMustBeAnActualDate() {
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-02-29");
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));
	}

	@Test
	public void dataSetMustBeAnActualDataSetType() {
		doNothing().when(mockService).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-07-04");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, "UNKNOWN_VALUE");
		Response response = webTarget.request().get();
		assertEquals(Response.Status.BAD_REQUEST.getStatusCode(), response.getStatus());

		verify(mockService, times(0)).transfer(any(Date.class), any(String.class), any(DataSetType.class), any(HttpServletRequest.class));
	}

	@Test
	public void endpointRespondsWithInternalServerErrorIfExceptionsOccurDuringDataTransfer() throws ParseException {
		String asOf = "2017-07-04";
		Date asOfDate = (new SimpleDateFormat("yyyy-MM-dd")).parse(asOf);
		doThrow(new RuntimeException()).when(mockService).transfer(eq(asOfDate), isNull(), isNull(), nullable(HttpServletRequest.class));

		WebTarget webTarget = this.target(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, asOf);
		Response response = webTarget.request().get();
		assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());

		verify(mockService, times(1)).transfer(eq(asOfDate), isNull(), isNull(), nullable(HttpServletRequest.class));
	}
}



		DataTransferParmsTest.java


package com.vanguard.corp.ics.sdt.behaviors;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;

public class DataTransferParmsTest {

	private DataTransferParameters classUnderTest = new DataTransferParameters();

	@Test
	public void parametersHasPortId() {
		String portId = "ABC123";
		classUnderTest.setPortId(portId);
		assertEquals(portId, classUnderTest.getPortId());
	}

	@Test
	public void parametersHasAsOfDate() {
		String asOfDate = "2017-09-11";
		classUnderTest.setAsOfDate(asOfDate);
		assertEquals(asOfDate, classUnderTest.getAsOfDate());
	}

	@Test
	public void parametersHasDataSetType() {
		String dataSetType = "CHARACTERISTICS";
		classUnderTest.setDataSet(dataSetType);
		assertEquals(dataSetType, classUnderTest.getDataSet());
	}
}


		DataTransferServiceFunctionalityTest.java

package com.vanguard.corp.ics.sdt.behaviors;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.powermock.reflect.Whitebox;

import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferServiceComparator;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.DataTransferException;
import com.vanguard.corp.ics.sdt.service.impl.DataTransferServiceImpl;


public class DataTransferServiceFunctionalityTest {

	private DataTransferServiceImpl classUnderTest = new DataTransferServiceImpl();
	private List<TransferService> services;
	
	@Mock
	private TransferService mock1;
	
	@Mock
	private TransferService mock2;
	
	@Mock
	private TransferService mock3;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		services = new ArrayList<>();
		services.add(mock1);
		services.add(mock2);
		services.add(mock3);
		Whitebox.setInternalState(classUnderTest, "services", services);
	}

	@Test
	public void serviceCallsMultipleTransferHandlersWhenTheyAgreeToHandleTheRequest() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(1)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
	}

	@Test
	public void serviceCallsOnlyTransferHandlersThatAgreeToHandleTheRequest() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(0)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock3, times(0)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
	}

	@Test
	public void serviceCallsNoTransferHandlersWhenNoneAgreeToHandleTheRequest() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(0)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock2, times(0)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock3, times(0)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
	}

	@Test
	public void servicePrioritizesTransferServicesFromHighestPriorityFirstToLowestPriorityLast() {
		TransferService highest = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.valueOf("HIGHEST"); }
		};
		TransferService high = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.HIGH; }
		};
		TransferService medium = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.MEDIUM; }
		};
		TransferService low = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.LOW; }
		};
		TransferService lowest = new TransferService() {
			@Override public void transfer(Date asOfDate, String portId, HttpServletRequest request) { }
			@Override public boolean handles(Date asOfDate, String portId, DataSetType dataSetType, HttpServletRequest request) { return false; }
			@Override public Priority getPriority() { return TransferService.Priority.LOWEST; }
		};
		
		List<TransferService> list = new ArrayList<>();
		list.add(lowest);
		list.add(low);
		list.add(medium);
		list.add(high);
		list.add(highest);
		assertEquals(highest, list.get(4));
		assertEquals(high, list.get(3));
		assertEquals(medium, list.get(2));
		assertEquals(low, list.get(1));
		assertEquals(lowest, list.get(0));
		
		TransferServiceComparator comparator = new TransferServiceComparator();
		Collections.sort(list, comparator);
		assertEquals(highest, list.get(0));
		assertEquals(high, list.get(1));
		assertEquals(medium, list.get(2));
		assertEquals(low, list.get(3));
		assertEquals(lowest, list.get(4));
		
		list.clear();
		list.add(medium);
		list.add(lowest);
		list.add(highest);
		list.add(low);
		list.add(high);
		assertEquals(highest, list.get(2));
		assertEquals(high, list.get(4));
		assertEquals(medium, list.get(0));
		assertEquals(low, list.get(3));
		assertEquals(lowest, list.get(1));
		
		Collections.sort(list, comparator);
		assertEquals(highest, list.get(0));
		assertEquals(high, list.get(1));
		assertEquals(medium, list.get(2));
		assertEquals(low, list.get(3));
		assertEquals(lowest, list.get(4));
	}

	@Test(expected=DataTransferException.class)
	public void serviceLogsCaughtExceptionsAndIndicatesFailureResponse() {
		Date asOfDate = new Date();
		String portId = null;
		DataSetType dataSetType = null;
		HttpServletRequest request = null;
		
		when(mock1.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock2.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock3.getPriority()).thenReturn(TransferService.Priority.MEDIUM);
		when(mock1.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.FALSE);
		when(mock2.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenReturn(Boolean.TRUE);
		when(mock3.handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class))).thenThrow(new RuntimeException());
		doNothing().when(mock1).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock2).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		doNothing().when(mock3).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		
		classUnderTest.transfer(asOfDate, portId, dataSetType, request);
		
		verify(mock1, atLeastOnce()).getPriority();
		verify(mock2, atLeastOnce()).getPriority();
		verify(mock3, atLeastOnce()).getPriority();
		verify(mock1, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).handles(any(Date.class), nullable(String.class), nullable(DataSetType.class), nullable(HttpServletRequest.class));
		verify(mock1, times(0)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock2, times(1)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
		verify(mock3, times(1)).transfer(any(Date.class), nullable(String.class), nullable(HttpServletRequest.class));
	}

}


com.vanguard.corp.ics.sdt.behaviors.characteristics

		CharacteristicsConversionTest.java



package com.vanguard.corp.ics.sdt.behaviors.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Test;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CountryAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CurrencyAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MarketSegmentationByCapAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.PortfolioCharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.RegionalAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.SectorAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.TopTenHoldingsCharacteristicsConverter;
import com.vanguard.corp.ics.sdt.test.characteristics.TestCharacteristicsType;

public class CharacteristicsConversionTest {

	@Test
	public void converterCopiesNonRoundingTargetTableValuesIntoReportingTableValues() {
		Date asOfDate = new Date();
		String portId = "ABC123";
		String name = "ASDFasdf 1234!@#$";

		Characteristics ch;
		List<Characteristics> outList;
		CharacteristicsConverter converter;

		List<FactsetMonthlyCharacteristicsTargetDAO> inList = new ArrayList<>();
		inList.add(new FactsetMonthlyCharacteristicsTargetDAO());
		inList.get(0).setEffectiveDate(asOfDate);
		inList.get(0).setPortfolioCode(portId);
		inList.get(0).setCharacteristicsName(name);

		for (TestCharacteristicsType type : TestCharacteristicsType.values()) {
			inList.get(0).setCharacteristicsType(type.getCode());
			converter = type.getConverter();

			outList = converter.convert(inList);
			assertEquals(inList.size(), outList.size());

			ch = outList.get(0);
			assertEquals(asOfDate, ch.getEffectiveDate());
			assertEquals(portId, ch.getPortId());
			assertEquals(type.getCode(), ch.getType());
			assertEquals(name, ch.getName());
		}
	}

	@Test
	public void doNotCopyTargetTablePrimaryKeyIntoReportingTablePrimaryKeyField() {
		Long id = Long.valueOf(123L);
		FactsetMonthlyCharacteristicsTargetDAO dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setId(id);

		Characteristics ch;
		List<Characteristics> outList;
		CharacteristicsConverter converter;

		List<FactsetMonthlyCharacteristicsTargetDAO> inList = new ArrayList<>();
		inList.add(dao);

		for (TestCharacteristicsType type : TestCharacteristicsType.values()) {
			inList.get(0).setCharacteristicsType(type.getCode());
			converter = type.getConverter();

			outList = converter.convert(inList);
			assertEquals(inList.size(), outList.size());

			ch = outList.get(0);
			assertEquals(type.getCode(), ch.getType());
			assertNull(ch.getId());
			assertEquals(id, dao.getId());
		}
	}

	@Test
	public void countryAllocationHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new CountryAllocationConverter();
		assertTrue(converter.handles(CharacteristicsType.valueOf("COUNTRY_ALLOCATION").getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
	}

	@Test
	public void currencyAllocationHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new CurrencyAllocationConverter();
		assertTrue(converter.handles(CharacteristicsType.CURRENCY_ALLOCATION.getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
	}

	@Test
	public void marketSegmentationByCapAllocationHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new MarketSegmentationByCapAllocationConverter();
		assertTrue(converter.handles(CharacteristicsType.MARKET_SEGMENTATION.getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
	}

	@Test
	public void portfolioCharacteristicsHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new PortfolioCharacteristicsConverter();
		assertTrue(converter.handles(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
	}

	@Test
	public void regionalAllocationHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new RegionalAllocationConverter();
		assertTrue(converter.handles(CharacteristicsType.REGIONAL_ALLOCATION.getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
	}

	@Test
	public void sectorAllocationHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new SectorAllocationConverter();
		assertTrue(converter.handles(CharacteristicsType.SECTOR_ALLOCATION.getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
	}

	@Test
	public void topTenHoldingsHandledByAppropriateConverter() {
		CharacteristicsConverter converter = new TopTenHoldingsCharacteristicsConverter();
		assertTrue(converter.handles(CharacteristicsType.TOP_TEN_HOLDINGS.getCode()));
		assertFalse(converter.handles(null));
		assertFalse(converter.handles(""));
		assertFalse(converter.handles(CharacteristicsType.COUNTRY_ALLOCATION.getCode()));
	}

	@Test
	public void portfolioCharacteristicsConversionRoundsPortfolioValuesTo1DecimalPrecision() {
		PortfolioCharacteristicsConverter converter = new PortfolioCharacteristicsConverter();
		Date effectiveDate = new Date();
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "A", "59.40000", "59.40000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "B", "30.30001", "30.30001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "C", "10.20001", "10.20001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "D", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "E", "0.04999", "0.04999"));
		BigDecimal expectedPortA = new BigDecimal("59.4"), expectedBenchA = new BigDecimal("59.4")
				, expectedPortB = new BigDecimal("30.3"), expectedBenchB = new BigDecimal("30.3")
				, expectedPortC = new BigDecimal("10.2"), expectedBenchC = new BigDecimal("10.2")
				, expectedPortD = new BigDecimal("0.0"), expectedBenchD = new BigDecimal("0.0")
				, expectedPortE = new BigDecimal("0.0"), expectedBenchE = new BigDecimal("0.0");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "F", "54.99999", "54.99999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "G", "44.90003", "44.90003"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "H", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "I", "0.04999", "0.04999"));
		BigDecimal expectedPortF = new BigDecimal("55.0"), expectedBenchF = new BigDecimal("55.0")
				, expectedPortG = new BigDecimal("44.9"), expectedBenchG = new BigDecimal("44.9")
				, expectedPortH = new BigDecimal("0.0"), expectedBenchH = new BigDecimal("0.0")
				, expectedPortI = new BigDecimal("0.0"), expectedBenchI = new BigDecimal("0.0");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "J", "21.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "K", "20.05000", "21.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "L", "20.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "M", "20.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "N", "18.80000", "18.80000"));
		BigDecimal expectedPortJ = new BigDecimal("21.1"), expectedBenchJ = new BigDecimal("20.1")
				, expectedPortK = new BigDecimal("20.1"), expectedBenchK = new BigDecimal("21.1")
				, expectedPortL = new BigDecimal("20.1"), expectedBenchL = new BigDecimal("20.1")
				, expectedPortM = new BigDecimal("20.1"), expectedBenchM = new BigDecimal("20.1")
				, expectedPortN = new BigDecimal("18.8"), expectedBenchN = new BigDecimal("18.8");

		List<Characteristics> converted = converter.convert(list);

		boolean foundA = false, foundB = false, foundC = false, foundD = false, foundE = false, foundF = false, foundG = false
				, foundH = false, foundI = false, foundJ = false, foundK = false, foundL = false, foundM = false, foundN = false;

		for (Characteristics ch : converted) {
			if (ch.getPortId().equals("ABC111") && ch.getName().equals("A") && ch.getPortfolio().compareTo(expectedPortA) == 0 && ch.getBenchmark().compareTo(expectedBenchA) == 0) {
				foundA = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("B") && ch.getPortfolio().compareTo(expectedPortB) == 0 && ch.getBenchmark().compareTo(expectedBenchB) == 0) {
				foundB = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("C") && ch.getPortfolio().compareTo(expectedPortC) == 0 && ch.getBenchmark().compareTo(expectedBenchC) == 0) {
				foundC = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("D") && ch.getPortfolio().compareTo(expectedPortD) == 0 && ch.getBenchmark().compareTo(expectedBenchD) == 0) {
				foundD = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("E") && ch.getPortfolio().compareTo(expectedPortE) == 0 && ch.getBenchmark().compareTo(expectedBenchE) == 0) {
				foundE = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("F") && ch.getPortfolio().compareTo(expectedPortF) == 0 && ch.getBenchmark().compareTo(expectedBenchF) == 0) {
				foundF = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("G") && ch.getPortfolio().compareTo(expectedPortG) == 0 && ch.getBenchmark().compareTo(expectedBenchG) == 0) {
				foundG = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("H") && ch.getPortfolio().compareTo(expectedPortH) == 0 && ch.getBenchmark().compareTo(expectedBenchH) == 0) {
				foundH = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("I") && ch.getPortfolio().compareTo(expectedPortI) == 0 && ch.getBenchmark().compareTo(expectedBenchI) == 0) {
				foundI = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("J") && ch.getPortfolio().compareTo(expectedPortJ) == 0 && ch.getBenchmark().compareTo(expectedBenchJ) == 0) {
				foundJ = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("K") && ch.getPortfolio().compareTo(expectedPortK) == 0 && ch.getBenchmark().compareTo(expectedBenchK) == 0) {
				foundK = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("L") && ch.getPortfolio().compareTo(expectedPortL) == 0 && ch.getBenchmark().compareTo(expectedBenchL) == 0) {
				foundL = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("M") && ch.getPortfolio().compareTo(expectedPortM) == 0 && ch.getBenchmark().compareTo(expectedBenchM) == 0) {
				foundM = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("N") && ch.getPortfolio().compareTo(expectedPortN) == 0 && ch.getBenchmark().compareTo(expectedBenchN) == 0) {
				foundN = true;
			}
		}

		assertTrue(foundA);
		assertTrue(foundB);
		assertTrue(foundC);
		assertTrue(foundD);
		assertTrue(foundE);
		assertTrue(foundF);
		assertTrue(foundG);
		assertTrue(foundH);
		assertTrue(foundI);
		assertTrue(foundJ);
		assertTrue(foundK);
		assertTrue(foundL);
		assertTrue(foundM);
		assertTrue(foundN);
	}

	@Test
	public void topTenHoldingsConversionRoundsPortfolioValuesTo1DecimalPrecisionForAnyPortIdWithGreaterThanOrEqualTo10Values() {
		CharacteristicsConverter converter = new TopTenHoldingsCharacteristicsConverter();
		Date effectiveDate = new Date();
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "A", "33.90002", "33.90002"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "B", "11.00000", "11.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "C", "10.00000", "10.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "D", "9.00000", "9.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "E", "8.00000", "2.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "F", "7.00000", "7.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "G", "6.00000", "6.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "H", "5.00000", "5.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "I", "4.00000", "4.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "J", "3.00000", "3.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "K", "2.00000", "8.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "L", "1.00000", "1.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "M", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "N", "0.04999", "0.04999"));
		BigDecimal expectedPortA = new BigDecimal("33.9"), expectedBenchA = new BigDecimal("33.9")
				, expectedPortB = new BigDecimal("11.0"), expectedBenchB = new BigDecimal("11.0")
				, expectedPortC = new BigDecimal("10.0"), expectedBenchC = new BigDecimal("10.0")
				, expectedPortD = new BigDecimal("9.0"), expectedBenchD = new BigDecimal("9.0")
				, expectedPortE = new BigDecimal("8.0"), expectedBenchE = new BigDecimal("2.0")
				, expectedPortF = new BigDecimal("7.0"), expectedBenchF = new BigDecimal("7.0")
				, expectedPortG = new BigDecimal("6.0"), expectedBenchG = new BigDecimal("6.0")
				, expectedPortH = new BigDecimal("5.0"), expectedBenchH = new BigDecimal("5.0")
				, expectedPortI = new BigDecimal("4.0"), expectedBenchI = new BigDecimal("4.0")
				, expectedPortJ = new BigDecimal("3.0"), expectedBenchJ = new BigDecimal("3.0")
				, expectedPortK = new BigDecimal("2.0"), expectedBenchK = new BigDecimal("8.0")
				, expectedPortL = new BigDecimal("1.0"), expectedBenchL = new BigDecimal("1.0")
				, expectedPortM = new BigDecimal("0.0"), expectedBenchM = new BigDecimal("0.0")
				, expectedPortN = new BigDecimal("0.0"), expectedBenchN = new BigDecimal("0.0");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "O", "33.90002", "33.90002"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "P", "11.00000", "11.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "Q", "10.00000", "10.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "R", "10.00000", "10.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "S", "10.00000", "10.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "T", "10.00000", "10.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "U", "10.00000", "10.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "V", "5.00000", "5.00000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "W", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", CharacteristicsType.TOP_TEN_HOLDINGS, "X", "0.04999", "0.04999"));
		BigDecimal expectedPortO = new BigDecimal("33.9"), expectedBenchO = new BigDecimal("33.9")
				, expectedPortP = new BigDecimal("11.0"), expectedBenchP = new BigDecimal("11.0")
				, expectedPortQ = new BigDecimal("10.0"), expectedBenchQ = new BigDecimal("10.0")
				, expectedPortR = new BigDecimal("10.0"), expectedBenchR = new BigDecimal("10.0")
				, expectedPortS = new BigDecimal("10.0"), expectedBenchS = new BigDecimal("10.0")
				, expectedPortT = new BigDecimal("10.0"), expectedBenchT = new BigDecimal("10.0")
				, expectedPortU = new BigDecimal("10.0"), expectedBenchU = new BigDecimal("10.0")
				, expectedPortV = new BigDecimal("5.0"), expectedBenchV = new BigDecimal("5.0")
				, expectedPortW = new BigDecimal("0.0"), expectedBenchW = new BigDecimal("0.0")
				, expectedPortX = new BigDecimal("0.0"), expectedBenchX = new BigDecimal("0.0");

		List<Characteristics> converted = converter.convert(list);

		boolean foundA = false, foundB = false, foundC = false, foundD = false, foundE = false, foundF = false
				, foundG = false, foundH = false, foundI = false, foundJ = false, foundK = false, foundL = false
				, foundM = false, foundN = false, foundO = false, foundP = false, foundQ = false, foundR = false
				, foundS = false, foundT = false, foundU = false, foundV = false, foundW = false, foundX = false;

		for (Characteristics ch : converted) {
			if (ch.getPortId().equals("ABC111") && ch.getName().equals("A") && ch.getPortfolio().compareTo(expectedPortA) == 0 && ch.getBenchmark().compareTo(expectedBenchA) == 0) {
				foundA = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("B") && ch.getPortfolio().compareTo(expectedPortB) == 0 && ch.getBenchmark().compareTo(expectedBenchB) == 0) {
				foundB = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("C") && ch.getPortfolio().compareTo(expectedPortC) == 0 && ch.getBenchmark().compareTo(expectedBenchC) == 0) {
				foundC = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("D") && ch.getPortfolio().compareTo(expectedPortD) == 0 && ch.getBenchmark().compareTo(expectedBenchD) == 0) {
				foundD = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("E") && ch.getPortfolio().compareTo(expectedPortE) == 0 && ch.getBenchmark().compareTo(expectedBenchE) == 0) {
				foundE = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("F") && ch.getPortfolio().compareTo(expectedPortF) == 0 && ch.getBenchmark().compareTo(expectedBenchF) == 0) {
				foundF = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("G") && ch.getPortfolio().compareTo(expectedPortG) == 0 && ch.getBenchmark().compareTo(expectedBenchG) == 0) {
				foundG = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("H") && ch.getPortfolio().compareTo(expectedPortH) == 0 && ch.getBenchmark().compareTo(expectedBenchH) == 0) {
				foundH = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("I") && ch.getPortfolio().compareTo(expectedPortI) == 0 && ch.getBenchmark().compareTo(expectedBenchI) == 0) {
				foundI = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("J") && ch.getPortfolio().compareTo(expectedPortJ) == 0 && ch.getBenchmark().compareTo(expectedBenchJ) == 0) {
				foundJ = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("K") && ch.getPortfolio().compareTo(expectedPortK) == 0 && ch.getBenchmark().compareTo(expectedBenchK) == 0) {
				foundK = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("L") && ch.getPortfolio().compareTo(expectedPortL) == 0 && ch.getBenchmark().compareTo(expectedBenchL) == 0) {
				foundL = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("M") && ch.getPortfolio().compareTo(expectedPortM) == 0 && ch.getBenchmark().compareTo(expectedBenchM) == 0) {
				foundM = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("N") && ch.getPortfolio().compareTo(expectedPortN) == 0 && ch.getBenchmark().compareTo(expectedBenchN) == 0) {
				foundN = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("O") && ch.getPortfolio().compareTo(expectedPortO) == 0 && ch.getBenchmark().compareTo(expectedBenchO) == 0) {
				foundO = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("P") && ch.getPortfolio().compareTo(expectedPortP) == 0 && ch.getBenchmark().compareTo(expectedBenchP) == 0) {
				foundP = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("Q") && ch.getPortfolio().compareTo(expectedPortQ) == 0 && ch.getBenchmark().compareTo(expectedBenchQ) == 0) {
				foundQ = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("R") && ch.getPortfolio().compareTo(expectedPortR) == 0 && ch.getBenchmark().compareTo(expectedBenchR) == 0) {
				foundR = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("S") && ch.getPortfolio().compareTo(expectedPortS) == 0 && ch.getBenchmark().compareTo(expectedBenchS) == 0) {
				foundS = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("T") && ch.getPortfolio().compareTo(expectedPortT) == 0 && ch.getBenchmark().compareTo(expectedBenchT) == 0) {
				foundT = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("U") && ch.getPortfolio().compareTo(expectedPortU) == 0 && ch.getBenchmark().compareTo(expectedBenchU) == 0) {
				foundU = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("V") && ch.getPortfolio().compareTo(expectedPortV) == 0 && ch.getBenchmark().compareTo(expectedBenchV) == 0) {
				foundV = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("W") && ch.getPortfolio().compareTo(expectedPortW) == 0 && ch.getBenchmark().compareTo(expectedBenchW) == 0) {
				foundW = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("X") && ch.getPortfolio().compareTo(expectedPortX) == 0 && ch.getBenchmark().compareTo(expectedBenchX) == 0) {
				foundX = true;
			}
		}

		assertTrue(foundA);
		assertTrue(foundB);
		assertTrue(foundC);
		assertTrue(foundD);
		assertTrue(foundE);
		assertTrue(foundF);
		assertTrue(foundG);
		assertTrue(foundH);
		assertTrue(foundI);
		assertTrue(foundJ);
		assertTrue(foundK);
		assertTrue(foundL);
		assertTrue(foundM);
		assertTrue(foundN);
		assertTrue(foundO);
		assertTrue(foundP);
		assertTrue(foundQ);
		assertTrue(foundR);
		assertTrue(foundS);
		assertTrue(foundT);
		assertTrue(foundU);
		assertTrue(foundV);
		assertTrue(foundW);
		assertTrue(foundX);
	}

	@Test
	public void topTenHoldingsConversionRoundsPortfolioValuesTo1DecimalPrecisionAndForcesTheSumForAnyPortIdToEqual100WhenLessThan10Values() {
		CharacteristicsConverter converter = new TopTenHoldingsCharacteristicsConverter();
		Date effectiveDate = new Date();
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "A", "1.05000", "1.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "B", "2.05000", "2.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "C", "3.05000", "3.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "D", "4.05000", "4.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "E", "5.05000", "5.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "F", "6.05000", "6.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "G", "7.05000", "7.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "H", "8.05000", "8.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", CharacteristicsType.TOP_TEN_HOLDINGS, "I", "63.60000", "63.60000"));
		BigDecimal expectedPortA = new BigDecimal("1.1"), expectedBenchA = new BigDecimal("1.1")
				, expectedPortB = new BigDecimal("2.1"), expectedBenchB = new BigDecimal("2.1")
				, expectedPortC = new BigDecimal("3.1"), expectedBenchC = new BigDecimal("3.1")
				, expectedPortD = new BigDecimal("4.1"), expectedBenchD = new BigDecimal("4.1")
				, expectedPortE = new BigDecimal("5.1"), expectedBenchE = new BigDecimal("5.1")
				, expectedPortF = new BigDecimal("6.1"), expectedBenchF = new BigDecimal("6.1")
				, expectedPortG = new BigDecimal("7.1"), expectedBenchG = new BigDecimal("7.1")
				, expectedPortH = new BigDecimal("8.1"), expectedBenchH = new BigDecimal("8.1")
				, expectedPortI = new BigDecimal("63.2"), expectedBenchI = new BigDecimal("63.2");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS, "Y", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS, "Z", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS, "1", "59.40000", "39.40000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS, "2", "30.30001", "50.30001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", CharacteristicsType.TOP_TEN_HOLDINGS, "3", "10.20001", "10.20001"));
		BigDecimal expectedPortY = new BigDecimal("0.0"), expectedBenchY = new BigDecimal("0.0")
				, expectedPortZ = new BigDecimal("0.0"), expectedBenchZ = new BigDecimal("0.0")
				, expectedPort1 = new BigDecimal("59.5"), expectedBench1 = new BigDecimal("39.4")
				, expectedPort2 = new BigDecimal("30.3"), expectedBench2 = new BigDecimal("50.4")
				, expectedPort3 = new BigDecimal("10.2"), expectedBench3 = new BigDecimal("10.2");

		List<Characteristics> converted = converter.convert(list);

		boolean foundA = false, foundB = false, foundC = false, foundD = false, foundE = false, foundF = false, foundG = false
				, foundH = false, foundI = false, foundY = false, foundZ = false, found1 = false, found2 = false, found3 = false;

		for (Characteristics ch : converted) {
			if (ch.getPortId().equals("ABC111") && ch.getName().equals("A") && ch.getPortfolio().compareTo(expectedPortA) == 0 && ch.getBenchmark().compareTo(expectedBenchA) == 0) {
				foundA = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("B") && ch.getPortfolio().compareTo(expectedPortB) == 0 && ch.getBenchmark().compareTo(expectedBenchB) == 0) {
				foundB = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("C") && ch.getPortfolio().compareTo(expectedPortC) == 0 && ch.getBenchmark().compareTo(expectedBenchC) == 0) {
				foundC = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("D") && ch.getPortfolio().compareTo(expectedPortD) == 0 && ch.getBenchmark().compareTo(expectedBenchD) == 0) {
				foundD = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("E") && ch.getPortfolio().compareTo(expectedPortE) == 0 && ch.getBenchmark().compareTo(expectedBenchE) == 0) {
				foundE = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("F") && ch.getPortfolio().compareTo(expectedPortF) == 0 && ch.getBenchmark().compareTo(expectedBenchF) == 0) {
				foundF = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("G") && ch.getPortfolio().compareTo(expectedPortG) == 0 && ch.getBenchmark().compareTo(expectedBenchG) == 0) {
				foundG = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("H") && ch.getPortfolio().compareTo(expectedPortH) == 0 && ch.getBenchmark().compareTo(expectedBenchH) == 0) {
				foundH = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("I") && ch.getPortfolio().compareTo(expectedPortI) == 0 && ch.getBenchmark().compareTo(expectedBenchI) == 0) {
				foundI = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("Y") && ch.getPortfolio().compareTo(expectedPortY) == 0 && ch.getBenchmark().compareTo(expectedBenchY) == 0) {
				foundY = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("Z") && ch.getPortfolio().compareTo(expectedPortZ) == 0 && ch.getBenchmark().compareTo(expectedBenchZ) == 0) {
				foundZ = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("1") && ch.getPortfolio().compareTo(expectedPort1) == 0 && ch.getBenchmark().compareTo(expectedBench1) == 0) {
				found1 = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("2") && ch.getPortfolio().compareTo(expectedPort2) == 0 && ch.getBenchmark().compareTo(expectedBench2) == 0) {
				found2 = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("3") && ch.getPortfolio().compareTo(expectedPort3) == 0 && ch.getBenchmark().compareTo(expectedBench3) == 0) {
				found3 = true;
			}
		}

		assertTrue(foundA);
		assertTrue(foundB);
		assertTrue(foundC);
		assertTrue(foundD);
		assertTrue(foundE);
		assertTrue(foundF);
		assertTrue(foundG);
		assertTrue(foundH);
		assertTrue(foundI);
		assertTrue(foundY);
		assertTrue(foundZ);
		assertTrue(found1);
		assertTrue(found2);
		assertTrue(found3);
	}

	@Test
	public void countryAllocationConversionRoundsPortfolioValuesTo1DecimalPrecisionAndForcesTheSumForAnyPortIdToEqual100() {
		genericMagicRounding(CharacteristicsType.COUNTRY_ALLOCATION, new CountryAllocationConverter());
	}

	@Test
	public void currencyAllocationConversionRoundsPortfolioValuesTo1DecimalPrecisionAndForcesTheSumForAnyPortIdToEqual100() {
		genericMagicRounding(CharacteristicsType.CURRENCY_ALLOCATION, new CurrencyAllocationConverter());
	}

	@Test
	public void marketSegmentationByCapitalizationConversionRoundsPortfolioValuesTo1DecimalPrecisionAndForcesTheSumForAnyPortIdToEqual100() {
		genericMagicRounding(CharacteristicsType.MARKET_SEGMENTATION, new MarketSegmentationByCapAllocationConverter());
	}

	@Test
	public void regionalAllocationConversionRoundsPortfolioValuesTo1DecimalPrecisionAndForcesTheSumForAnyPortIdToEqual100() {
		genericMagicRounding(CharacteristicsType.REGIONAL_ALLOCATION, new RegionalAllocationConverter());
	}

	@Test
	public void sectorAllocationConversionRoundsPortfolioValuesTo1DecimalPrecisionAndForcesTheSumForAnyPortIdToEqual100() {
		genericMagicRounding(CharacteristicsType.SECTOR_ALLOCATION, new SectorAllocationConverter());
	}

	@Test
	public void nullValuesPreventMagicRounding() {
		genericMagicRoundingWithNulls(CharacteristicsType.COUNTRY_ALLOCATION, new CountryAllocationConverter());
		genericMagicRoundingWithNulls(CharacteristicsType.CURRENCY_ALLOCATION, new CurrencyAllocationConverter());
		genericMagicRoundingWithNulls(CharacteristicsType.MARKET_SEGMENTATION, new MarketSegmentationByCapAllocationConverter());
		genericMagicRoundingWithNulls(CharacteristicsType.REGIONAL_ALLOCATION, new RegionalAllocationConverter());
		genericMagicRoundingWithNulls(CharacteristicsType.SECTOR_ALLOCATION, new SectorAllocationConverter());
	}

	private void genericMagicRounding(CharacteristicsType type, CharacteristicsConverter converter) {
		Date effectiveDate = new Date();
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "A", "59.49999", "59.49999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "B", "30.34999", "30.34999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "C", "10.15011", "10.15011"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "D", "0.04999", "0.04999"));
		BigDecimal expectedPortA = new BigDecimal("59.5"), expectedBenchA = new BigDecimal("59.5")
				, expectedPortB = new BigDecimal("30.3"), expectedBenchB = new BigDecimal("30.3")
				, expectedPortC = new BigDecimal("10.2"), expectedBenchC = new BigDecimal("10.2")
				, expectedPortD = new BigDecimal("0.0"), expectedBenchD = new BigDecimal("0.0");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", type, "E", "44.85001", "55.14999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", type, "F", "55.14999", "44.85001"));
		BigDecimal expectedPortE = new BigDecimal("44.9"), expectedBenchE = new BigDecimal("55.1")
				, expectedPortF = new BigDecimal("55.1"), expectedBenchF = new BigDecimal("44.9");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "G", "30.64999", "30.64999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "H", "69.35001", "69.35001"));
		BigDecimal expectedPortG = new BigDecimal("30.6"), expectedBenchG = new BigDecimal("30.6")
				, expectedPortH = new BigDecimal("69.4"), expectedBenchH = new BigDecimal("69.4");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC444", type, "I", "59.40000", "59.40000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC444", type, "J", "30.30001", "30.30001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC444", type, "K", "10.20001", "10.20001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC444", type, "L", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC444", type, "M", "0.04999", "0.04999"));
		BigDecimal expectedPortI = new BigDecimal("59.5"), expectedBenchI = new BigDecimal("59.5")
				, expectedPortJ = new BigDecimal("30.3"), expectedBenchJ = new BigDecimal("30.3")
				, expectedPortK = new BigDecimal("10.2"), expectedBenchK = new BigDecimal("10.2")
				, expectedPortL = new BigDecimal("0.0"), expectedBenchL = new BigDecimal("0.0")
				, expectedPortM = new BigDecimal("0.0"), expectedBenchM = new BigDecimal("0.0");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC555", type, "N", "54.99999", "54.99999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC555", type, "O", "44.90003", "44.90003"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC555", type, "P", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC555", type, "Q", "0.04999", "0.04999"));
		BigDecimal expectedPortN = new BigDecimal("55.1"), expectedBenchN = new BigDecimal("55.1")
				, expectedPortO = new BigDecimal("44.9"), expectedBenchO = new BigDecimal("44.9")
				, expectedPortP = new BigDecimal("0.0"), expectedBenchP = new BigDecimal("0.0")
				, expectedPortQ = new BigDecimal("0.0"), expectedBenchQ = new BigDecimal("0.0");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC666", type, "R", "21.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC666", type, "S", "20.05000", "21.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC666", type, "T", "20.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC666", type, "U", "20.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC666", type, "V", "18.80000", "18.80000"));
		BigDecimal expectedPortR = new BigDecimal("20.9"), expectedBenchR = new BigDecimal("20.1")
				, expectedPortS = new BigDecimal("20.1"), expectedBenchS = new BigDecimal("20.9")
				, expectedPortT = new BigDecimal("20.1"), expectedBenchT = new BigDecimal("20.1")
				, expectedPortU = new BigDecimal("20.1"), expectedBenchU = new BigDecimal("20.1")
				, expectedPortV = new BigDecimal("18.8"), expectedBenchV = new BigDecimal("18.8");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "W", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "X", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "Y", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "Z", "0.04999", "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "1", "0.00004", "0.00004"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "2", "49.90000", "49.90000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC777", type, "3", "49.90000", "49.90000"));
		BigDecimal expectedPortW = new BigDecimal("0.0"), expectedBenchW = new BigDecimal("0.0")
				, expectedPortX = new BigDecimal("0.0"), expectedBenchX = new BigDecimal("0.0")
				, expectedPortY = new BigDecimal("0.0"), expectedBenchY = new BigDecimal("0.0")
				, expectedPortZ = new BigDecimal("0.0"), expectedBenchZ = new BigDecimal("0.0")
				, expectedPort1 = new BigDecimal("0.0"), expectedBench1 = new BigDecimal("0.0")
				, expectedPort2 = new BigDecimal("50.1"), expectedBench2 = new BigDecimal("50.1")
				, expectedPort3 = new BigDecimal("49.9"), expectedBench3 = new BigDecimal("49.9");

		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC888", type, "4", "1.21020", "5.21020"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC888", type, "5", "2.43039", "2.43039"));
		BigDecimal expectedPort4 = new BigDecimal("1.2"), expectedBench4 = new BigDecimal("97.6")
				, expectedPort5 = new BigDecimal("98.8"), expectedBench5 = new BigDecimal("2.4");

		List<Characteristics> converted = converter.convert(list);

		boolean foundA = false, foundB = false, foundC = false, foundD = false, foundE = false, foundF = false
				, foundG = false, foundH = false, foundI = false, foundJ = false, foundK = false, foundL = false
				, foundM = false, foundN = false, foundO = false, foundP = false, foundQ = false, foundR = false
				, foundS = false, foundT = false, foundU = false, foundV = false, foundW = false, foundX = false
				, foundY = false, foundZ = false, found1 = false, found2 = false, found3 = false, found4 = false
				, found5 = false;

		for (Characteristics ch : converted) {
			if (ch.getPortId().equals("ABC111") && ch.getName().equals("A") && ch.getPortfolio().compareTo(expectedPortA) == 0 && ch.getBenchmark().compareTo(expectedBenchA) == 0) {
				foundA = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("B") && ch.getPortfolio().compareTo(expectedPortB) == 0 && ch.getBenchmark().compareTo(expectedBenchB) == 0) {
				foundB = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("C") && ch.getPortfolio().compareTo(expectedPortC) == 0 && ch.getBenchmark().compareTo(expectedBenchC) == 0) {
				foundC = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("D") && ch.getPortfolio().compareTo(expectedPortD) == 0 && ch.getBenchmark().compareTo(expectedBenchD) == 0) {
				foundD = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("E") && ch.getPortfolio().compareTo(expectedPortE) == 0 && ch.getBenchmark().compareTo(expectedBenchE) == 0) {
				foundE = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("F") && ch.getPortfolio().compareTo(expectedPortF) == 0 && ch.getBenchmark().compareTo(expectedBenchF) == 0) {
				foundF = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("G") && ch.getPortfolio().compareTo(expectedPortG) == 0 && ch.getBenchmark().compareTo(expectedBenchG) == 0) {
				foundG = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("H") && ch.getPortfolio().compareTo(expectedPortH) == 0 && ch.getBenchmark().compareTo(expectedBenchH) == 0) {
				foundH = true;
			}
			else if (ch.getPortId().equals("ABC444") && ch.getName().equals("I") && ch.getPortfolio().compareTo(expectedPortI) == 0 && ch.getBenchmark().compareTo(expectedBenchI) == 0) {
				foundI = true;
			}
			else if (ch.getPortId().equals("ABC444") && ch.getName().equals("J") && ch.getPortfolio().compareTo(expectedPortJ) == 0 && ch.getBenchmark().compareTo(expectedBenchJ) == 0) {
				foundJ = true;
			}
			else if (ch.getPortId().equals("ABC444") && ch.getName().equals("K") && ch.getPortfolio().compareTo(expectedPortK) == 0 && ch.getBenchmark().compareTo(expectedBenchK) == 0) {
				foundK = true;
			}
			else if (ch.getPortId().equals("ABC444") && ch.getName().equals("L") && ch.getPortfolio().compareTo(expectedPortL) == 0 && ch.getBenchmark().compareTo(expectedBenchL) == 0) {
				foundL = true;
			}
			else if (ch.getPortId().equals("ABC444") && ch.getName().equals("M") && ch.getPortfolio().compareTo(expectedPortM) == 0 && ch.getBenchmark().compareTo(expectedBenchM) == 0) {
				foundM = true;
			}
			else if (ch.getPortId().equals("ABC555") && ch.getName().equals("N") && ch.getPortfolio().compareTo(expectedPortN) == 0 && ch.getBenchmark().compareTo(expectedBenchN) == 0) {
				foundN = true;
			}
			else if (ch.getPortId().equals("ABC555") && ch.getName().equals("O") && ch.getPortfolio().compareTo(expectedPortO) == 0 && ch.getBenchmark().compareTo(expectedBenchO) == 0) {
				foundO = true;
			}
			else if (ch.getPortId().equals("ABC555") && ch.getName().equals("P") && ch.getPortfolio().compareTo(expectedPortP) == 0 && ch.getBenchmark().compareTo(expectedBenchP) == 0) {
				foundP = true;
			}
			else if (ch.getPortId().equals("ABC555") && ch.getName().equals("Q") && ch.getPortfolio().compareTo(expectedPortQ) == 0 && ch.getBenchmark().compareTo(expectedBenchQ) == 0) {
				foundQ = true;
			}
			else if (ch.getPortId().equals("ABC666") && ch.getName().equals("R") && ch.getPortfolio().compareTo(expectedPortR) == 0 && ch.getBenchmark().compareTo(expectedBenchR) == 0) {
				foundR = true;
			}
			else if (ch.getPortId().equals("ABC666") && ch.getName().equals("S") && ch.getPortfolio().compareTo(expectedPortS) == 0 && ch.getBenchmark().compareTo(expectedBenchS) == 0) {
				foundS = true;
			}
			else if (ch.getPortId().equals("ABC666") && ch.getName().equals("T") && ch.getPortfolio().compareTo(expectedPortT) == 0 && ch.getBenchmark().compareTo(expectedBenchT) == 0) {
				foundT = true;
			}
			else if (ch.getPortId().equals("ABC666") && ch.getName().equals("U") && ch.getPortfolio().compareTo(expectedPortU) == 0 && ch.getBenchmark().compareTo(expectedBenchU) == 0) {
				foundU = true;
			}
			else if (ch.getPortId().equals("ABC666") && ch.getName().equals("V") && ch.getPortfolio().compareTo(expectedPortV) == 0 && ch.getBenchmark().compareTo(expectedBenchV) == 0) {
				foundV = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("W") && ch.getPortfolio().compareTo(expectedPortW) == 0 && ch.getBenchmark().compareTo(expectedBenchW) == 0) {
				foundW = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("X") && ch.getPortfolio().compareTo(expectedPortX) == 0 && ch.getBenchmark().compareTo(expectedBenchX) == 0) {
				foundX = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("Y") && ch.getPortfolio().compareTo(expectedPortY) == 0 && ch.getBenchmark().compareTo(expectedBenchY) == 0) {
				foundY = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("Z") && ch.getPortfolio().compareTo(expectedPortZ) == 0 && ch.getBenchmark().compareTo(expectedBenchZ) == 0) {
				foundZ = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("1") && ch.getPortfolio().compareTo(expectedPort1) == 0 && ch.getBenchmark().compareTo(expectedBench1) == 0) {
				found1 = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("2") && ch.getPortfolio().compareTo(expectedPort2) == 0 && ch.getBenchmark().compareTo(expectedBench2) == 0) {
				found2 = true;
			}
			else if (ch.getPortId().equals("ABC777") && ch.getName().equals("3") && ch.getPortfolio().compareTo(expectedPort3) == 0 && ch.getBenchmark().compareTo(expectedBench3) == 0) {
				found3 = true;
			}
			else if (ch.getPortId().equals("ABC888") && ch.getName().equals("4") && ch.getPortfolio().compareTo(expectedPort4) == 0 && ch.getBenchmark().compareTo(expectedBench4) == 0) {
				found4 = true;
			}
			else if (ch.getPortId().equals("ABC888") && ch.getName().equals("5") && ch.getPortfolio().compareTo(expectedPort5) == 0 && ch.getBenchmark().compareTo(expectedBench5) == 0) {
				found5 = true;
			}
		}

		assertTrue(foundA);
		assertTrue(foundB);
		assertTrue(foundC);
		assertTrue(foundD);
		assertTrue(foundE);
		assertTrue(foundF);
		assertTrue(foundG);
		assertTrue(foundH);
		assertTrue(foundI);
		assertTrue(foundJ);
		assertTrue(foundK);
		assertTrue(foundL);
		assertTrue(foundM);
		assertTrue(foundN);
		assertTrue(foundO);
		assertTrue(foundP);
		assertTrue(foundQ);
		assertTrue(foundR);
		assertTrue(foundS);
		assertTrue(foundT);
		assertTrue(foundU);
		assertTrue(foundV);
		assertTrue(foundW);
		assertTrue(foundX);
		assertTrue(foundY);
		assertTrue(foundZ);
		assertTrue(found1);
		assertTrue(found2);
		assertTrue(found3);
		assertTrue(found4);
		assertTrue(found5);
	}
	
	private void genericMagicRoundingWithNulls(CharacteristicsType type, CharacteristicsConverter converter) {
		Date effectiveDate = new Date();
		List<FactsetMonthlyCharacteristicsTargetDAO> list = new ArrayList<>();
		
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "A", "59.40000", "59.40000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "B", "30.30001", "30.30001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "C", "10.20001", "10.20001"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "D", null,       "0.04999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC111", type, "E", "0.04999",  "0.04999"));
		BigDecimal expectedPortA = new BigDecimal("59.4"), expectedBenchA = new BigDecimal("59.5"),
				   expectedPortB = new BigDecimal("30.3"), expectedBenchB = new BigDecimal("30.3"),
				   expectedPortC = new BigDecimal("10.2"), expectedBenchC = new BigDecimal("10.2"),
				                                           expectedBenchD = new BigDecimal("0.0"),
				   expectedPortE = new BigDecimal("0.0"),  expectedBenchE = new BigDecimal("0.0");
		
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", type, "F", "54.99999", "54.99999"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", type, "G", "44.90003", "44.90003"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", type, "H", "0.04999",  null));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC222", type, "I", "0.04999",  "0.04999"));
		BigDecimal expectedPortF = new BigDecimal("55.1"), expectedBenchF = new BigDecimal("55.0"),
				   expectedPortG = new BigDecimal("44.9"), expectedBenchG = new BigDecimal("44.9"),
				   expectedPortH = new BigDecimal("0.0"),
				   expectedPortI = new BigDecimal("0.0"),  expectedBenchI = new BigDecimal("0.0");
		
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "J", "21.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "K", "20.05000", "21.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "L", "20.05000", "20.05000"));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "M", "20.05000", null));
		list.add(buildFactsetMonthlyCharacteristicsTargetDao(effectiveDate, "ABC333", type, "N", null,       "18.80000"));
		BigDecimal expectedPortJ = new BigDecimal("21.1"), expectedBenchJ = new BigDecimal("20.1"),
				   expectedPortK = new BigDecimal("20.1"), expectedBenchK = new BigDecimal("21.1"),
				   expectedPortL = new BigDecimal("20.1"), expectedBenchL = new BigDecimal("20.1"),
				   expectedPortM = new BigDecimal("20.1"),
				                                           expectedBenchN = new BigDecimal("18.8");
		
		List<Characteristics> converted = converter.convert(list);
		
		boolean foundA = false, foundB = false, foundC = false, foundD = false, foundE = false, foundF = false, foundG = false
				, foundH = false, foundI = false, foundJ = false, foundK = false, foundL = false, foundM = false, foundN = false;
		
		for (Characteristics ch : converted) {
			if (ch.getPortId().equals("ABC111") && ch.getName().equals("A") && ch.getPortfolio().compareTo(expectedPortA) == 0 && ch.getBenchmark().compareTo(expectedBenchA) == 0) {
				foundA = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("B") && ch.getPortfolio().compareTo(expectedPortB) == 0 && ch.getBenchmark().compareTo(expectedBenchB) == 0) {
				foundB = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("C") && ch.getPortfolio().compareTo(expectedPortC) == 0 && ch.getBenchmark().compareTo(expectedBenchC) == 0) {
				foundC = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("D") && ch.getPortfolio() == null && ch.getBenchmark().compareTo(expectedBenchD) == 0) {
				foundD = true;
			}
			else if (ch.getPortId().equals("ABC111") && ch.getName().equals("E") && ch.getPortfolio().compareTo(expectedPortE) == 0 && ch.getBenchmark().compareTo(expectedBenchE) == 0) {
				foundE = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("F") && ch.getPortfolio().compareTo(expectedPortF) == 0 && ch.getBenchmark().compareTo(expectedBenchF) == 0) {
				foundF = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("G") && ch.getPortfolio().compareTo(expectedPortG) == 0 && ch.getBenchmark().compareTo(expectedBenchG) == 0) {
				foundG = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("H") && ch.getPortfolio().compareTo(expectedPortH) == 0 && ch.getBenchmark() == null) {
				foundH = true;
			}
			else if (ch.getPortId().equals("ABC222") && ch.getName().equals("I") && ch.getPortfolio().compareTo(expectedPortI) == 0 && ch.getBenchmark().compareTo(expectedBenchI) == 0) {
				foundI = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("J") && ch.getPortfolio().compareTo(expectedPortJ) == 0 && ch.getBenchmark().compareTo(expectedBenchJ) == 0) {
				foundJ = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("K") && ch.getPortfolio().compareTo(expectedPortK) == 0 && ch.getBenchmark().compareTo(expectedBenchK) == 0) {
				foundK = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("L") && ch.getPortfolio().compareTo(expectedPortL) == 0 && ch.getBenchmark().compareTo(expectedBenchL) == 0) {
				foundL = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("M") && ch.getPortfolio().compareTo(expectedPortM) == 0 && ch.getBenchmark() == null) {
				foundM = true;
			}
			else if (ch.getPortId().equals("ABC333") && ch.getName().equals("N") && ch.getPortfolio() == null && ch.getBenchmark().compareTo(expectedBenchN) == 0) {
				foundN = true;
			}
		}
		
		assertTrue(foundA);
		assertTrue(foundB);
		assertTrue(foundC);
		assertTrue(foundD);
		assertTrue(foundE);
		assertTrue(foundF);
		assertTrue(foundG);
		assertTrue(foundH);
		assertTrue(foundI);
		assertTrue(foundJ);
		assertTrue(foundK);
		assertTrue(foundL);
		assertTrue(foundM);
		assertTrue(foundN);
	}

	private FactsetMonthlyCharacteristicsTargetDAO buildFactsetMonthlyCharacteristicsTargetDao(Date effectiveDate, String portId, CharacteristicsType type, String name, String portfolio, String benchmark) {
		FactsetMonthlyCharacteristicsTargetDAO dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setEffectiveDate(effectiveDate);
		dao.setPortfolioCode(portId);
		dao.setCharacteristicsType(type.getCode());
		dao.setCharacteristicsName(name);
		dao.setPortfolioValue(portfolio == null ? null : Double.valueOf(portfolio));
		dao.setBenchMarkValue(benchmark == null ? null : Double.valueOf(benchmark));

		return dao;
	}
}

		CharacteristicsDataTest.java


package com.vanguard.corp.ics.sdt.behaviors.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.math.BigDecimal;
import java.util.Calendar;
import java.util.Date;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

public class CharacteristicsDataTest {

	private Characteristics classUnderTest = new Characteristics();

	@Test
	public void characteristicsHasCharacteristicsId() {
		final Long id = Long.valueOf(123L);
		classUnderTest.setId(id);
		assertEquals(id, classUnderTest.getId());
	}
	
	@Test
	public void characteristicsHasPortId() {
		final String portId = "ABC123";
		classUnderTest.setPortId(portId);
		assertEquals(portId, classUnderTest.getPortId());
	}
	
	@Test
	public void characteristicsHasAsOfDate() {
		final Date asOfDate = new Date();
		classUnderTest.setEffectiveDate(asOfDate);
		assertEquals(asOfDate, classUnderTest.getEffectiveDate());
	}
	
	@Test
	public void characteristicsHasCharacteristicsTypeCode() {
		final String charType = "ABCDEFG";
		classUnderTest.setType(charType);
		assertEquals(charType, classUnderTest.getType());
	}
	
	@Test
	public void characteristicsHasCharacteristicsName() {
		final String name = "ABCabc123!@# asdf";
		classUnderTest.setName(name);
		assertEquals(name, classUnderTest.getName());
	}
	
	@Test
	public void characteristicsHasPortfolioValue() {
		final BigDecimal portfolioValue = new BigDecimal("1234567890.12345");
		classUnderTest.setPortfolio(portfolioValue);
		assertEquals(portfolioValue, classUnderTest.getPortfolio());
	}
	
	@Test
	public void characteristicsHasBenchmarkValue() {
		final BigDecimal benchmarkValue = new BigDecimal("9876543210.12345");
		classUnderTest.setBenchmark(benchmarkValue);
		assertEquals(benchmarkValue, classUnderTest.getBenchmark());
	}
	
	@Test
	public void characteristicsHasEffectiveDates() {
		Calendar cal = Calendar.getInstance();
		final Date effectiveEnd = cal.getTime();
		cal.add(Calendar.YEAR, -1); // last year
		final Date effectiveBegin = cal.getTime();
		assertNotEquals(effectiveBegin, effectiveEnd);
		
		classUnderTest.setEffectiveBeginDate(effectiveBegin);
		classUnderTest.setEffectiveEndDate(effectiveEnd);
		assertEquals(effectiveBegin, classUnderTest.getEffectiveBeginDate());
		assertEquals(effectiveEnd, classUnderTest.getEffectiveEndDate());
	}
	
	@Test
	public void characteristicsHasLastUpdatedUserAndTimestamp() {
		final Date lastUpdatedDate = new Date();
		final String lastUpdatedUser = "UGLY";
		classUnderTest.setLastUpdatedDate(lastUpdatedDate);
		classUnderTest.setLastUpdatedUserId(lastUpdatedUser);
		assertEquals(lastUpdatedDate, classUnderTest.getLastUpdatedDate());
		assertEquals(lastUpdatedUser, classUnderTest.getLastUpdatedUserId());
	}
}


		CharacteristicsReportingTableDataAccessTest.java


package com.vanguard.corp.ics.sdt.behaviors.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.dao.impl.repository.CharacteristicsRepository;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRepoWrapper;

public class CharacteristicsReportingTableDataAccessTest {

	@InjectMocks
	private CharacteristicsRepoWrapper classUnderTest = new CharacteristicsRepoWrapper.Impl();

	@Mock
	private CharacteristicsRepository repo;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void systemRetrievesCharacteristicsByAsOfDate() {
		final Date asOfDate = new Date();
		final List<Characteristics> expectedList = new ArrayList<>();

		when(repo.findByEffectiveDate(asOfDate)).thenReturn(expectedList);
		
		List<Characteristics> retrieved = classUnderTest.retrieveAll(asOfDate);
		assertEquals(expectedList, retrieved);
		
		verify(repo, times(1)).findByEffectiveDate(asOfDate);
	}

	@Test
	public void systemRetrievesCharacteristicsByAsOfDateAndPortId() {
		final Date asOfDate = new Date();
		final String portId = "ABC123";
		final List<Characteristics> expectedList = new ArrayList<>();

		when(repo.findByEffectiveDateAndPortId(asOfDate, portId)).thenReturn(expectedList);
		
		List<Characteristics> retrieved = classUnderTest.retrieveAll(asOfDate, portId);
		assertEquals(expectedList, retrieved);
		
		verify(repo, times(1)).findByEffectiveDateAndPortId(asOfDate, portId);
	}

	@Test
	public void systemSavesCharacteristicsByLogicallyDeletingAndInsertingNewRows() {
		Date asOfDate = new Date();
		List<Characteristics> expectedList = buildTestCharacteristicsList(asOfDate);
		Characteristics update1 = buildTestCharacteristics(1, asOfDate); // ABC123
		Characteristics update2 = buildTestCharacteristics(2, asOfDate); // ABC123
		Characteristics update3 = buildTestCharacteristics(3, asOfDate); // ABC124
		Characteristics update4 = buildTestCharacteristics(4, asOfDate); // ABC123 (different type)
		Characteristics newchar = buildTestCharacteristics(5, asOfDate); // ABC125

		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "CHARTYPE")).thenReturn(Arrays.asList(update1, update2));
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC124", "CHARTYPE")).thenReturn(Arrays.asList(update3));
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "OTHERTYPE")).thenReturn(Arrays.asList(update4));
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC125", "ANOTHERTYPE")).thenReturn(new ArrayList<>());
		when(repo.save(expectedList)).thenReturn(expectedList);

		List<Characteristics> saved = classUnderTest.saveAll(expectedList);
		assertEquals(expectedList, saved);
		assertNotNull(update1.getEffectiveEndDate());
		assertNotNull(update2.getEffectiveEndDate());
		assertNotNull(update3.getEffectiveEndDate());
		assertNotNull(update4.getEffectiveEndDate());
		assertNull(newchar.getEffectiveEndDate());

		verify(repo, times(4)).findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(any(Date.class), any(String.class), any(String.class));
		verify(repo, times(1)).save(expectedList);
	}
	
	@Test
	public void savingAnEmptyListOfCharacteristicsDoesNotSaveAnything() {
		List<Characteristics> emptyList = new ArrayList<>();
		
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(any(Date.class), any(String.class), any(String.class))).thenThrow(new RuntimeException("should NOT happen"));
		when(repo.save(emptyList)).thenThrow(new RuntimeException("should NOT happen"));
		
		List<Characteristics> saved = classUnderTest.saveAll(emptyList);
		assertEquals(emptyList, saved);
		
		verify(repo, times(0)).findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(any(Date.class), any(String.class), any(String.class));
		verify(repo, times(0)).save(emptyList);
	}

	@Test
	public void systemDeletesCharacteristicsByLogicallyDeleting() {
		Date asOfDate = new Date();
		Characteristics update1 = buildTestCharacteristics(1, asOfDate); // ABC123
		Characteristics update2 = buildTestCharacteristics(2, asOfDate); // ABC123
		
		when(repo.findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "CHARTYPE")).thenReturn(Arrays.asList(update1, update2));
		
		classUnderTest.logicalDelete(asOfDate, "ABC123", "CHARTYPE");
		assertNotNull(update1.getEffectiveEndDate());
		assertNotNull(update2.getEffectiveEndDate());
		
		verify(repo, times(1)).findByEffectiveDateAndPortIdAndTypeAndEffectiveEndDateIsNull(asOfDate, "ABC123", "CHARTYPE");
	}

	private List<Characteristics> buildTestCharacteristicsList(Date asOfDate) {
		List<Characteristics> list = new ArrayList<>();
		list.add(buildTestCharacteristics(1, asOfDate));
		list.add(buildTestCharacteristics(2, asOfDate));
		list.add(buildTestCharacteristics(3, asOfDate));
		list.add(buildTestCharacteristics(4, asOfDate));
		list.add(buildTestCharacteristics(5, asOfDate));

		return list;
	}

	private Characteristics buildTestCharacteristics(int which, Date asOfDate) {
		Characteristics c = new Characteristics();

		switch (which) {
		case 1:
			c.setName("having");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC123");
			c.setType("CHARTYPE");
			break;

		case 2:
			c.setName("fun");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC123");
			c.setType("CHARTYPE");
			break;

		case 3:
			c.setName("with");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC124");
			c.setType("CHARTYPE");
			break;

		case 4:
			c.setName("easter");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC123");
			c.setType("OTHERTYPE");
			break;

		case 5:
			c.setName("eggs");
			c.setEffectiveDate(asOfDate);
			c.setPortId("ABC125");
			c.setType("ANOTHERTYPE");
			break;

		default:
		}

		return c;
	}
}


		CharacteristicsTransfersTest.java


package com.vanguard.corp.ics.sdt.behaviors.characteristics;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.*;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.powermock.reflect.Whitebox;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.exception.ReadCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.api.exception.SaveCharacteristicsException;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRepoWrapper;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsTransferService;

@RunWith(MockitoJUnitRunner.class)
public class CharacteristicsTransfersTest {

	@InjectMocks
	private TransferService classUnderTest = new CharacteristicsTransferService();

	@Mock
	private FactsetMonthlyCharacteristicsRepository readRepo;

	@Mock
	private CharacteristicsConverter converter1;
	
	@Mock
	private CharacteristicsConverter converter2;
	
	@Mock
	private CharacteristicsConverter converter3;

	@Mock
	private CharacteristicsRepoWrapper writeRepo;

	private List<CharacteristicsConverter> converters;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		
		converters = new ArrayList<>();
		converters.add(converter1);
		
		Whitebox.setInternalState(classUnderTest, "converters", converters);
	}

	@Test
	public void characteristicsServiceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, classUnderTest.getPriority());
	}

	@Test
	public void serviceWantsToHandleCharacteristicsDataSetTypeRequests() {
		String portId = null;
		Date asOfDate = null;
		DataSetType dataSetType = DataSetType.CHARACTERISTICS;
		HttpServletRequest request = null;
		
		assertTrue(classUnderTest.handles(asOfDate, portId, dataSetType, request));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		String portId = null;
		Date asOfDate = null;
		DataSetType dataSetType = null;
		HttpServletRequest request = null;
		
		assertTrue(classUnderTest.handles(asOfDate, portId, dataSetType, request));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		String portId = null;
		Date asOfDate = null;
		DataSetType dataSetType = DataSetType.PRODUCT_DATA;
		HttpServletRequest request = null;
		
		assertFalse(classUnderTest.handles(asOfDate, portId, dataSetType, request));
	}

	@Test(expected=IllegalArgumentException.class)
	public void serviceThrowsIllegalArgumentExceptionIfAsOfDateIsNull() {
		classUnderTest.transfer(null, null, null);
	}

	@Test
	public void serviceCanReadCharacteristicsByAsOfDateFromTargetTables() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>());
		classUnderTest.transfer(asOfDate, portId, request);
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
	}

	@Test
	public void serviceCanReadCharacteristicsByAsOfDateAndPortIdFromTargetTables() {
		String portId = "ABC123";
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		
		when(readRepo.findByEffectiveDateAndPortfolioCode(asOfDate, portId)).thenReturn(new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>());
		classUnderTest.transfer(asOfDate, portId, request);
		verify(readRepo, times(1)).findByEffectiveDateAndPortfolioCode(asOfDate, portId);
	}

	@Test
	public void serviceThrowsCharacteristicsReadExceptionWhenProblemsOccurDuringRead() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		Exception cause = new RuntimeException();
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenThrow(cause);
		try {
			classUnderTest.transfer(asOfDate, portId, request);
		}
		catch (ReadCharacteristicsException e) {
			assertEquals(cause, e.getCause());
		}
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
	}

	@Test
	public void serviceThrowsCharacteristicsReadExceptionWhenReadReturnsNull() {
		boolean caughtExpectedException = false;
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(null);
		try {
			classUnderTest.transfer(asOfDate, portId, request);
		}
		catch (ReadCharacteristicsException e) {
			assertTrue(e.getCause() instanceof IllegalArgumentException);
			assertTrue(e.getMessage().indexOf("Target characteristics list is null") > -1);
			caughtExpectedException = true;
		}
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
		
		assertTrue(caughtExpectedException);
	}

	@SuppressWarnings("unchecked")
	@Test
	public void serviceConvertsTargetTableCharacteristicsIntoReportingTableCharacteristicsByAppropriateConverterAndSavesToReportingTables() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String characteristicsTypeCode = "ABCDEFGH";
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		readList.add(new FactsetMonthlyCharacteristicsTargetDAO());
		readList.get(0).setCharacteristicsType(characteristicsTypeCode);
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		writeList.add(new Characteristics());
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(readList);
		when(converter1.handles(characteristicsTypeCode)).thenReturn(Boolean.TRUE);
		when(converter1.convert(readList)).thenReturn(writeList);
		when(writeRepo.saveAll(any(List.class))).thenReturn(writeList);
		classUnderTest.transfer(asOfDate, portId, request);
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
		verify(converter1, times(1)).handles(characteristicsTypeCode);
		verify(converter1, times(1)).convert(readList);
		verify(writeRepo, times(1)).saveAll(any(List.class));
	}

	@Test
	public void serviceThrowsCharacteristicsSaveExceptionWhenProblemsOccurDuringSave() {
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String characteristicsTypeCode = "ABCDEFGH";
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		readList.add(new FactsetMonthlyCharacteristicsTargetDAO());
		readList.get(0).setCharacteristicsType(characteristicsTypeCode);
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		writeList.add(new Characteristics());
		Exception cause = new RuntimeException();
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(readList);
		when(converter1.handles(characteristicsTypeCode)).thenReturn(Boolean.TRUE);
		when(converter1.convert(readList)).thenReturn(writeList);
		when(writeRepo.saveAll(writeList)).thenThrow(cause);
		try {
			classUnderTest.transfer(asOfDate, portId, request);
		}
		catch (SaveCharacteristicsException e) {
			assertEquals(cause, e.getCause());
		}
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
		verify(converter1, times(1)).convert(readList);
		verify(writeRepo, times(1)).saveAll(writeList);
	}

	@SuppressWarnings("unchecked")
	@Test
	public void serviceUsesOnlyConverterAgreeingToHandleCharacteristicType() {
		converters.add(converter2);
		converters.add(converter3);
		
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String characteristicsTypeCode = "ABCDEFGH";
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		readList.add(new FactsetMonthlyCharacteristicsTargetDAO());
		readList.get(0).setCharacteristicsType(characteristicsTypeCode);
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		writeList.add(new Characteristics());
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(readList);
		when(converter1.handles(characteristicsTypeCode)).thenReturn(Boolean.FALSE);
		when(converter2.handles(characteristicsTypeCode)).thenReturn(Boolean.TRUE);
		when(converter2.convert(readList)).thenReturn(writeList);
		when(writeRepo.saveAll(writeList)).thenReturn(writeList);
		
		classUnderTest.transfer(asOfDate, portId, request);
		
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
		verify(converter1, times(1)).handles(characteristicsTypeCode);
		verify(converter2, times(1)).handles(characteristicsTypeCode);
		verify(converter3, never()).handles(characteristicsTypeCode);
		verify(converter1, never()).convert(any(List.class));
		verify(converter2, times(1)).convert(readList);
		verify(converter3, never()).convert(any(List.class));
		verify(writeRepo, times(1)).saveAll(writeList);
	}

	@Test
	public void servicePassesToConverterOnlyCharacteristicsThatConverterHandles() {
		List<CheckableCharacteristicsConverter> checkableConverters = new ArrayList<>();
		Whitebox.setInternalState(classUnderTest, "converters", checkableConverters);
		
		checkableConverters.add(new CheckableCharacteristicsConverter() {
			private final List<FactsetMonthlyCharacteristicsTargetDAO> convertedDaos = new ArrayList<>();
			
			@Override
			public boolean handles(String code) {
				return "ABCDEFGH".equals(code);
			}
			
			@Override
			public List<Characteristics> convert(List<FactsetMonthlyCharacteristicsTargetDAO> list) {
				convertedDaos.addAll(list);
				return new ArrayList<>();
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> getConvertedDaos() {
				return convertedDaos;
			}
		});
		
		checkableConverters.add(new CheckableCharacteristicsConverter() {
			private final List<FactsetMonthlyCharacteristicsTargetDAO> convertedDaos = new ArrayList<>();
			
			@Override
			public boolean handles(String code) {
				return "IJKLMNOP".equals(code);
			}
			
			@Override
			public List<Characteristics> convert(List<FactsetMonthlyCharacteristicsTargetDAO> list) {
				convertedDaos.addAll(list);
				return new ArrayList<>();
			}
			
			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> getConvertedDaos() {
				return convertedDaos;
			}
		});
		
		checkableConverters.add(new CheckableCharacteristicsConverter() {
			private final List<FactsetMonthlyCharacteristicsTargetDAO> convertedDaos = new ArrayList<>();
			
			@Override
			public boolean handles(String code) {
				return "QRSTUVWX".equals(code);
			}
			
			@Override
			public List<Characteristics> convert(List<FactsetMonthlyCharacteristicsTargetDAO> list) {
				convertedDaos.addAll(list);
				return new ArrayList<>();
			}
			
			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> getConvertedDaos() {
				return convertedDaos;
			}
		});
		
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		FactsetMonthlyCharacteristicsTargetDAO dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setCharacteristicsType("ABCDEFGH");
		readList.add(dao);
		dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setCharacteristicsType("QRSTUVWX");
		readList.add(dao);
		dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setCharacteristicsType("QRSTUVWX");
		readList.add(dao);
		dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setCharacteristicsType("IJKLMNOP");
		readList.add(dao);
		dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setCharacteristicsType("ABCDEFGH");
		readList.add(dao);
		dao = new FactsetMonthlyCharacteristicsTargetDAO();
		dao.setCharacteristicsType("IJKLMNOP");
		readList.add(dao);
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(readList);
		when(writeRepo.saveAll(writeList)).thenReturn(writeList);
		classUnderTest.transfer(asOfDate, portId, request);
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
		verify(writeRepo, times(1)).saveAll(writeList);
		
		for (FactsetMonthlyCharacteristicsTargetDAO d : checkableConverters.get(0).getConvertedDaos()) {
			assertEquals("ABCDEFGH", d.getCharacteristicsType());
		}
		
		for (FactsetMonthlyCharacteristicsTargetDAO d : checkableConverters.get(1).getConvertedDaos()) {
			assertEquals("IJKLMNOP", d.getCharacteristicsType());
		}
		
		for (FactsetMonthlyCharacteristicsTargetDAO d : checkableConverters.get(2).getConvertedDaos()) {
			assertEquals("QRSTUVWX", d.getCharacteristicsType());
		}
	}

	@Test
	public void serviceThrowsSaveExceptionWhenEncounteringCharacteristicsWithoutConverter() {
		boolean expectedExceptionIsCaught = false;
		String portId = null;
		Date asOfDate = new Date();
		HttpServletRequest request = null;
		String characteristicsTypeCode = "ABCDEFGH";
		List<FactsetMonthlyCharacteristicsTargetDAO> readList = new ArrayList<FactsetMonthlyCharacteristicsTargetDAO>();
		readList.add(new FactsetMonthlyCharacteristicsTargetDAO());
		readList.get(0).setCharacteristicsType(characteristicsTypeCode);
		List<Characteristics> writeList = new ArrayList<Characteristics>();
		writeList.add(new Characteristics());
		
		when(readRepo.findByEffectiveDate(asOfDate)).thenReturn(readList);
		when(converter1.handles(characteristicsTypeCode)).thenReturn(Boolean.FALSE);
		try {
			classUnderTest.transfer(asOfDate, portId, request);
		}
		catch (SaveCharacteristicsException e) {
			assertNull(e.getCause());
			assertTrue(e.getMessage().indexOf("Unknown characteristics type code: "+characteristicsTypeCode) > -1);
			expectedExceptionIsCaught = true;
		}
		verify(readRepo, times(1)).findByEffectiveDate(asOfDate);
		verify(converter1, times(1)).handles(characteristicsTypeCode);
		
		assertTrue(expectedExceptionIsCaught);
	}

	private interface CheckableCharacteristicsConverter extends CharacteristicsConverter {
		List<FactsetMonthlyCharacteristicsTargetDAO> getConvertedDaos();
	}

}

com.vanguard.corp.ics.sdt.behaviors.risksummary
		RiskSummaryTransfersTest.java

package com.vanguard.corp.ics.sdt.behaviors.risksummary;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestPortfolioLimitRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.LimitValidator;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.RiskSummaryServiceImpl;


public class RiskSummaryTransfersTest {

	private static final String PORT_ID_1 = "PORT01";
	private static final String CURRENT_USERNAME = "Utilities Username";

	@InjectMocks
	private TransferService classUnderTest = new RiskSummaryServiceImpl();

	@Mock
	private ProductPortalService productPortalService;

	@Spy
	private TestPortfolioLimitRepository repo = new TestPortfolioLimitRepository();

	@Mock
	private HttpServletRequest request;

	@Mock
	private Utilities utilites;
	
	@Mock
	private LimitValidator limitValidator;
	
	private List<PortalProduct> portalProducts;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		
		portalProducts = new ArrayList<>();
		when(productPortalService.getProducts(request)).thenReturn(portalProducts);
	}

	@Test
	public void serviceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, classUnderTest.getPriority());
	}

	@Test
	public void serviceWantsToHandleRiskSummaryDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, DataSetType.RISK_SUMMARY, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(classUnderTest.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(classUnderTest.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	@Test
	public void serviceDoesNothingWithoutPortId() {
		//TODO update with real behavior specifications
		classUnderTest.transfer(null, null, null);
	}

	@Test
	public void serviceTransfersExAnteRiskForGivenPortId() {
		//TODO udpate with real behavior specifications
		PortalProduct product = new PortalProduct();
		product.setExAnteMaxBreachIMA("123.45678");
		
		when(utilites.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(Double.class), nullable(Double.class), nullable(Double.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, request);
		
		Limit limit = repo.dataMap.get(AnalyticsTypeCode.EX_ANTE_RISK.getName());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertEquals((Double) 1.2345678, limit.getLowerLimitValue());
		assertNull(limit.getUpperLimitValue());
		assertNull(limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(AnalyticsTypeCode.ONE_YR_EX_POST.getName());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(AnalyticsTypeCode.THREE_YR_EX_POST.getName());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
		
		Limit limit4 = repo.dataMap.get(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName());
		assertNotNull(limit4);
		assertEquals(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName(), limit4.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getCode(), limit4.getLimitTypeCode());
		assertNull(limit4.getLowerLimitValue());
		assertNull(limit4.getUpperLimitValue());
		assertNull(limit4.getFumSplitLimitValue());
		
		Limit limit5 = repo.dataMap.get(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName());
		assertNotNull(limit5);
		assertEquals(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName(), limit5.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getCode(), limit5.getLimitTypeCode());
		assertNull(limit5.getLowerLimitValue());
		assertNull(limit5.getUpperLimitValue());
		assertNull(limit5.getFumSplitLimitValue());
	}
	
	@Test
	public void serviceTranfersExAnteRiskWithUpperAndSplitLimitForGivenPortId() {
		//TODO udpate with real behavior specifications
		PortalProduct product = new PortalProduct();
		product.setExAnteMaxBreachIMA("123.45678");
		product.setExAnteMaxBreachIMAAbvLmt("246.91356");
		product.setExAnteFumSplitLimit((Double) 5.0E7);
		
		when(utilites.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(Double.class), nullable(Double.class), nullable(Double.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, request);
		
		Limit limit = repo.dataMap.get(AnalyticsTypeCode.EX_ANTE_RISK.getName());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertEquals((Double) 1.2345678, limit.getLowerLimitValue());
		assertEquals((Double) 2.4691356, limit.getUpperLimitValue());
		assertEquals((Double) 5.0E7, limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(AnalyticsTypeCode.ONE_YR_EX_POST.getName());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(AnalyticsTypeCode.THREE_YR_EX_POST.getName());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
		
		Limit limit4 = repo.dataMap.get(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName());
		assertNotNull(limit4);
		assertEquals(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName(), limit4.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getCode(), limit4.getLimitTypeCode());
		assertNull(limit4.getLowerLimitValue());
		assertNull(limit4.getUpperLimitValue());
		assertNull(limit4.getFumSplitLimitValue());
		
		Limit limit5 = repo.dataMap.get(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName());
		assertNotNull(limit5);
		assertEquals(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName(), limit5.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getCode(), limit5.getLimitTypeCode());
		assertNull(limit5.getLowerLimitValue());
		assertNull(limit5.getUpperLimitValue());
		assertNull(limit5.getFumSplitLimitValue());
	}
	
	@Test
	public void serviceTransfersNoLimitsForGivenPortId() {
		//TODO udpate with real behavior specifications
		PortalProduct product = new PortalProduct();
		
		when(utilites.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(productPortalService.getProduct(portalProducts, PORT_ID_1)).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(Double.class), nullable(Double.class), nullable(Double.class))).thenReturn(true);
		
		classUnderTest.transfer(null, PORT_ID_1, request);
		
		Limit limit = repo.dataMap.get(AnalyticsTypeCode.EX_ANTE_RISK.getName());
		assertNotNull(limit);
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getName(), limit.getLimitName());
		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK.getCode(), limit.getLimitTypeCode());
		assertNull(limit.getLowerLimitValue());
		assertNull(limit.getUpperLimitValue());
		assertNull(limit.getFumSplitLimitValue());
		
		Limit limit2 = repo.dataMap.get(AnalyticsTypeCode.ONE_YR_EX_POST.getName());
		assertNotNull(limit2);
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getName(), limit2.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_EX_POST.getCode(), limit2.getLimitTypeCode());
		assertNull(limit2.getLowerLimitValue());
		assertNull(limit2.getUpperLimitValue());
		assertNull(limit2.getFumSplitLimitValue());
		
		Limit limit3 = repo.dataMap.get(AnalyticsTypeCode.THREE_YR_EX_POST.getName());
		assertNotNull(limit3);
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getName(), limit3.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_EX_POST.getCode(), limit3.getLimitTypeCode());
		assertNull(limit3.getLowerLimitValue());
		assertNull(limit3.getUpperLimitValue());
		assertNull(limit3.getFumSplitLimitValue());
		
		Limit limit4 = repo.dataMap.get(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName());
		assertNotNull(limit4);
		assertEquals(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName(), limit4.getLimitName());
		assertEquals(AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getCode(), limit4.getLimitTypeCode());
		assertNull(limit4.getLowerLimitValue());
		assertNull(limit4.getUpperLimitValue());
		assertNull(limit4.getFumSplitLimitValue());
		
		Limit limit5 = repo.dataMap.get(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName());
		assertNotNull(limit5);
		assertEquals(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName(), limit5.getLimitName());
		assertEquals(AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getCode(), limit5.getLimitTypeCode());
		assertNull(limit5.getLowerLimitValue());
		assertNull(limit5.getUpperLimitValue());
		assertNull(limit5.getFumSplitLimitValue());
	}
}

com.vanguard.corp.ics.sdt.dao.api.constants
		DatabaseConstantsTest.java

package com.vanguard.corp.ics.sdt.dao.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class DatabaseConstantsTest {

	@Test
	public void testConstants() {
		assertEquals("CurrentM", DatabaseConstants.PORTFOLIO_VALUATION_TYPE_CODE_CURRENT);
	}

}

		RestServiceConstantsTest.java

package com.vanguard.corp.ics.sdt.dao.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class RestServiceConstantsTest {

	@Test
	public void testConstants() {
		assertEquals("dd-MMM-yyyy", RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT);
	}
	
}

com.vanguard.corp.ics.sdt.dao.api.domain.portal
		CurrencyTest.java

package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class CurrencyTest {

	@Test
	public void shouldGetAndSetValues() {
		Currency currency = new Currency();
		
		Long currencyId = Long.valueOf(1);
		String currencyCode = "AUD";
		String currencyName = "Australian Dollar123";
		
		currency.setCurrencyId(currencyId);
		currency.setCurrencyCode(currencyCode);
		currency.setCurrencyName(currencyName);
		
		assertEquals(currency.getCurrencyId(), currencyId);
		assertEquals(currency.getCurrencyCode(), currencyCode);
		assertEquals(currency.getCurrencyName(), currencyName);
	}
	
	@Test
	public void shouldGetAndSetValuesWithNull() {
		Currency currency = new Currency();
		
		currency.setCurrencyId(null);
		currency.setCurrencyCode(null);
		currency.setCurrencyName(null);
		
		assertNull(currency.getCurrencyId());
		assertNull(currency.getCurrencyCode());
		assertNull(currency.getCurrencyName());
	}
}

		InvestmentGroupTest.java

package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class InvestmentGroupTest {
	
	public static final String INVSTMNT_GRP_CODE = "Test Investment Group Code";
	public static final String INVSTMNT_GRP_NAME = "Test Investment Group Name";

	/**
	 * Test getters and setters
	 */
	@Test
	public void shouldGetAndSetValues(){
		InvestmentGroup investmentGroup = new InvestmentGroup();
		
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupCode(INVSTMNT_GRP_CODE);
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);
		
		assertEquals(investmentGroup.getInvestmentGroupId(), Long.valueOf(1));
		assertEquals(investmentGroup.getInvestmentGroupCode(), INVSTMNT_GRP_CODE);
		assertEquals(investmentGroup.getInvestmentGroupName(), INVSTMNT_GRP_NAME);
	}
}

		PortalProductTest.java

package com.vanguard.corp.ics.sdt.dao.api.domain.portal;

import static org.junit.Assert.assertEquals;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class PortalProductTest {
	
	@Test
	public void shouldGetAndSetValues() {
		PortalProduct portalProduct = new PortalProduct();
		
		Long productId = Long.valueOf(1);
		Long productTypeId = Long.valueOf(2);
		String productName = "ProductName";
		String clientId = "ClientID";
		String productCode = "ProductCode";
		String investmentStyleId = "InvestmentStyleID";
		Long assetClassId = Long.valueOf(3);
		Long investmentMarketId = Long.valueOf(4);
		String investmentObjective = "InvestmentObjective";
		Long investmentGroupId = Long.valueOf(5);
		Long baseCurrencyId = Long.valueOf(6);
		Long hedgeTypeId = Long.valueOf(7);
		double hedgePercentage = 1.1;
		Long hedgeCurrencyId = Long.valueOf(8);
		Long benchmarkProviderId = Long.valueOf(9);
		String benchmarkName = "BenchmarkName";
		Long custodianId = Long.valueOf(10);
		Long futuresClearingAgentId = Long.valueOf(11);
		double initialAum = 1.2;
		Long initialAumCurrencyId = Long.valueOf(12);
		String perfInceptionDate = "PerfInceptionDate";
		Long productFundingTypeId = Long.valueOf(13);
		Long investmentManagementEntityId = Long.valueOf(14);
		Long contactingEntityId = Long.valueOf(15);
		Long salesTeamEntityId = Long.valueOf(16);
		String targetLaunchDate = "TargetLaunchDate";
		Long statusId = Long.valueOf(17);
		String modifiedBy = "ModifiedBy";
		Currency currency = new Currency();
		InvestmentGroup investmentGroup = new InvestmentGroup();
		String exAnteMaxBreachIma = "ExAnteMaxBreachIma";
		String exPostMaxBreachIma = "ExPostMaxBreachIma";
		String modifiedDate = "2000-01-01";
		LocalDate modifiedLocalDate = LocalDate.parse(modifiedDate, DateTimeFormatter.ISO_LOCAL_DATE);
		
		portalProduct.setProductID(productId);
		portalProduct.setProductTypeID(productTypeId);
		portalProduct.setProductName(productName);
		portalProduct.setClientID(clientId);
		portalProduct.setProductCode(productCode);
		portalProduct.setInvestmentStyleID(investmentStyleId);
		portalProduct.setAssetClassID(assetClassId);
		portalProduct.setInvestmentMarketID(investmentMarketId);
		portalProduct.setInvestmentObjective(investmentObjective);
		portalProduct.setInvestmentGroupID(investmentGroupId);
		portalProduct.setBaseCurrencyID(baseCurrencyId);
		portalProduct.setHedgeTypeID(hedgeTypeId);
		portalProduct.setHedgePercentage(hedgePercentage);
		portalProduct.setHedgeCurrencyID(hedgeCurrencyId);
		portalProduct.setBenchMarkProviderID(benchmarkProviderId);
		portalProduct.setBenchMarkName(benchmarkName);
		portalProduct.setCustodianID(custodianId);
		portalProduct.setFuturesClearingAgentID(futuresClearingAgentId);
		portalProduct.setInitialAUM(initialAum);
		portalProduct.setInitialAUMCurrencyID(initialAumCurrencyId);
		portalProduct.setPerfInceptionDate(perfInceptionDate);
		portalProduct.setProductFundingTypeID(productFundingTypeId);
		portalProduct.setInvestmentManagementEntityID(investmentManagementEntityId);
		portalProduct.setContactingEntityID(contactingEntityId);
		portalProduct.setSalesTeamEntityID(salesTeamEntityId);
		portalProduct.setTargetLaunchDate(targetLaunchDate);
		portalProduct.setStatusID(statusId);
		portalProduct.setModifiedBy(modifiedBy);
		portalProduct.setCurrency(currency);
		portalProduct.setInvestmentGroup(investmentGroup);
		portalProduct.setExAnteMaxBreachIMA(exAnteMaxBreachIma);
		portalProduct.setExPostMaxBreachIMA(exPostMaxBreachIma);
		portalProduct.setModifiedDate(modifiedDate);
		
		assertEquals(portalProduct.getProductID(), productId);
		assertEquals(portalProduct.getProductTypeID(), productTypeId);
		assertEquals(portalProduct.getProductName(), productName);
		assertEquals(portalProduct.getClientID(), clientId);
		assertEquals(portalProduct.getProductCode(), productCode);
		assertEquals(portalProduct.getInvestmentStyleID(), investmentStyleId);
		assertEquals(portalProduct.getAssetClassID(), assetClassId);
		assertEquals(portalProduct.getInvestmentMarketID(), investmentMarketId);
		assertEquals(portalProduct.getInvestmentObjective(), investmentObjective);
		assertEquals(portalProduct.getInvestmentGroupID(), investmentGroupId);
		assertEquals(portalProduct.getBaseCurrencyID(), baseCurrencyId);
		assertEquals(portalProduct.getHedgeTypeID(), hedgeTypeId);
		assertEquals(portalProduct.getHedgePercentage(), hedgePercentage, 0);
		assertEquals(portalProduct.getHedgeCurrencyID(), hedgeCurrencyId);
		assertEquals(portalProduct.getBenchMarkProviderID(), benchmarkProviderId);
		assertEquals(portalProduct.getBenchMarkName(), benchmarkName);
		assertEquals(portalProduct.getCustodianID(), custodianId);
		assertEquals(portalProduct.getFuturesClearingAgentID(), futuresClearingAgentId);
		assertEquals(portalProduct.getInitialAUM(), initialAum, 0);
		assertEquals(portalProduct.getInitialAUMCurrencyID(), initialAumCurrencyId);
		assertEquals(portalProduct.getPerfInceptionDate(), perfInceptionDate);
		assertEquals(portalProduct.getProductFundingTypeID(), productFundingTypeId);
		assertEquals(portalProduct.getInvestmentManagementEntityID(), investmentManagementEntityId);
		assertEquals(portalProduct.getContactingEntityID(), contactingEntityId);
		assertEquals(portalProduct.getSalesTeamEntityID(), salesTeamEntityId);
		assertEquals(portalProduct.getTargetLaunchDate(), targetLaunchDate);
		assertEquals(portalProduct.getStatusID(), statusId);
		assertEquals(portalProduct.getModifiedBy(), modifiedBy);
		assertEquals(portalProduct.getCurrency(), currency);
		assertEquals(portalProduct.getInvestmentGroup(), investmentGroup);
		assertEquals(portalProduct.getExAnteMaxBreachIMA(), exAnteMaxBreachIma);
		assertEquals(portalProduct.getExPostMaxBreachIMA(), exPostMaxBreachIma);
		assertEquals(modifiedLocalDate, portalProduct.getModifiedDate());
	}
}

com.vanguard.corp.ics.sdt.dao.impl.config
		PortalConfigurationTest.java

package com.vanguard.corp.ics.sdt.dao.impl.config;

import static org.junit.Assert.*;

import org.junit.Test;

public class PortalConfigurationTest {

	@Test
	public void testGettersAndSetters() {
		PortalConfiguration configuration = new PortalConfiguration();
		
		String anyPortalProductEndpoint = "TestPortalProductEndpoint";
		String anyPortalReferenceEndpoint = "TestPortalRefereceEndpoint";
		int anyRetryCount = 5;
		
		configuration.setPortalProductEndpoint(anyPortalProductEndpoint);
		configuration.setPortalReferenceEndpoint(anyPortalReferenceEndpoint);
		configuration.setMaxConnectionAttempts(anyRetryCount);
		
		assertEquals(anyPortalProductEndpoint, configuration.getPortalProductEndpoint());
		assertEquals(anyPortalReferenceEndpoint, configuration.getPortalReferenceEndpoint());
		assertEquals(anyRetryCount, configuration.getMaxConnectionAttempts());
	}

}


		ReportingDatabaseConfigurationTest.java

package com.vanguard.corp.ics.sdt.dao.impl.config;

import static org.junit.Assert.*;

import java.util.Map;

import org.apache.tomcat.jdbc.pool.DataSource;
import org.apache.tomcat.jdbc.pool.PoolConfiguration;
import org.apache.tomcat.jdbc.pool.PoolProperties;
import org.junit.Before;
import org.junit.Test;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.PlatformTransactionManager;

public class ReportingDatabaseConfigurationTest {

	private ReportingDatabaseConfiguration reportingDatabaseConfiguration;
	
	private String datasourceUsername = "testUser";
	private String datasourcePassword = "testPassword";
	private String datasourceUrl = "testUrl";
	
	@Before
	public void init() {
		reportingDatabaseConfiguration = new ReportingDatabaseConfiguration();
		
		ReflectionTestUtils.setField(reportingDatabaseConfiguration, "sdtDataSourceReportingUsername", datasourceUsername);
		ReflectionTestUtils.setField(reportingDatabaseConfiguration, "sdtDataSourceReportingPassword", datasourcePassword);
		ReflectionTestUtils.setField(reportingDatabaseConfiguration, "sdtReportingConnectionUrl", datasourceUrl);
	}
	
	@Test
	public void testDataSource() {
		DataSource testDataSource = reportingDatabaseConfiguration.dataSource();
		
		PoolProperties poolProperties = new PoolProperties();
		poolProperties.setUrl(datasourceUrl);
		poolProperties.setDriverClassName("oracle.jdbc.OracleDriver");
		poolProperties.setUsername(datasourceUsername);
		poolProperties.setPassword(datasourcePassword);
		poolProperties.setDefaultAutoCommit(false);
		poolProperties.setDefaultReadOnly(false);
		poolProperties.setDefaultTransactionIsolation(2);
		poolProperties.setJmxEnabled(false);
		poolProperties.setTestWhileIdle(true);
		poolProperties.setTestOnBorrow(true);
		poolProperties.setValidationQuery("SELECT 1 FROM DUAL");
		poolProperties.setTestOnReturn(false);
		poolProperties.setValidationInterval(30000);
		poolProperties.setTimeBetweenEvictionRunsMillis(30000);
		poolProperties.setMaxActive(1000);
		poolProperties.setInitialSize(5);
		poolProperties.setMaxWait(10000);
		poolProperties.setRemoveAbandonedTimeout(30);
		poolProperties.setMinEvictableIdleTimeMillis(30000);
		poolProperties.setMinIdle(10);
		poolProperties.setLogAbandoned(true);
		poolProperties.setRemoveAbandoned(true);
		poolProperties.setJdbcInterceptors("org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;"
				+ "org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");

		PoolConfiguration actualProperties = testDataSource.getPoolProperties();
		
		assertEquals(poolProperties.getUrl(), actualProperties.getUrl());
		assertEquals(poolProperties.getDriverClassName(), actualProperties.getDriverClassName());
		assertEquals(poolProperties.getUsername(), actualProperties.getUsername());
		assertEquals(poolProperties.getPassword(), actualProperties.getPassword());
		assertEquals(poolProperties.getDefaultAutoCommit(), actualProperties.getDefaultAutoCommit());
		assertEquals(poolProperties.getDefaultReadOnly(), actualProperties.getDefaultReadOnly());
		assertEquals(poolProperties.getDefaultTransactionIsolation(), actualProperties.getDefaultTransactionIsolation());
		assertEquals(poolProperties.isJmxEnabled(), actualProperties.isJmxEnabled());
		assertEquals(poolProperties.isTestWhileIdle(), actualProperties.isTestWhileIdle());
		assertEquals(poolProperties.isTestOnBorrow(), actualProperties.isTestOnBorrow());
		assertEquals(poolProperties.getValidationQuery(), actualProperties.getValidationQuery());
		assertEquals(poolProperties.isTestOnReturn(), actualProperties.isTestOnReturn());
		assertEquals(poolProperties.getValidationInterval(), actualProperties.getValidationInterval());
		assertEquals(poolProperties.getTimeBetweenEvictionRunsMillis(), actualProperties.getTimeBetweenEvictionRunsMillis());
		assertEquals(poolProperties.getMaxActive(), actualProperties.getMaxActive());
		assertEquals(poolProperties.getInitialSize(), actualProperties.getInitialSize());
		assertEquals(poolProperties.getMaxWait(), actualProperties.getMaxWait());
		assertEquals(poolProperties.getRemoveAbandonedTimeout(), actualProperties.getRemoveAbandonedTimeout());
		assertEquals(poolProperties.getMinEvictableIdleTimeMillis(), actualProperties.getMinEvictableIdleTimeMillis());
		assertEquals(poolProperties.getMinIdle(), actualProperties.getMinIdle());
		assertEquals(poolProperties.isLogAbandoned(), actualProperties.isLogAbandoned());
		assertEquals(poolProperties.isRemoveAbandoned(), actualProperties.isRemoveAbandoned());
		assertEquals(poolProperties.getJdbcInterceptors(), actualProperties.getJdbcInterceptors());
	}
	
	@Test
	public void testGetReportingEntityManagerFactory() {
		String testPersistenceUnitName = "GRMDB";
		String testHibernateDialect = "org.hibernate.dialect.Oracle10gDialect";
		String testHibernateShowSql = "true";
		String testHibernateFormatSql = "true";
		String testUseSqlComments = "false";
		String testEnableLazyLoadNoTrans = "true";
	
		LocalContainerEntityManagerFactoryBean factory = reportingDatabaseConfiguration.getReportingEntityManagerFactory();
		
		Map<String, Object> properties = factory.getJpaPropertyMap();

		assertEquals(testPersistenceUnitName, factory.getPersistenceUnitName());
		assertEquals(testHibernateDialect, properties.get("hibernate.dialect"));
		assertEquals(testHibernateShowSql, properties.get("hibernate.show_sql"));
		assertEquals(testHibernateFormatSql, properties.get("hibernate.format_sql"));
		assertEquals(testUseSqlComments, properties.get("hibernate.use_sql_comments"));
		assertEquals(testEnableLazyLoadNoTrans, properties.get("hibernate.enable_lazy_load_no_trans"));
	}

	@Test
	public void testTransactionManager() {
		PlatformTransactionManager transactionManager = reportingDatabaseConfiguration.transactionManager();
		assertNotNull(transactionManager);
		assertTrue(transactionManager instanceof JpaTransactionManager);
	}
}


com.vanguard.corp.ics.sdt.dao.impl.entity.report
		AccountBenchmarkAssociationTest.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.util.Date;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class AccountBenchmarkAssociationTest {
	
	public static final String BENCHMARK_EIP_ID = "Test Benchmark EIP ID";
	public static final String BENCHMARK_ASSOC_TYPE = "Test Benchmark Association Type";
	public static final String LAST_UPDATED_USER = "Test Last Updated User";
	public static final String BENCHMARK_NAME = "Test Benchmark Name";
	
	
	/**
	 * Test getters and setters 
	 */
	@Test
	public void shouldGetAndSetValues(){
		AccountBenchmarkAssociation accountBenchmarkAssociation = new AccountBenchmarkAssociation();
		
		accountBenchmarkAssociation.setId(Long.valueOf(1));
		accountBenchmarkAssociation.setBenchmarkEipId(BENCHMARK_EIP_ID);
		accountBenchmarkAssociation.setBenchmarkAssociationType(BENCHMARK_ASSOC_TYPE);
		accountBenchmarkAssociation.setUpdatedUser(LAST_UPDATED_USER);
		accountBenchmarkAssociation.setUpdatedDate(new Date(1));
		accountBenchmarkAssociation.setBenchmarkName(BENCHMARK_NAME);
		
		assertEquals(accountBenchmarkAssociation.getId(), Long.valueOf(1));
		assertEquals(accountBenchmarkAssociation.getBenchmarkEipId(), BENCHMARK_EIP_ID);
		assertEquals(accountBenchmarkAssociation.getBenchmarkAssociationType(), BENCHMARK_ASSOC_TYPE);
		assertEquals(accountBenchmarkAssociation.getUpdatedUser(), LAST_UPDATED_USER);
		assertEquals(accountBenchmarkAssociation.getUpdatedDate(), new Date(1));
		assertEquals(accountBenchmarkAssociation.getBenchmarkName(), BENCHMARK_NAME);
	
		
	}

}

			AccountFundTest.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.junit.MockitoJUnitRunner;
import java.util.Calendar;

@RunWith(MockitoJUnitRunner.class)
public class AccountFundTest {
	private final Long TEST_ID = Long.valueOf(1);
	private final String TEST_PORTFOLIO_ID = "Portfolio ID1";
	private final String TEST_ACCOUNT_NAME = "Account Name1";
	private final String TEST_ACCOUNT_TYPE = "Account Type1";
	private final Long TEST_ASSET_CLASSIFICATION_ID = Long.valueOf(2);
	private final double TEST_PRODUCT_EIP_ID = 3.0;
	private final String TEST_MANAGEMENT_STRATEGY = "Management Stategy1";
	private final String TEST_PORTFOLIO_BASE_CURRENCY = "Portfolio Base Currency1";
	private final String TEST_UPDATED_USER = "Updated User1"; 
	private final Long TEST_PORTFOLIO_SIZE = Long.valueOf(4);
	private final Long TEST_PORTFOLIO_MANAGER_ID = Long.valueOf(5);
	private final String TEST_INVESTMENT_OBJECTIVE = "Investment Objective1";
	private final String TEST_PORTFOLIO_MANAGER = "Portfolio Manager1";
	
	
	@InjectMocks
	private AccountFund accountFund;

	@Test
	public void test() throws ParseException {
		Calendar cal = Calendar.getInstance();
		SimpleDateFormat formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss");
		String InceptionDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss")
				.format(cal.getTime());
		Date inceptionDate = formatter.parse(InceptionDateInString);
		String UpdatedDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		Date updatedDate = formatter.parse(UpdatedDateInString);

		assertNull(accountFund.getId());
		assertNull(accountFund.getPortfolioId());
		assertNull(accountFund.getAccountName());
		assertNull(accountFund.getAccountType());
		assertNull(accountFund.getAssetClassificationId());
		assertNull(accountFund.getManagementStrategy());
		assertNull(accountFund.getPortfolioBaseCurrency());
		assertNull(accountFund.getInceptionDate());
		assertNull(accountFund.getUpdatedUser());
		assertNull(accountFund.getUpdatedDate());
		assertNull(accountFund.getPortfolioSize());
		assertNull(accountFund.getPortfolioManagerId());
		assertNull(accountFund.getInvestmentObjective());
		assertNull(accountFund.getPortfolioManager());

		accountFund.setId(TEST_ID);
		accountFund.setPortfolioId(TEST_PORTFOLIO_ID);
		accountFund.setAccountName(TEST_ACCOUNT_NAME);
		accountFund.setAccountType(TEST_ACCOUNT_TYPE);
		accountFund.setAssetClassificationId(TEST_ASSET_CLASSIFICATION_ID);
		accountFund.setProductEipID(TEST_PRODUCT_EIP_ID);
		accountFund.setManagementStrategy(TEST_MANAGEMENT_STRATEGY);
		accountFund.setPortfolioBaseCurrency(TEST_PORTFOLIO_BASE_CURRENCY);
		accountFund.setInceptionDate(inceptionDate);
		accountFund.setUpdatedUser(TEST_UPDATED_USER);
		accountFund.setUpdatedDate(updatedDate);
		accountFund.setPortfolioSize(TEST_PORTFOLIO_SIZE);
		accountFund.setPortfolioManagerId(TEST_PORTFOLIO_MANAGER_ID);
		accountFund.setInvestmentObjective(TEST_INVESTMENT_OBJECTIVE);
		accountFund.setPortfolioManager(TEST_PORTFOLIO_MANAGER);

		assertEquals(TEST_ID, accountFund.getId());
		assertEquals(TEST_PORTFOLIO_ID, accountFund.getPortfolioId());
		assertEquals(TEST_ACCOUNT_NAME, accountFund.getAccountName());
		assertEquals(TEST_ACCOUNT_TYPE, accountFund.getAccountType());
		assertEquals(TEST_ASSET_CLASSIFICATION_ID, accountFund.getAssetClassificationId());
		assertEquals(TEST_PRODUCT_EIP_ID, accountFund.getProductEipID(), 0.0);
		assertEquals(TEST_MANAGEMENT_STRATEGY, accountFund.getManagementStrategy());
		assertEquals(TEST_PORTFOLIO_BASE_CURRENCY, accountFund.getPortfolioBaseCurrency());
		assertEquals(inceptionDate, accountFund.getInceptionDate());
		assertEquals(TEST_UPDATED_USER, accountFund.getUpdatedUser());
		assertEquals(updatedDate, accountFund.getUpdatedDate());
		assertEquals(TEST_PORTFOLIO_SIZE, accountFund.getPortfolioSize());
		assertEquals(TEST_PORTFOLIO_MANAGER_ID, accountFund.getPortfolioManagerId());
		assertEquals(TEST_INVESTMENT_OBJECTIVE, accountFund.getInvestmentObjective());
		assertEquals(TEST_PORTFOLIO_MANAGER, accountFund.getPortfolioManager());

		assertNotNull(accountFund.getId());
		assertNotNull(accountFund.getPortfolioId());
		assertNotNull(accountFund.getAccountName());
		assertNotNull(accountFund.getAccountType());
		assertNotNull(accountFund.getAssetClassificationId());
		assertNotNull(accountFund.getProductEipID());
		assertNotNull(accountFund.getManagementStrategy());
		assertNotNull(accountFund.getPortfolioBaseCurrency());
		assertNotNull(accountFund.getInceptionDate());
		assertNotNull(accountFund.getUpdatedUser());
		assertNotNull(accountFund.getUpdatedDate());
		assertNotNull(accountFund.getPortfolioSize());
		assertNotNull(accountFund.getPortfolioManagerId());
		assertNotNull(accountFund.getInvestmentObjective());
		assertNotNull(accountFund.getPortfolioManager());

	}
}

	AccountSetupTest.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.junit.MockitoJUnitRunner;
import java.util.Calendar;

@RunWith(MockitoJUnitRunner.class)
public class AccountSetupTest {

	private final Long TEST_ID = Long.valueOf(1);
	private final String TEST_PORTFOLIO_ID = "Portfolio ID1";
	private final String TEST_ACCOUNT_CLIENT_NAME ="Account Client Name1"; 
	private final String TEST_ADDRESS_LINE_ONE = " Address Line1";
	private final String TEST_ADDRESS_LINE_TWO = " address Line2";
	private final String TEST_ADDRESS_LINE_THREE = "Address Line3";
	private final String TEST_COUNTRY_NAME = "Country Name1";
	private final String TEST_POSTAL_CODE = "Postal Code1";
	private final String TEST_STATUS_CODE = "Status Code1";
	private final String TEST_UPDATED_USER = "Updated User1"; 
	
	@InjectMocks
	private AccountSetup accountSetup;

	@Test
	public void test() throws ParseException {

		Calendar cal = Calendar.getInstance();
		SimpleDateFormat formatter = new SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss");
		String BeginDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		Date beginDate = formatter.parse(BeginDateInString);
		String EndDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		Date endDate = formatter.parse(EndDateInString);
		String UpdatedDateInString = new java.text.SimpleDateFormat("EEEE, dd/MM/yyyy/hh:mm:ss").format(cal.getTime());
		Date updatedDate = formatter.parse(UpdatedDateInString);

		assertNull(accountSetup.getId());
		assertNull(accountSetup.getPortfolioId());
		assertNull(accountSetup.getAccountClientName());
		assertNull(accountSetup.getAddressLineOne());
		assertNull(accountSetup.getAddressLineTwo());
		assertNull(accountSetup.getAddressLineThree());
		assertNull(accountSetup.getCountryName());
		assertNull(accountSetup.getPostalCode());
		assertNull(accountSetup.getAgreementBeginDate());
		assertNull(accountSetup.getAgreementEndDate());
		assertNull(accountSetup.getStatusCode());
		assertNull(accountSetup.getUpdatedUser());
		assertNull(accountSetup.getUpdatedDate());

		
		accountSetup.setId(TEST_ID);
		accountSetup.setPortfolioId(TEST_PORTFOLIO_ID);
		accountSetup.setAccountClientName(TEST_ACCOUNT_CLIENT_NAME);
		accountSetup.setAddressLineOne(TEST_ADDRESS_LINE_ONE);
		accountSetup.setAddressLineTwo(TEST_ADDRESS_LINE_TWO);
		accountSetup.setAddressLineThree(TEST_ADDRESS_LINE_THREE);
		accountSetup.setCountryName(TEST_COUNTRY_NAME);
		accountSetup.setPostalCode(TEST_POSTAL_CODE);

		accountSetup.setAgreementBeginDate(beginDate);
		accountSetup.setAgreementEndDate(endDate);
		accountSetup.setStatusCode(TEST_STATUS_CODE);
		accountSetup.setUpdatedUser(TEST_UPDATED_USER);
		accountSetup.setUpdatedDate(updatedDate);

		assertEquals(TEST_ID, accountSetup.getId());
		assertEquals(TEST_PORTFOLIO_ID, accountSetup.getPortfolioId());
		assertEquals(TEST_ACCOUNT_CLIENT_NAME,
				accountSetup.getAccountClientName());
		assertEquals(TEST_ADDRESS_LINE_ONE, accountSetup.getAddressLineOne());
		assertEquals(TEST_ADDRESS_LINE_TWO, accountSetup.getAddressLineTwo());
		assertEquals(TEST_ADDRESS_LINE_THREE, accountSetup.getAddressLineThree());
		assertEquals(TEST_COUNTRY_NAME, accountSetup.getCountryName());
		assertEquals(TEST_POSTAL_CODE, accountSetup.getPostalCode());
		assertEquals(beginDate, accountSetup.getAgreementBeginDate());
		assertEquals(TEST_STATUS_CODE, accountSetup.getStatusCode());
		assertEquals(TEST_UPDATED_USER, accountSetup.getUpdatedUser());
		assertEquals(updatedDate, accountSetup.getUpdatedDate());

		assertNotNull(accountSetup.getId());
		assertNotNull(accountSetup.getPortfolioId());
		assertNotNull(accountSetup.getAccountClientName());
		assertNotNull(accountSetup.getAddressLineOne());
		assertNotNull(accountSetup.getAddressLineTwo());
		assertNotNull(accountSetup.getAddressLineThree());
		assertNotNull(accountSetup.getCountryName());
		assertNotNull(accountSetup.getPostalCode());
		assertNotNull(accountSetup.getAgreementBeginDate());
		assertNotNull(accountSetup.getAgreementEndDate());
		assertNotNull(accountSetup.getStatusCode());
		assertNotNull(accountSetup.getUpdatedUser());
		assertNotNull(accountSetup.getUpdatedDate());

	}

}

		CommentaryEntityTest.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.*;

import java.util.Date;

import org.junit.Test;

public class CommentaryEntityTest {
	
	private final Long TEST_ID = Long.valueOf(1);
	private final String TEST_PORTFOLIO_ID = "Portfolio ID1";
	private final Date TEST_EFFECTIVE_DATE = new Date(1);
	private final String TEST_COMMENTARY_TEXT = "Test commentary text";
	private final String TEST_COMMENTARY_REASON = "Test commentary reason type";
	private final Date TEST_EFFECTIVE_BEGIN_DATE = new Date(2);
	private final Date TEST_EFFECTIVE_END_DATE = new Date(3);

	/**
	 * Test getters and setters 
	 */
	@Test
	public void shouldGetAndSetValues(){
		Commentary commentary = new Commentary();
		
		commentary.setId(TEST_ID);
		commentary.setPortfolioId(TEST_PORTFOLIO_ID);
		commentary.setEffectiveDate(TEST_EFFECTIVE_DATE);
		commentary.setCommentaryText(TEST_COMMENTARY_TEXT);
		commentary.setCommentaryReason(TEST_COMMENTARY_REASON);
		commentary.setEffectiveBeginDate(TEST_EFFECTIVE_BEGIN_DATE);
		commentary.setEffectiveEndDate(TEST_EFFECTIVE_END_DATE);
		
		assertEquals(commentary.getId(), TEST_ID);
		assertEquals(commentary.getPortfolioId(), TEST_PORTFOLIO_ID);
		assertEquals(commentary.getEffectiveDate(), TEST_EFFECTIVE_DATE);
		assertEquals(commentary.getCommentaryText(), TEST_COMMENTARY_TEXT);
		assertEquals(commentary.getCommentaryReason(), TEST_COMMENTARY_REASON);
		assertEquals(commentary.getEffectiveBeginDate(), TEST_EFFECTIVE_BEGIN_DATE);
		assertEquals(commentary.getEffectiveEndDate(), TEST_EFFECTIVE_END_DATE);
	}

}

		LimitTest.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import static org.junit.Assert.assertEquals;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class LimitTest {
	
	private DateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);

	@Test
	public void shouldGetAndSetValues() throws Exception {
		Limit limit = new Limit();
		
		Long anyId = new Long(3);
		String uniquePortId = "TEST";
		Date anyEffectiveBeginDate = df.parse("2017-07-31");
		Date anyEffectiveEndDate = df.parse("2017-09-01");
		String anyLimitTypeCode = "TYPE";
		String anyLimitName = "Limit Name";
		Double anyLowerLimitValue = 0.1;
		Double anyUpperLimitValue = 0.2;
		Double anyFumSplitLimitValue = 0.3;
		String anyUpdatedUser = "XXXX";
		Date anyUpdatedDate = df.parse("2017-08-03");
		
		limit.setId(anyId);
		limit.setPortfolioCode(uniquePortId);
		limit.setEffectiveBeginDate(anyEffectiveBeginDate);
		limit.setEffectiveEndDate(anyEffectiveEndDate);
		limit.setLimitTypeCode(anyLimitTypeCode);
		limit.setLimitName(anyLimitName);
		limit.setLowerLimitValue(anyLowerLimitValue);
		limit.setUpperLimitValue(anyUpperLimitValue);
		limit.setFumSplitLimitValue(anyFumSplitLimitValue);		
		limit.setUpdatedUser(anyUpdatedUser);
		limit.setUpdatedDate(anyUpdatedDate);

		assertEquals(limit.getId(), anyId);
		assertEquals(limit.getPortfolioCode(), uniquePortId);
		assertEquals(limit.getEffectiveBeginDate(), anyEffectiveBeginDate);
		assertEquals(limit.getEffectiveEndDate(), anyEffectiveEndDate);
		assertEquals(limit.getLimitTypeCode(), anyLimitTypeCode);
		assertEquals(limit.getLimitName(), anyLimitName);
		assertEquals(limit.getLowerLimitValue(), anyLowerLimitValue);
		assertEquals(limit.getUpperLimitValue(), anyUpperLimitValue);
		assertEquals(limit.getFumSplitLimitValue(), anyFumSplitLimitValue);
		assertEquals(limit.getUpdatedUser(), anyUpdatedUser);
		assertEquals(limit.getUpdatedDate(), anyUpdatedDate);
	}
}



		ValuationsReportTest.java

package com.vanguard.corp.ics.sdt.dao.impl.entity.report;

import java.util.Date;

import org.junit.Test;
import org.junit.experimental.categories.Category;

import static org.junit.Assert.assertEquals;

import com.vanguard.corp.ics.dao.target.DatasourceFileDAO;
import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
public class ValuationsReportTest {

	private static final Long Id = Long.valueOf(1);
	private static final String testPortfolioCode = "One90";
	private static final Date testEffectiveDate = new Date();
	private static final Date testRunTimeStamp = new Date();
	private static final String testSecurityTypeCode = "Equity";
	private static final Double testValuationValue = 100.00;
	private static final Double testTotalValue = 2100.00;
	private static final String testCreatedUser = "UXXX";
	private static final Date testCreatedDate = new Date();
	private static final String testUpdatedUser = "UYYY";
	private static final Date testUpdatedDate = new Date();
	private static final String testPortfolioValuationTypeCode = "Test Type Code";
	private static final DatasourceFileDAO datasourceFileDAO = new DatasourceFileDAO();
	
	@Test
	public void gettersAndSetters(){
		ValuationsReport dao = new ValuationsReport();
		dao.setId(Id);
		dao.setPortfolioCode(testPortfolioCode);
		dao.setEffectiveDate(testEffectiveDate);
		dao.setRunTimestamp(testRunTimeStamp);
		dao.setSecurityTypeCode(testSecurityTypeCode);
		dao.setValuationValue(testValuationValue);
		dao.setTotalValue(testTotalValue);
		dao.setCreatedUser(testCreatedUser);
		dao.setCreatedDate(testCreatedDate);
		dao.setUpdatedUser(testUpdatedUser);
		dao.setUpdatedDate(testUpdatedDate);
		dao.setPortfolioValuationTypeCode(testPortfolioValuationTypeCode);
		dao.setDatasourceFileDAO(datasourceFileDAO);
		
		assertEquals(dao.getId(), Id);
		assertEquals(dao.getPortfolioCode(), testPortfolioCode);
		assertEquals(dao.getEffectiveDate(), testEffectiveDate);
		assertEquals(dao.getRunTimestamp(), testRunTimeStamp);
		assertEquals(dao.getSecurityTypeCode(), testSecurityTypeCode);
		assertEquals(dao.getValuationValue(), testValuationValue, 0);
		assertEquals(dao.getTotalValue(), testTotalValue, 0);
		assertEquals(dao.getCreatedUser(), testCreatedUser);
		assertEquals(dao.getCreatedDate(), testCreatedDate);
		assertEquals(dao.getUpdatedUser(), testUpdatedUser);
		assertEquals(dao.getUpdatedDate(), testUpdatedDate);
		assertEquals(dao.getPortfolioValuationTypeCode(), testPortfolioValuationTypeCode);
		assertEquals(datasourceFileDAO, dao.getDatasourceFileDAO());
	}
	
}

com.vanguard.corp.ics.sdt.dao.impl.portal
		
		ProductPortalHelperTest.java

package com.vanguard.corp.ics.sdt.dao.impl.portal;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.Invocation.Builder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.MediaType;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.powermock.reflect.Whitebox;

import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;


public class ProductPortalHelperTest {

	@Mock
	private Client mockClient;

	@Mock
	private WebTarget mockWebTarget;

	@Mock
	private Builder mockBuilder;

	@Mock
	private HttpServletRequest mockRequest;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testGetClient() {
		ProductPortalHelper pph = new ProductPortalHelper();
		assertNotNull(pph.getClient());
	}

	@Test
	public void testGetRequestMakesSuccessfulConnection() {
		when(mockClient.register(SecureClientRequestFeature.class)).thenReturn(mockClient);
		when(mockClient.target(any(String.class))).thenReturn(mockWebTarget);
		when(mockWebTarget.request(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.property(SecureClientRequestFeature.FORWARD_HTTP_SERVLET_REQUEST, mockRequest)).thenReturn(mockBuilder);
		when(mockBuilder.accept(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.get(String.class)).thenReturn("hi there!");
		
		PortalConfiguration config = new PortalConfiguration();
		config.setMaxConnectionAttempts(1);
		
		ProductPortalHelper pph = new ProductPortalHelper() {
			@Override
			protected Client getClient() {
				return mockClient;
			}
		};
		Whitebox.setInternalState(pph, PortalConfiguration.class, config);
		
		String response = pph.getRequest("blah", String.class, mockRequest);
		assertEquals("hi there!", response);
	}

	@Test
	public void testGetRequestMakesUnsuccessfulConnection() {
		when(mockClient.register(SecureClientRequestFeature.class)).thenReturn(mockClient);
		when(mockClient.target(any(String.class))).thenReturn(mockWebTarget);
		when(mockWebTarget.request(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.property(SecureClientRequestFeature.FORWARD_HTTP_SERVLET_REQUEST, mockRequest)).thenReturn(mockBuilder);
		when(mockBuilder.accept(MediaType.APPLICATION_JSON)).thenReturn(mockBuilder);
		when(mockBuilder.get(String.class)).thenThrow(new RuntimeException());
		
		PortalConfiguration config = new PortalConfiguration();
		config.setMaxConnectionAttempts(2);
		
		ProductPortalHelper pph = new ProductPortalHelper() {
			@Override
			protected Client getClient() {
				return mockClient;
			}
		};
		Whitebox.setInternalState(pph, PortalConfiguration.class, config);
		
		String response = pph.getRequest("blah", String.class, mockRequest);
		assertNull(response);
	}

}

		ProductPortalServiceImplTest.java


package com.vanguard.corp.ics.sdt.dao.impl.portal;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.eq;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.impl.config.PortalConfiguration;

public class ProductPortalServiceImplTest {

	@InjectMocks
	ProductPortalServiceImpl productPortalService;
	
	@Mock
	PortalConfiguration portalConfiguration;
	
	@Mock
	ProductPortalHelper productPortalHelper;

	private PortalProduct[] portalProducts;
	
	private PortalProduct portalProduct;
	private PortalProduct secondPortalProduct;

	private static final String PRODUCT_CODE = "ONE90";
	private static final String PRODUCT_CODE2 = "ONE91";
	private static final String PRODUCT_NAME = "OnePath Australian Listed Property Index Pool";
	private static final String PRODUCT_NAME2 = "OnePath Australian Bonds Index Pool";
	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final Long INVSTMNT_GRP_ID2 = Long.valueOf(2);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String INVSTMNT_GRP_NAME2 = "Fixed Income Group";
	private static final String CURRENCY_CODE = "AUD";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String INVSTMNT_OBJ2 = "Investment Objective 2";
	private static final String CLIENT_ID = "ANZ OnePath";
	private static final String CLIENT_ID2 = "ANZ OnePath2";
	private static final String BENCHMARK_NAME = "test";
	private static final String BENCHMARK_NAME2 = "Bloomberg AusBond Composite 0+ Years Index";
	
	private Currency currency;
	private InvestmentGroup investmentGroup;
	private InvestmentGroup secondInvestmentGroup;
	
	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		
		portalProduct = new PortalProduct();
		secondPortalProduct = new PortalProduct();
		
		portalProduct.setBaseCurrencyID(Long.valueOf(1));
		portalProduct.setBenchMarkName(BENCHMARK_NAME);
		portalProduct.setClientID(CLIENT_ID);
		portalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct.setProductCode(PRODUCT_CODE);
		portalProduct.setProductName(PRODUCT_NAME);
		portalProduct.setInvestmentObjective(INVSTMNT_OBJ);

		currency = new Currency();
		currency.setCurrencyCode(CURRENCY_CODE);
		currency.setCurrencyId(Long.valueOf(1));
		currency.setCurrencyName("Australian Dollar123");

		investmentGroup = new InvestmentGroup();
		investmentGroup.setInvestmentGroupCode("EIG");
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);
		
		secondPortalProduct.setBaseCurrencyID(Long.valueOf(1));
		secondPortalProduct.setBenchMarkName(BENCHMARK_NAME2);
		secondPortalProduct.setClientID(CLIENT_ID2);
		secondPortalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID2);
		secondPortalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		secondPortalProduct.setProductCode(PRODUCT_CODE2);
		secondPortalProduct.setProductName(PRODUCT_NAME2);
		secondPortalProduct.setInvestmentObjective(INVSTMNT_OBJ2);

		secondInvestmentGroup = new InvestmentGroup();
		secondInvestmentGroup.setInvestmentGroupCode("FIG");
		secondInvestmentGroup.setInvestmentGroupId(Long.valueOf(2));
		secondInvestmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME2);

		portalProducts = new PortalProduct[]{portalProduct, secondPortalProduct};
		
		when(portalConfiguration.getPortalProductEndpoint()).thenReturn("testString");
		when(portalConfiguration.getPortalReferenceEndpoint()).thenReturn("testString");
		when(productPortalHelper.getRequest(eq("testString/currency/1"), eq(Currency.class), any(HttpServletRequest.class))).thenReturn(currency);
		when(productPortalHelper.getRequest(eq("testString/investmentGroup/1"), eq(InvestmentGroup.class), any(HttpServletRequest.class)))
				.thenReturn(investmentGroup);
		when(productPortalHelper.getRequest(eq("testString/investmentGroup/2"), eq(InvestmentGroup.class), any(HttpServletRequest.class)))
				.thenReturn(secondInvestmentGroup);
		when(productPortalHelper.getRequest(eq("testString"), eq(PortalProduct[].class), any(HttpServletRequest.class))).thenReturn(portalProducts);
	}
	
	@Test
	public void testRetrieveInvestmentGroup() {
		HttpServletRequest mockRequest = Mockito.mock(HttpServletRequest.class);
		InvestmentGroup group = productPortalService.getInvestmentGroup(portalProduct, mockRequest);
		
		assertEquals(investmentGroup.getInvestmentGroupCode(), group.getInvestmentGroupCode());
		assertEquals(investmentGroup.getInvestmentGroupId(), group.getInvestmentGroupId());
		assertEquals(investmentGroup.getInvestmentGroupName(), group.getInvestmentGroupName());
	}
	
	@Test
	public void testRetrieveCurrencyCode() {
		HttpServletRequest mockRequest = Mockito.mock(HttpServletRequest.class);
		Currency curr = productPortalService.getProductCurrency(portalProduct, mockRequest);
		
		assertEquals(currency.getCurrencyCode(), curr.getCurrencyCode());
		assertEquals(currency.getCurrencyId(), curr.getCurrencyId());
		assertEquals(currency.getCurrencyName(), curr.getCurrencyName());
	}

	@Test
	public void testRetrieveSpecificProduct() {
		PortalProduct product = productPortalService.getProduct(Arrays.asList(portalProducts), portalProduct.getProductCode());
		
		compareProducts(portalProduct, product);
	}
	
	@Test
	public void testRetrieveAllProducts() {
		HttpServletRequest mockRequest = Mockito.mock(HttpServletRequest.class);
		List<PortalProduct> products = productPortalService.getProducts(mockRequest);
		
		for (PortalProduct product : products) {
			if (product.getProductCode().equals(portalProduct.getProductCode())) {
				compareProducts(portalProduct, product);
			} else {
				compareProducts(secondPortalProduct, product);
			}
		}
	}

	private void compareProducts(PortalProduct expected, PortalProduct actual) {
		assertEquals(expected.getAssetClassID(), actual.getAssetClassID());
		assertEquals(expected.getBaseCurrencyID(), actual.getBaseCurrencyID());
		assertEquals(expected.getBenchMarkName(), actual.getBenchMarkName());
		assertEquals(expected.getBenchMarkProviderID(), actual.getBenchMarkProviderID());
		assertEquals(expected.getClientID(), actual.getClientID());
		assertEquals(expected.getContactingEntityID(), actual.getContactingEntityID());
		assertEquals(expected.getCurrency(), actual.getCurrency());
		assertEquals(expected.getCustodianID(), actual.getCustodianID());
		assertEquals(expected.getExAnteMaxBreachIMA(), actual.getExAnteMaxBreachIMA());
		assertEquals(expected.getExPostMaxBreachIMA(), actual.getExPostMaxBreachIMA());
		assertEquals(expected.getFuturesClearingAgentID(), actual.getFuturesClearingAgentID());
		assertEquals(expected.getHedgeCurrencyID(), actual.getHedgeCurrencyID());
		assertEquals(expected.getHedgePercentage(), actual.getHedgePercentage());
		assertEquals(expected.getHedgeTypeID(), actual.getHedgeTypeID());
		assertEquals(expected.getInitialAUM(), actual.getInitialAUM());
		assertEquals(expected.getInitialAUMCurrencyID(), actual.getInitialAUMCurrencyID());
		assertEquals(expected.getInvestmentGroup(), actual.getInvestmentGroup());
		assertEquals(expected.getInvestmentGroupID(), actual.getInvestmentGroupID());
		assertEquals(expected.getInvestmentManagementEntityID(), actual.getInvestmentManagementEntityID());
		assertEquals(expected.getInvestmentMarketID(), actual.getInvestmentMarketID());
		assertEquals(expected.getInvestmentObjective(), actual.getInvestmentObjective());
		assertEquals(expected.getInvestmentStyleID(), actual.getInvestmentStyleID());
		assertEquals(expected.getModifiedBy(), actual.getModifiedBy());
		assertEquals(expected.getModifiedDate(), actual.getModifiedDate());
		assertEquals(expected.getPerfInceptionDate(), actual.getPerfInceptionDate());
		assertEquals(expected.getProductCode(), actual.getProductCode());
		assertEquals(expected.getProductFundingTypeID(), actual.getProductFundingTypeID());
		assertEquals(expected.getProductID(), actual.getProductID());
		assertEquals(expected.getProductName(), actual.getProductName());
		assertEquals(expected.getProductTypeID(), actual.getProductTypeID());
		assertEquals(expected.getSalesTeamEntityID(), actual.getSalesTeamEntityID());
		assertEquals(expected.getStatusID(), actual.getStatusID());
		assertEquals(expected.getTargetLaunchDate(), actual.getTargetLaunchDate());
	}
}


com.vanguard.corp.ics.sdt.dao.impl.repository
		
		TestAccountBenchmarkAssociationRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;

public class TestAccountBenchmarkAssociationRepository implements AccountBenchmarkAssociationRepository {
	
	public List<AccountBenchmarkAssociation> accountBenchmarkAssociationList = new ArrayList<>();
	public Map<String, AccountBenchmarkAssociation> accountBenchmarkAssociationMap = new HashMap<>();
	
	@Override
	public List<AccountBenchmarkAssociation> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountBenchmarkAssociation> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountBenchmarkAssociation> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends AccountBenchmarkAssociation> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends AccountBenchmarkAssociation> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<AccountBenchmarkAssociation> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public AccountBenchmarkAssociation getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<AccountBenchmarkAssociation> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(AccountBenchmarkAssociation arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends AccountBenchmarkAssociation> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public AccountBenchmarkAssociation findOne(Long arg0) {
		return accountBenchmarkAssociationMap.get(arg0.toString());
	}

	@Override
	public <S extends AccountBenchmarkAssociation> S save(S accountBenchmarkAssociation) {
		// TODO Auto-generated method stub
		accountBenchmarkAssociationList.add(accountBenchmarkAssociation);
		
		return accountBenchmarkAssociation;
	}

	@Override
	public AccountBenchmarkAssociation findByPortfolioIdIs(String portfolioId) {
		return accountBenchmarkAssociationMap.get(portfolioId);
	}
	
}

		TestAccountFundRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;

public class TestAccountFundRepository implements AccountFundRepository {
	
	public List<AccountFund> accountFunds = new ArrayList<>();
	public Map<String, AccountFund> accountFundMap = new HashMap<>();

	@Override
	public List<AccountFund> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountFund> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AccountFund> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends AccountFund> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends AccountFund> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<AccountFund> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public AccountFund getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<AccountFund> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(AccountFund arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends AccountFund> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public AccountFund findOne(Long arg0) {
		return accountFundMap.get(arg0.toString());
	}

	@Override
	public <S extends AccountFund> S save(S accountFund) {
		// TODO Auto-generated method stub
		accountFunds.add(accountFund);
		//this.accountFund= accountFund;
		
		return accountFund;
	}

	@Override
	public AccountFund findByPortfolioIdIs(String portfolioId) {
		return accountFundMap.get(portfolioId);
	}
	



}


		TestAccountSetupRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;

public class TestAccountSetupRepository implements AccountSetupRepository {
	
	public List<AccountSetup> accountSetupList = new ArrayList<>();
	public Map<String, AccountSetup> accountSetupMap = new HashMap<>();

	@Override
	public <S extends AccountSetup> S save(S accountSetup) {
		accountSetupList.add(accountSetup);

		return accountSetup;
	}


	@Override
	public List<AccountSetup> findAll() {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public List<AccountSetup> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public List<AccountSetup> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public <S extends AccountSetup> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public <S extends AccountSetup> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public void deleteInBatch(Iterable<AccountSetup> entities) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public AccountSetup getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Page<AccountSetup> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}


	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void delete(AccountSetup arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void delete(Iterable<? extends AccountSetup> arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}


	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}


	@Override
	public AccountSetup findOne(Long arg0) {
		return accountSetupMap.get(arg0.toString());
	}


	@Override
	public AccountSetup findByPortfolioIdIs(String portfolioId) {
		return accountSetupMap.get(portfolioId);
	}

}


		TestCommentaryRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Commentary;

public class TestCommentaryRepository implements CommentaryRepository{

	public Commentary testCommentaryEntity = new Commentary();
	
	@Override
	public List<Commentary> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Commentary> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Commentary> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Commentary> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends Commentary> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<Commentary> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Commentary getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<Commentary> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Commentary arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends Commentary> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Commentary findOne(Long arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Commentary> S save(S commentary) {
		this.testCommentaryEntity = commentary;
		
		return commentary;
	}
	

	@Override
	public Commentary findByAsOfDateAndPortId(Date asOfDate, String portfolioId) {
		return testCommentaryEntity;
	}

}

		TestPortfolioLimitRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;

public class TestPortfolioLimitRepository implements PortfolioLimitRepository {
	
	public Map<String, Limit> dataMap = new HashMap<String, Limit>();
	
	@Override
	public List<Limit> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Limit> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Limit> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Limit> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends Limit> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<Limit> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Limit getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<Limit> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Limit arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends Limit> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Limit findOne(Long arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends Limit> S save(S limit) {
		dataMap.put(limit.getLimitName(), limit);
		
		return limit;
	}

	@Override
	public Limit findOneById(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Limit findByPortfolioCodeAndLimitTypeCodeAndEffectiveBeginDate(String portfolioCode, String limitTypeCode,
			Date effectiveBeginDate) {
		// TODO Auto-generated method stub
		return null;
	}

}


			TestValuationReportRepository.java

package com.vanguard.corp.ics.sdt.dao.impl.repository;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;

public class TestValuationReportRepository implements ValuationsReportRepository {
	
	public Map<String, ValuationsReport> dataMap = new HashMap<String, ValuationsReport>();
	public ValuationsReport report = null;

	@Override
	public List<ValuationsReport> findAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<ValuationsReport> findAll(Sort sort) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<ValuationsReport> findAll(Iterable<Long> ids) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <S extends ValuationsReport> List<S> save(Iterable<S> entities) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void flush() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public <S extends ValuationsReport> S saveAndFlush(S entity) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void deleteInBatch(Iterable<ValuationsReport> entities) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAllInBatch() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ValuationsReport getOne(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Page<ValuationsReport> findAll(Pageable arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public long count() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void delete(Long arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(ValuationsReport arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void delete(Iterable<? extends ValuationsReport> arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void deleteAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean exists(Long arg0) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public ValuationsReport findOne(Long arg0) {
		return report;
	}

	@Override
	public <S extends ValuationsReport> S save(S valReport) {
		dataMap.put(valReport.getPortfolioCode() + valReport.getEffectiveDate().toString() + valReport.getSecurityTypeCode(), (ValuationsReport) valReport);
		
		return valReport;
		
	}

	@Override
	public ValuationsReport findOneById(Long id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ValuationsReport findByPortfolioCodeIsAndSecurityTypeCodeIsAndEffectiveDateIs(String portfolioCode,
			String securityTypeCode, Date effectiveDate) {
		return report;
	}

}

com.vanguard.corp.ics.sdt.service.api.constants
			AnalyticsTypeCodeTest.java

package com.vanguard.corp.ics.sdt.service.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class AnalyticsTypeCodeTest {

	@Test
	public void testEnumValues() {
		// Names
		assertEquals("Ex Ante- Tracking Error", AnalyticsTypeCode.EX_ANTE_RISK.getName());
		assertEquals("1 yr Ex-Post Tracking Error", AnalyticsTypeCode.ONE_YR_EX_POST.getName());
		assertEquals("3 yr Ex-Post Tracking Error", AnalyticsTypeCode.THREE_YR_EX_POST.getName());
		assertEquals("1 yr Standard Deviation", AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName());
		assertEquals("3 yr Standard Deviation", AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getName());
		
		// Codes
		assertEquals("EATE", AnalyticsTypeCode.EX_ANTE_RISK.getCode());
		assertEquals("1YEP", AnalyticsTypeCode.ONE_YR_EX_POST.getCode());
		assertEquals("3YEP", AnalyticsTypeCode.THREE_YR_EX_POST.getCode());
		assertEquals("1YSD", AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getCode());
		assertEquals("3YSD", AnalyticsTypeCode.THREE_YR_STANDARD_DEV.getCode());

		assertEquals(AnalyticsTypeCode.EX_ANTE_RISK, AnalyticsTypeCode.valueOf("EX_ANTE_RISK"));
	}
}

		SecurityTypeCodeTest.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.service.api.constants;

import static org.junit.Assert.*;

import org.junit.Test;

public class SecurityTypeCodeTest {

	@Test
	public void testEnumValues() {
		// Names
		assertEquals("Derivatives", SecurityTypeCode.DERIVATIVES.getName());
		assertEquals("Equity", SecurityTypeCode.EQUITY.getName());
		assertEquals("Futures", SecurityTypeCode.FUTURES.getName());
		assertEquals("Forward Forex", SecurityTypeCode.FORWARD_FOREX.getName());
		assertEquals("Liquidity", SecurityTypeCode.LIQUIDITY.getName());
		assertEquals("Securities", SecurityTypeCode.FIXED_INTEREST.getName());
		
		// Codes
		assertEquals("DERI", SecurityTypeCode.DERIVATIVES.getCode());
		assertEquals("EQUI", SecurityTypeCode.EQUITY.getCode());
		assertEquals("FUTU", SecurityTypeCode.FUTURES.getCode());
		assertEquals("FWFX", SecurityTypeCode.FORWARD_FOREX.getCode());
		assertEquals("LIQU", SecurityTypeCode.LIQUIDITY.getCode());
		assertEquals("SECU", SecurityTypeCode.FIXED_INTEREST.getCode());

		assertEquals(SecurityTypeCode.EQUITY, SecurityTypeCode.valueOf("EQUITY"));
	}
}

com.vanguard.corp.ics.sdt.service.api.util

		DateParserTest.java

package com.vanguard.corp.ics.sdt.service.api.util;

import org.junit.Test;


public class DateParserTest {

	private DateParser classUnderTest = new DateParser();

	@Test(expected=DateParser.DateParserException.class)
	public void testForCoverageBecauseLessThan100PercentIsBad() {
		classUnderTest.parse("ABCD");
	}

}


		UtilitiesTest.java

package com.vanguard.corp.ics.sdt.service.api.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;

import org.junit.Test;
import org.springframework.security.core.GrantedAuthority;

import com.vanguard.services.suds.entity.VGUser;
import com.vanguard.services.suds.entity.VGUserDetailsServiceRequest;


public class UtilitiesTest {

	private Utilities classUnderTest = new Utilities();

	private DateParser dateParser = new DateParser();

	@Test
	public void testGetPreviousMonthEnd() {
		Date date = dateParser.parse("2016-01-01");
		
		Date previousMonthEnd = classUnderTest.getPreviousMonthEnd(date);
		
		assertNotNull(previousMonthEnd);
		assertEquals(dateParser.parse("2015-12-31"), previousMonthEnd);
	}

	@Test
	public void testGenerateDateFromString() {
		Date generatedDate = classUnderTest.generateDateFromString("2016-01-01", "yyyy-MM-dd");
		
		assertEquals(dateParser.parse("2016-01-01"), generatedDate);
	}

	@Test
	public void testBadDateStringBecomesToday() {
		Date generatedDate = classUnderTest.generateDateFromString("blah blah blah", "yyyy-MM-dd");
		
		Calendar now = Calendar.getInstance();
		Calendar cal = Calendar.getInstance();
		cal.setTime(generatedDate);
		
		assertEquals(now.get(Calendar.YEAR), cal.get(Calendar.YEAR));
		assertEquals(now.get(Calendar.MONTH), cal.get(Calendar.MONTH));
		assertEquals(now.get(Calendar.DATE), cal.get(Calendar.DATE));
	}

	@Test
	public void testGetAuthenticatedUser() {
		classUnderTest.getAuthenticatedUser();
	}

	@Test
	public void testGetCurrentUserName() {
		Utilities util = new Utilities() {
			@Override
			protected VGUser getAuthenticatedUser() {
				Collection<? extends GrantedAuthority> authorities = new ArrayList<>();
				VGUserDetailsServiceRequest vGUserDetailsServiceRequest = new VGUserDetailsServiceRequest();
				return new VGUser("username", authorities, vGUserDetailsServiceRequest);
			}
		};
		
		String currentUsername = util.getCurrentUsername();
		assertEquals("username", currentUsername);
	}
}


com.vanguard.corp.ics.sdt.service.impl
		CommentaryServiceImplTest.java

package com.vanguard.corp.ics.sdt.service.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.impl.repository.TestCommentaryRepository;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;

public class CommentaryServiceImplTest {

	@InjectMocks
	CommentaryServiceImpl commentaryService = new CommentaryServiceImpl();

	@Spy
	TestCommentaryRepository testCommentaryRepository = new TestCommentaryRepository();

	private CommentaryDTO existingCommentary;
	private final DateParser dateParser = new DateParser();

	private static final String AS_OF_DATE = "2017-09-25";
	private static final String PORT_ID = "ONE88";
	private static final String COMMENTARY_TXT = "This is sample commentary";
	
	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);

		testCommentaryRepository.testCommentaryEntity.setEffectiveDate(dateParser.parse(AS_OF_DATE));
		testCommentaryRepository.testCommentaryEntity.setPortfolioId(PORT_ID);
		testCommentaryRepository.testCommentaryEntity.setCommentaryText(COMMENTARY_TXT);
		
		existingCommentary = new CommentaryDTO();

		existingCommentary.setAsOfDate(AS_OF_DATE);
		existingCommentary.setPortId(PORT_ID);
		existingCommentary.setCommentary(COMMENTARY_TXT);
	}

	@Test
	public void testGetCommentary() {

		CommentaryDTO commentary = commentaryService.getCommentary(PORT_ID, dateParser.parse(AS_OF_DATE));

		assertNotNull(commentary);
		assertEquals(dateParser.parse(AS_OF_DATE).toString(), commentary.getAsOfDate());
		assertEquals(PORT_ID, commentary.getPortId());
		assertEquals(COMMENTARY_TXT, commentary.getCommentary());
	}

	@Test
	public void testGetCommentaryIfFindReturnedNull() {
		when(testCommentaryRepository.findByAsOfDateAndPortId(dateParser.parse(AS_OF_DATE), PORT_ID)).thenReturn(null);
		
		CommentaryDTO commentary = commentaryService.getCommentary(PORT_ID, dateParser.parse(AS_OF_DATE));

		assertNull(commentary);
	}
	
	@Test
	public void testUpdateCommentary(){
		commentaryService.saveOrUpdateCommentary(existingCommentary);
		
		assertEquals(dateParser.parse(AS_OF_DATE), testCommentaryRepository.testCommentaryEntity.getEffectiveDate());
		assertEquals(PORT_ID, testCommentaryRepository.testCommentaryEntity.getPortfolioId());
		assertEquals(COMMENTARY_TXT, testCommentaryRepository.testCommentaryEntity.getCommentaryText());
	}
	
	
	

}

		ProductDataServiceImplTest.java

package com.vanguard.corp.ics.sdt.service.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountBenchmarkAssociation;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountFund;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.AccountSetup;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Limit;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;

public class ProductDataServiceImplTest {

	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();

	@InjectMocks
	private ProductDataServiceImpl productDataService;
	
	@Mock
	private Utilities utilities;
	
	private PortalProduct portalProduct1, portalProduct2, portalProduct3, portalProduct4, portalProduct6;

	private Currency currency1, currency2, currency3, currency4, currency6;

	private InvestmentGroup investmentGroup1, investmentGroup2, investmentGroup3, investmentGroup4, investmentGroup6;

	private List<PortalProduct> portalProducts, portalProducts2;

	public Map<String, Limit> dataMap = new HashMap<String, Limit>();
	
	private AccountFund existingAccountFund;
	private AccountSetup existingAccountSetup;
	private AccountBenchmarkAssociation existingAccountBenchmarkAssociation;
	
	private static final String PRODUCT_CODE = "ONE90";
	private static final String PRODUCT_CODE2 = "ONE91";
	private static final String PRODUCT_CODE3 = "CODE03";
	private static final String PRODUCT_CODE4 = "CODE04";
	private static final String PRODUCT_CODE5 = "CODE05";
	private static final String PRODUCT_CODE6 = "CODE06";
	private static final String PRODUCT_NAME = "OnePath Australian Listed Property Index Pool";
	private static final String PRODUCT_NAME2 = "OnePath Australian Bonds Index Pool";
	private static final String PRODUCT_NAME3 = "Product Three";
	private static final String PRODUCT_NAME4 = "Product Four";
	private static final String PRODUCT_NAME6 = "Product Six";
	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final Long INVSTMNT_GRP_ID2 = Long.valueOf(2);
	private static final Long INVSTMNT_GRP_ID3 = Long.valueOf(3);
	private static final Long INVSTMNT_GRP_ID4 = Long.valueOf(4);
	private static final Long INVSTMNT_GRP_ID6 = Long.valueOf(6);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String INVSTMNT_GRP_NAME2 = "Fixed Income Group";
	private static final String INVSTMNT_GRP_NAME3 = "Group Three";
	private static final String INVSTMNT_GRP_NAME4 = "Group Four";
	private static final String INVSTMNT_GRP_NAME6 = "Group Six";
	private static final String CURRENCY_CODE = "AUD";
	private static final String CURRENCY_CODE2 = "USD";
	private static final String CURRENCY_CODE3 = "DSD";
	private static final String CURRENCY_CODE4 = "DDT";
	private static final String CURRENCY_CODE6 = "XXX";
	private static final String CURRENCY_CODE_NOT_FOUND = "N/A";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String INVSTMNT_OBJ2 = "Investment Objective 2";
	private static final String INVSTMNT_OBJ3 = "Investment Objective 3";
	private static final String INVSTMNT_OBJ4 = "Investment Objective 4";
	private static final String INVSTMNT_OBJ6 = "Investment Objective 6";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final String CLIENT_ID = "ANZ OnePath";
	private static final String CLIENT_ID2 = "ANZ OnePath2";
	private static final String CLIENT_ID3 = "ANZ OnePath3";
	private static final String CLIENT_ID4 = "ANZ OnePath4";
	private static final String CLIENT_ID6 = "ANZ OnePath6";
	private static final String BENCHMARK_NAME = "test";
	private static final String BENCHMARK_NAME2 = "Bloomberg AusBond Composite 0+ Years Index";
	private static final String BENCHMARK_NAME3 = "Benchmark Three";
	private static final String BENCHMARK_NAME4 = "Benchmark Four";
	private static final String BENCHMARK_NAME6 = "Benchmark Six";
	
	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);

		portalProducts = new ArrayList<>();
		portalProducts2 = new ArrayList<>();
		
		portalProduct1 = new PortalProduct();
		portalProduct2 = new PortalProduct();
		portalProduct3 = new PortalProduct();
		portalProduct4 = new PortalProduct();
		portalProduct6 = new PortalProduct();

		currency1 = new Currency();
		currency2 = new Currency();
		currency3 = new Currency();
		currency4 = new Currency();
		currency6 = new Currency();

		investmentGroup1 = new InvestmentGroup();
		investmentGroup2 = new InvestmentGroup();
		investmentGroup3 = new InvestmentGroup();
		investmentGroup4 = new InvestmentGroup();
		investmentGroup6 = new InvestmentGroup();

		portalProduct1.setBaseCurrencyID(Long.valueOf(1));
		portalProduct1.setBenchMarkName(BENCHMARK_NAME);
		portalProduct1.setClientID(CLIENT_ID);
		portalProduct1.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct1.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct1.setProductCode(PRODUCT_CODE);
		portalProduct1.setProductName(PRODUCT_NAME);
		portalProduct1.setInvestmentObjective(INVSTMNT_OBJ);

		
		currency1.setCurrencyCode(CURRENCY_CODE);
		currency1.setCurrencyId(Long.valueOf(1));
		currency1.setCurrencyName("Australian Dollar123");

		investmentGroup1.setInvestmentGroupCode("EIG");
		investmentGroup1.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup1.setInvestmentGroupName(INVSTMNT_GRP_NAME);

		portalProduct1.setCurrency(currency1);
		portalProduct1.setInvestmentGroup(investmentGroup1);

		portalProducts.add(portalProduct1);
		
		portalProduct2.setBaseCurrencyID(Long.valueOf(2));
		portalProduct2.setBenchMarkName(BENCHMARK_NAME2);
		portalProduct2.setClientID(CLIENT_ID2);
		portalProduct2.setInvestmentGroupID(INVSTMNT_GRP_ID2);
		portalProduct2.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct2.setProductCode(PRODUCT_CODE2);
		portalProduct2.setProductName(PRODUCT_NAME2);
		portalProduct2.setInvestmentObjective(INVSTMNT_OBJ2);

		currency2.setCurrencyCode(CURRENCY_CODE2);
		currency2.setCurrencyId(Long.valueOf(2));
		currency2.setCurrencyName("Australian Dollar123");

		investmentGroup2.setInvestmentGroupCode("FIG");
		investmentGroup2.setInvestmentGroupId(Long.valueOf(2));
		investmentGroup2.setInvestmentGroupName(INVSTMNT_GRP_NAME2);

		portalProduct2.setCurrency(currency2);
		portalProduct2.setInvestmentGroup(investmentGroup2);

		portalProducts.add(portalProduct2);
		
		portalProduct3.setBaseCurrencyID(Long.valueOf(3));
		portalProduct3.setBenchMarkName(BENCHMARK_NAME3);
		portalProduct3.setClientID(CLIENT_ID3);
		portalProduct3.setInvestmentGroupID(INVSTMNT_GRP_ID3);
		portalProduct3.setPerfInceptionDate("");
		portalProduct3.setProductCode(PRODUCT_CODE3);
		portalProduct3.setProductName(PRODUCT_NAME3);
		portalProduct3.setInvestmentObjective(INVSTMNT_OBJ3);
		
		currency3.setCurrencyCode(CURRENCY_CODE3);
		currency3.setCurrencyId(Long.valueOf(4));
		currency3.setCurrencyName("Australian Dollar333");
		
		investmentGroup3.setInvestmentGroupCode("GIG");
		investmentGroup3.setInvestmentGroupId(Long.valueOf(3));
		investmentGroup3.setInvestmentGroupName(INVSTMNT_GRP_NAME3);
		
		portalProduct3.setCurrency(currency3);
		portalProduct3.setInvestmentGroup(investmentGroup3);
		
		portalProducts.add(portalProduct3);
		
		portalProduct4.setBaseCurrencyID(Long.valueOf(4));
		portalProduct4.setBenchMarkName(BENCHMARK_NAME4);
		portalProduct4.setClientID(CLIENT_ID4);
		portalProduct4.setInvestmentGroupID(INVSTMNT_GRP_ID4);
		portalProduct4.setPerfInceptionDate(null);
		portalProduct4.setProductCode(PRODUCT_CODE4);
		portalProduct4.setProductName(PRODUCT_NAME4);
		portalProduct4.setInvestmentObjective(INVSTMNT_OBJ4);
		
		currency4.setCurrencyCode(CURRENCY_CODE4);
		currency4.setCurrencyId(Long.valueOf(4));
		currency4.setCurrencyName("Australian Dollar444");
		
		investmentGroup4.setInvestmentGroupCode("HIG");
		investmentGroup4.setInvestmentGroupId(Long.valueOf(4));
		investmentGroup4.setInvestmentGroupName(INVSTMNT_GRP_NAME4);
		
		portalProduct4.setCurrency(currency4);
		portalProduct4.setInvestmentGroup(investmentGroup4);
		
		portalProducts.add(portalProduct4);
		
		portalProduct6.setBaseCurrencyID(Long.valueOf(1));
		portalProduct6.setBenchMarkName(BENCHMARK_NAME6);
		portalProduct6.setClientID(CLIENT_ID6);
		portalProduct6.setInvestmentGroupID(INVSTMNT_GRP_ID6);
		portalProduct6.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct6.setProductCode(PRODUCT_CODE6);
		portalProduct6.setProductName(PRODUCT_NAME6);
		portalProduct6.setInvestmentObjective(INVSTMNT_OBJ6);
		
		currency6.setCurrencyCode(CURRENCY_CODE6);
		currency6.setCurrencyId(Long.valueOf(6));
		currency6.setCurrencyName("Australian Dollar666");
		
		investmentGroup6.setInvestmentGroupCode("IIG");
		investmentGroup6.setInvestmentGroupId(Long.valueOf(6));
		investmentGroup6.setInvestmentGroupName(INVSTMNT_GRP_NAME6);
		
		portalProduct6.setCurrency(currency6);
		portalProduct6.setInvestmentGroup(investmentGroup6);
		
		portalProducts2.add(portalProduct6);
		
		
		when(utilities.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(utilities.generateDateFromString(portalProduct1.getPerfInceptionDate(), RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT)).thenReturn(PERF_INCEPT_DATE);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE)).thenReturn(this.portalProduct1);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE2)).thenReturn(this.portalProduct2);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE3)).thenReturn(this.portalProduct3);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE4)).thenReturn(this.portalProduct4);
		when(productPortalService.getProductCurrency(portalProduct1, request)).thenReturn(currency1);
		when(productPortalService.getInvestmentGroup(portalProduct1, request)).thenReturn(investmentGroup1);
		when(productPortalService.getProductCurrency(portalProduct2, request)).thenReturn(currency2);
		when(productPortalService.getInvestmentGroup(portalProduct2, request)).thenReturn(investmentGroup2);
		when(productPortalService.getProductCurrency(portalProduct3, request)).thenReturn(currency3);
		when(productPortalService.getInvestmentGroup(portalProduct3, request)).thenReturn(investmentGroup3);
		when(productPortalService.getProductCurrency(portalProduct4, request)).thenReturn(currency4);
		when(productPortalService.getInvestmentGroup(portalProduct4, request)).thenReturn(investmentGroup4);
		
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE5)).thenReturn(null);
		when(productPortalService.getProduct(portalProducts2, PRODUCT_CODE6)).thenReturn(portalProduct6);
		when(productPortalService.getProductCurrency(portalProduct6, request)).thenReturn(currency6);
		when(productPortalService.getInvestmentGroup(portalProduct6, request)).thenReturn(investmentGroup6);
		
		existingAccountFund = new AccountFund();
		existingAccountFund.setId(987654321L);
		existingAccountFund.setPortfolioId(PRODUCT_CODE6);
		existingAccountFund.setAccountName("old account name");
		existingAccountFund.setPortfolioManagerId(123L);
		existingAccountFund.setPortfolioManager("old portfolio manager");
		existingAccountFund.setPortfolioBaseCurrency("old base currency");
		existingAccountFund.setInvestmentObjective("old objective");
		existingAccountFund.setUpdatedUser("old user");
		existingAccountFund.setAccountType("old account type");
		existingAccountFund.setAssetClassificationId(0L);
		existingAccountFund.setProductEipID(999L);
		
		existingAccountSetup = new AccountSetup();
		existingAccountSetup.setId(345698345L);
		existingAccountSetup.setPortfolioId(PRODUCT_CODE6);
		existingAccountSetup.setAccountClientName("old client name");
		existingAccountSetup.setUpdatedUser("old user");
		existingAccountSetup.setStatusCode("old status code");
		
		existingAccountBenchmarkAssociation = new AccountBenchmarkAssociation();
		existingAccountBenchmarkAssociation.setId(1234876541L);
		existingAccountBenchmarkAssociation.setPortfolioId(PRODUCT_CODE6);
		existingAccountBenchmarkAssociation.setBenchmarkName("old benchmark name");
		existingAccountBenchmarkAssociation.setUpdatedUser("old user");
		
		testAccountFundRepository.accountFundMap.put(PRODUCT_CODE6, existingAccountFund);
		testAccountFundRepository.accountFundMap.put(existingAccountFund.getId().toString(), existingAccountFund);
		testAccountSetupRepository.accountSetupMap.put(PRODUCT_CODE6, existingAccountSetup);
		testAccountSetupRepository.accountSetupMap.put(existingAccountSetup.getId().toString(), existingAccountSetup);
		testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationMap.put(PRODUCT_CODE6, existingAccountBenchmarkAssociation);
		testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationMap.put(existingAccountBenchmarkAssociation.getId().toString(), existingAccountBenchmarkAssociation);
	}

	@Test
	public void valuationsServiceHasHighestPriority() {
		assertEquals(TransferService.Priority.HIGHEST, productDataService.getPriority());
	}

	@Test
	public void serviceWantsToHandleValuationsDataSetTypeRequests() {
		assertTrue(productDataService.handles(null, null, DataSetType.PRODUCT_DATA, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(productDataService.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(productDataService.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	@Test
	public void testMoveProductPortalDataToReport() {
		
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		productDataService.transfer(null, "ONE90", request);
		
		assertEquals(PRODUCT_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioId());
		
		assertEquals(PRODUCT_NAME, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(INVSTMNT_GRP_ID, testAccountFundRepository.accountFunds.get(0).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME, testAccountFundRepository.accountFunds.get(0).getPortfolioManager());
		assertEquals(CURRENCY_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(0).getInceptionDate());
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(0).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE, testAccountSetupRepository.accountSetupList.get(0).getPortfolioId());
		assertEquals(CLIENT_ID, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(0).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getPortfolioId());
		assertEquals(BENCHMARK_NAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getUpdatedUser());
	}

	

	@Test
	public void testMoveAllProductPortalDataToReport() {
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		productDataService.transfer(null, null, request);
			
		assertEquals(PRODUCT_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioId());	
		assertEquals(PRODUCT_NAME, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(INVSTMNT_GRP_ID, testAccountFundRepository.accountFunds.get(0).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME, testAccountFundRepository.accountFunds.get(0).getPortfolioManager());
		assertEquals(CURRENCY_CODE, testAccountFundRepository.accountFunds.get(0).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(0).getInceptionDate());
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(0).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE, testAccountSetupRepository.accountSetupList.get(0).getPortfolioId());
		assertEquals(CLIENT_ID, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(0).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getPortfolioId());
		assertEquals(BENCHMARK_NAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(0).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE2, testAccountFundRepository.accountFunds.get(1).getPortfolioId());
		assertEquals(PRODUCT_NAME2, testAccountFundRepository.accountFunds.get(1).getAccountName());
		assertEquals(INVSTMNT_GRP_ID2, testAccountFundRepository.accountFunds.get(1).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME2, testAccountFundRepository.accountFunds.get(1).getPortfolioManager());
		assertEquals(CURRENCY_CODE2, testAccountFundRepository.accountFunds.get(1).getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, testAccountFundRepository.accountFunds.get(1).getInceptionDate());
		assertEquals(INVSTMNT_OBJ2, testAccountFundRepository.accountFunds.get(1).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(1).getUpdatedUser());
		
		assertEquals(PRODUCT_CODE2, testAccountSetupRepository.accountSetupList.get(1).getPortfolioId());
		assertEquals(CLIENT_ID2, testAccountSetupRepository.accountSetupList.get(1).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(1).getUpdatedUser());
		
		assertEquals(PRODUCT_CODE2, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(1).getPortfolioId());
		assertEquals(BENCHMARK_NAME2, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(1).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(1).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE3, testAccountFundRepository.accountFunds.get(2).getPortfolioId());
		assertEquals(PRODUCT_NAME3, testAccountFundRepository.accountFunds.get(2).getAccountName());
		assertEquals(INVSTMNT_GRP_ID3, testAccountFundRepository.accountFunds.get(2).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME3, testAccountFundRepository.accountFunds.get(2).getPortfolioManager());
		assertEquals(CURRENCY_CODE3, testAccountFundRepository.accountFunds.get(2).getPortfolioBaseCurrency());
		SimpleDateFormat formatter = new SimpleDateFormat("yyy-MM-dd");
		assertEquals(formatter.format(new Date()), formatter.format(testAccountFundRepository.accountFunds.get(2).getInceptionDate()));
		assertEquals(INVSTMNT_OBJ3, testAccountFundRepository.accountFunds.get(2).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(2).getUpdatedUser());
		
		assertEquals(PRODUCT_CODE3, testAccountSetupRepository.accountSetupList.get(2).getPortfolioId());
		assertEquals(CLIENT_ID3, testAccountSetupRepository.accountSetupList.get(2).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(2).getUpdatedUser());
		
		assertEquals(PRODUCT_CODE3, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(2).getPortfolioId());
		assertEquals(BENCHMARK_NAME3, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(2).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(2).getUpdatedUser());
		
		
		assertEquals(PRODUCT_CODE4, testAccountFundRepository.accountFunds.get(3).getPortfolioId());
		assertEquals(PRODUCT_NAME4, testAccountFundRepository.accountFunds.get(3).getAccountName());
		assertEquals(INVSTMNT_GRP_ID4, testAccountFundRepository.accountFunds.get(3).getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME4, testAccountFundRepository.accountFunds.get(3).getPortfolioManager());
		assertEquals(CURRENCY_CODE_NOT_FOUND, testAccountFundRepository.accountFunds.get(3).getPortfolioBaseCurrency());
		assertEquals(formatter.format(new Date()), formatter.format(testAccountFundRepository.accountFunds.get(3).getInceptionDate()));
		assertEquals(INVSTMNT_OBJ4, testAccountFundRepository.accountFunds.get(3).getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, testAccountFundRepository.accountFunds.get(3).getUpdatedUser());
		
		assertEquals(PRODUCT_CODE4, testAccountSetupRepository.accountSetupList.get(3).getPortfolioId());
		assertEquals(CLIENT_ID4, testAccountSetupRepository.accountSetupList.get(3).getAccountClientName());
		assertEquals(CURRENT_USERNAME, testAccountSetupRepository.accountSetupList.get(3).getUpdatedUser());
		
		assertEquals(PRODUCT_CODE4, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(3).getPortfolioId());
		assertEquals(BENCHMARK_NAME4, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(3).getBenchmarkName());
		assertEquals(CURRENT_USERNAME, testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(3).getUpdatedUser());
	}

	@Test
	public void serviceSavesNothingIfNoDataInProductPortal() {
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		productDataService.transfer(null, PRODUCT_CODE5, request);
		
		assertTrue(testAccountFundRepository.accountFunds.isEmpty());
		assertTrue(testAccountSetupRepository.accountSetupList.isEmpty());
		assertTrue(testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.isEmpty());
	}

	@Test
	public void serviceUpdatesExistingValuesRatherThanLogicalDeleteAndInsertNewRows() {
		assertEquals("old account name", existingAccountFund.getAccountName());
		assertEquals(Long.valueOf(123L), existingAccountFund.getPortfolioManagerId());
		assertEquals("old portfolio manager", existingAccountFund.getPortfolioManager());
		assertEquals("old base currency", existingAccountFund.getPortfolioBaseCurrency());
		assertEquals("old objective", existingAccountFund.getInvestmentObjective());
		assertEquals("old user", existingAccountFund.getUpdatedUser());
		assertEquals("old account type", existingAccountFund.getAccountType());
		assertEquals(Long.valueOf(0L), existingAccountFund.getAssetClassificationId());
		assertEquals(999, existingAccountFund.getProductEipID(), 0);
		
		assertEquals("old client name", existingAccountSetup.getAccountClientName());
		assertEquals("old user", existingAccountSetup.getUpdatedUser());
		assertEquals("old status code", existingAccountSetup.getStatusCode());
		
		assertEquals("old benchmark name", existingAccountBenchmarkAssociation.getBenchmarkName());
		assertEquals("old user", existingAccountBenchmarkAssociation.getUpdatedUser());
		
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts2);
		productDataService.transfer(null, PRODUCT_CODE6, request);
		
		assertEquals(PRODUCT_CODE6, existingAccountFund.getPortfolioId());
		assertEquals(PRODUCT_NAME6, existingAccountFund.getAccountName());
		assertEquals(INVSTMNT_GRP_ID6, existingAccountFund.getPortfolioManagerId());
		assertEquals(INVSTMNT_GRP_NAME6, existingAccountFund.getPortfolioManager());
		assertEquals(CURRENCY_CODE6, existingAccountFund.getPortfolioBaseCurrency());
		assertEquals(PERF_INCEPT_DATE, existingAccountFund.getInceptionDate());
		assertEquals(INVSTMNT_OBJ6, existingAccountFund.getInvestmentObjective());
		assertEquals(CURRENT_USERNAME, existingAccountFund.getUpdatedUser());
		assertEquals("TEST", existingAccountFund.getAccountType());
		assertEquals(Long.valueOf(3L), existingAccountFund.getAssetClassificationId());
		assertEquals(0, existingAccountFund.getProductEipID(), 0);
		
		assertEquals(PRODUCT_CODE6, existingAccountSetup.getPortfolioId());
		assertEquals(CLIENT_ID6, existingAccountSetup.getAccountClientName());
		assertEquals(CURRENT_USERNAME, existingAccountSetup.getUpdatedUser());
		assertEquals("ACTIVE", existingAccountSetup.getStatusCode());
		
		assertEquals(PRODUCT_CODE6, existingAccountBenchmarkAssociation.getPortfolioId());
		assertEquals(BENCHMARK_NAME6, existingAccountBenchmarkAssociation.getBenchmarkName());
		assertEquals(CURRENT_USERNAME, existingAccountBenchmarkAssociation.getUpdatedUser());
	}
}


			ValuationsServiceImplTest.java

package com.vanguard.corp.ics.sdt.service.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.Mockito.*;

import com.vanguard.corp.ics.dao.target.ValuationsTargetDAO;
import com.vanguard.corp.ics.repository.target.ValuationsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.ValuationsReport;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestValuationReportRepository;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.service.api.constants.SecurityTypeCode;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ValuationsServiceImpl;

@RunWith(MockitoJUnitRunner.class)
public class ValuationsServiceImplTest {
	@Spy
	TestValuationReportRepository valReportRepo = new TestValuationReportRepository();
	
	@InjectMocks
	ValuationsServiceImpl valService = new ValuationsServiceImpl();
	
	@Mock
	ValuationsRepository valuationsTargetRepository;
	
	@Mock
	Utilities utilities;
	
	ValuationsTargetDAO valTargetRecord;
	ValuationsTargetDAO priorMonthTargetRecord;
	List<ValuationsTargetDAO> TargetRecords = new ArrayList<>();
	Date valuationDate;
	SimpleDateFormat df = new SimpleDateFormat("dd-MMM-yy");

	
	private static final Long id = Long.valueOf(1);
	private static final Long id2 = Long.valueOf(2);
	private static final String portCode = "Test Port Code";
	private static final String currencyCode = "USD";
	private static final Double equityValue = 100.0;
	private static final Double futuresValue = 200.0;
	private static final Double fixedInterestValue = 300.0;
	private static final Double ffxValue = 400.0;
	private static final Double liquidityValue = 500.0;
	private static final Double derivitivesValue = 600.0;
	private static final Double totalValue = 2100.0;
	private static final String createdUser = "UBUG";
	private static final String updatedUser = "UBUG";
	
	
	@Before
	public void init() throws ParseException {
		MockitoAnnotations.initMocks(this);
		
		
		valTargetRecord = new ValuationsTargetDAO();
		valTargetRecord.setId(id);
		valTargetRecord.setValueDate(df.parse("31-jul-17"));
		valTargetRecord.setPortfolioCode(portCode);
		valTargetRecord.setCurrencyCode(currencyCode);
		valTargetRecord.setEquityValue(equityValue);
		valTargetRecord.setFuturesValue(futuresValue);
		valTargetRecord.setFixedInterestValue(fixedInterestValue);
		valTargetRecord.setForwardForiegnExchangeValue(ffxValue);
		valTargetRecord.setLiquidityValue(liquidityValue);
		valTargetRecord.setDerivitivesValue(derivitivesValue);
		valTargetRecord.setTotalValue(totalValue);
		valTargetRecord.setCreatedUser(createdUser);
		valTargetRecord.setCreatedDate(df.parse("4-jul-17"));
		valTargetRecord.setUpdatedUser(updatedUser);
		valTargetRecord.setUpdatedDate(df.parse("17-jul-17"));
		
		priorMonthTargetRecord = new ValuationsTargetDAO();
		priorMonthTargetRecord.setId(id2);
		priorMonthTargetRecord.setValueDate(df.parse("30-jun-17"));
		priorMonthTargetRecord.setPortfolioCode(portCode);
		priorMonthTargetRecord.setCurrencyCode(currencyCode);
		priorMonthTargetRecord.setEquityValue(equityValue);
		priorMonthTargetRecord.setFuturesValue(futuresValue);
		priorMonthTargetRecord.setFixedInterestValue(fixedInterestValue);
		priorMonthTargetRecord.setForwardForiegnExchangeValue(ffxValue);
		priorMonthTargetRecord.setLiquidityValue(liquidityValue);
		priorMonthTargetRecord.setDerivitivesValue(derivitivesValue);
		priorMonthTargetRecord.setTotalValue(totalValue);
		priorMonthTargetRecord.setCreatedUser(createdUser);
		priorMonthTargetRecord.setCreatedDate(df.parse("21-jun-17"));
		priorMonthTargetRecord.setUpdatedUser(updatedUser);
		priorMonthTargetRecord.setUpdatedDate(df.parse("25-jun-17"));
		
		TargetRecords.add(valTargetRecord);
		TargetRecords.add(priorMonthTargetRecord);
		List<String> portCodes = new ArrayList<>();
		portCodes.add(portCode);
		
		when(utilities.getPreviousMonthEnd(df.parse("31-jul-17"))).thenReturn(df.parse("30-jun-17"));
		when(utilities.getCurrentUsername()).thenReturn("UBUG");
		when(valuationsTargetRepository.findPortIdByDate(valTargetRecord.getValueDate())).thenReturn(portCodes);
	}

	@Test
	public void valuationsServiceHasMediumPriority() {
		assertEquals(TransferService.Priority.MEDIUM, valService.getPriority());
	}

	@Test
	public void serviceWantsToHandleValuationsDataSetTypeRequests() {
		assertTrue(valService.handles(null, null, DataSetType.VALUATIONS, null));
	}

	@Test
	public void serviceWantsToHandleNullDataSetTypeRequests() {
		assertTrue(valService.handles(null, null, null, null));
	}

	@Test
	public void serviceDoesNotWantToHandleOtherDataSetTypeRequests() {
		assertFalse(valService.handles(null, null, DataSetType.CHARACTERISTICS, null));
	}

	//TODO uncomment this test if asOfDate cannot be null, else remove it
//	@Test(expected=IllegalArgumentException.class)
//	public void handlerThrowsExceptionIfAsOfDateIsNull() {
//		classUnderTest.transfer(null, null, null);
//	}
	
	@Test
	public void moveValuationsFromTargetToReportTest() throws ParseException{
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(priorMonthTargetRecord.getValueDate(), portCode)).thenReturn(priorMonthTargetRecord);
		valService.transfer(valTargetRecord.getValueDate(), "Test Port Code", null);
		
		
		for (SecurityTypeCode value : SecurityTypeCode.values()){
		
			ValuationsReport valReportRecord = valReportRepo.dataMap.get(valTargetRecord.getPortfolioCode() + valTargetRecord.getValueDate().toString() + value.getCode());
			ValuationsReport priorMonthValReportRecord = valReportRepo.dataMap.get(priorMonthTargetRecord.getPortfolioCode() + priorMonthTargetRecord.getValueDate().toString() + value.getCode());
			
			switch(value){
				case DERIVATIVES :
					assertEquals(valTargetRecord.getDerivitivesValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getDerivitivesValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case EQUITY : 
					assertEquals(valTargetRecord.getEquityValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getEquityValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case FUTURES : 
					assertEquals(valTargetRecord.getFuturesValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getFuturesValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case FIXED_INTEREST :
					assertEquals(valTargetRecord.getFixedInterestValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getFixedInterestValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case FORWARD_FOREX :
					assertEquals(valTargetRecord.getForwardForiegnExchangeValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getForwardForiegnExchangeValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case LIQUIDITY : 
					assertEquals(valTargetRecord.getLiquidityValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getLiquidityValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
			}
			
			assertEquals(portCode, valReportRecord.getPortfolioCode());
			assertEquals(valTargetRecord.getValueDate(), valReportRecord.getEffectiveDate());
			assertNotNull(valReportRecord.getRunTimestamp());
			assertEquals(totalValue, valReportRecord.getTotalValue(), 0);
			assertEquals(createdUser, valReportRecord.getCreatedUser());
			assertEquals(valTargetRecord.getCreatedDate(), valReportRecord.getCreatedDate());
			assertEquals(updatedUser, valReportRecord.getUpdatedUser());
			assertNotNull(valReportRecord.getPortfolioValuationTypeCode());
			
			assertEquals(portCode, priorMonthValReportRecord.getPortfolioCode());
			assertEquals(priorMonthTargetRecord.getValueDate(), priorMonthValReportRecord.getEffectiveDate());
			assertNotNull(priorMonthValReportRecord.getRunTimestamp());
			assertNotNull(priorMonthValReportRecord.getSecurityTypeCode());
			assertNotNull(priorMonthValReportRecord.getValuationValue());
			assertEquals(totalValue, priorMonthValReportRecord.getTotalValue(), 0);
			assertEquals(createdUser, priorMonthValReportRecord.getCreatedUser());
			assertEquals(priorMonthTargetRecord.getCreatedDate(), priorMonthValReportRecord.getCreatedDate());
			assertEquals(updatedUser, priorMonthValReportRecord.getUpdatedUser());
			assertNotNull(priorMonthValReportRecord.getPortfolioValuationTypeCode());
		}
		

	}
	
	@Test
	public void moveAllValuationsFromTargetToReportTest() throws ParseException{
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(priorMonthTargetRecord.getValueDate(), portCode)).thenReturn(priorMonthTargetRecord);
		valService.transfer(valTargetRecord.getValueDate(), null, null);
		
		
		for (SecurityTypeCode value : SecurityTypeCode.values()){
		
			ValuationsReport valReportRecord = valReportRepo.dataMap.get(valTargetRecord.getPortfolioCode() + valTargetRecord.getValueDate().toString() + value.getCode());
			ValuationsReport priorMonthValReportRecord = valReportRepo.dataMap.get(priorMonthTargetRecord.getPortfolioCode() + priorMonthTargetRecord.getValueDate().toString() + value.getCode());
			
			switch(value){
				case DERIVATIVES :
					assertEquals(valTargetRecord.getDerivitivesValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getDerivitivesValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case EQUITY : 
					assertEquals(valTargetRecord.getEquityValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getEquityValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case FUTURES : 
					assertEquals(valTargetRecord.getFuturesValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getFuturesValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case FIXED_INTEREST :
					assertEquals(valTargetRecord.getFixedInterestValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getFixedInterestValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case FORWARD_FOREX :
					assertEquals(valTargetRecord.getForwardForiegnExchangeValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getForwardForiegnExchangeValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
				case LIQUIDITY : 
					assertEquals(valTargetRecord.getLiquidityValue(), valReportRecord.getValuationValue(), 0);
					assertEquals(priorMonthTargetRecord.getLiquidityValue(), priorMonthValReportRecord.getValuationValue(), 0);
					
					break;
			}
			
			assertEquals(portCode, valReportRecord.getPortfolioCode());
			assertEquals(valTargetRecord.getValueDate(), valReportRecord.getEffectiveDate());
			assertNotNull(valReportRecord.getRunTimestamp());
			assertEquals(totalValue, valReportRecord.getTotalValue(), 0);
			assertEquals(createdUser, valReportRecord.getCreatedUser());
			assertEquals(valTargetRecord.getCreatedDate(), valReportRecord.getCreatedDate());
			assertEquals(updatedUser, valReportRecord.getUpdatedUser());
			assertNotNull(valReportRecord.getPortfolioValuationTypeCode());
			
			assertEquals(portCode, priorMonthValReportRecord.getPortfolioCode());
			assertEquals(priorMonthTargetRecord.getValueDate(), priorMonthValReportRecord.getEffectiveDate());
			assertNotNull(priorMonthValReportRecord.getRunTimestamp());
			assertNotNull(priorMonthValReportRecord.getSecurityTypeCode());
			assertNotNull(priorMonthValReportRecord.getValuationValue());
			assertEquals(totalValue, priorMonthValReportRecord.getTotalValue(), 0);
			assertEquals(createdUser, priorMonthValReportRecord.getCreatedUser());
			assertEquals(priorMonthTargetRecord.getCreatedDate(), priorMonthValReportRecord.getCreatedDate());
			assertEquals(updatedUser, priorMonthValReportRecord.getUpdatedUser());
			assertNotNull(priorMonthValReportRecord.getPortfolioValuationTypeCode());
		}
		

	}
	
	@Test
	public void getValuationTargetRecordTest(){
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		ValuationsTargetDAO testTargetRecord = valService.getValuationTargetRecord(portCode, valTargetRecord.getValueDate());
		
		assertEquals(valTargetRecord.getPortfolioCode(), testTargetRecord.getPortfolioCode());
		assertEquals(valTargetRecord.getValueDate(), testTargetRecord.getValueDate());
		assertEquals(valTargetRecord.getCurrencyCode(), testTargetRecord.getCurrencyCode());
		assertEquals(valTargetRecord.getEquityValue(), testTargetRecord.getEquityValue());
		assertEquals(valTargetRecord.getFuturesValue(), testTargetRecord.getFuturesValue());
		assertEquals(valTargetRecord.getFixedInterestValue(), testTargetRecord.getFixedInterestValue());
		assertEquals(valTargetRecord.getForwardForiegnExchangeValue(), testTargetRecord.getForwardForiegnExchangeValue());
		assertEquals(valTargetRecord.getDerivitivesValue(), testTargetRecord.getDerivitivesValue());
		assertEquals(valTargetRecord.getLiquidityValue(), testTargetRecord.getLiquidityValue());
		assertEquals(valTargetRecord.getTotalValue(), testTargetRecord.getTotalValue());
		assertEquals(valTargetRecord.getCreatedUser(), testTargetRecord.getCreatedUser());
		assertEquals(valTargetRecord.getCreatedDate(), testTargetRecord.getCreatedDate());
		assertEquals(valTargetRecord.getUpdatedUser(), testTargetRecord.getUpdatedUser());
		assertEquals(valTargetRecord.getUpdatedDate(), testTargetRecord.getUpdatedDate());
	}
	
	@Test
	public void serviceUpdatesExistingRecordsRatherThanLogicallyDeletingAndAddingNewRows() {
		Long reportId = 12345L;
		ValuationsReport report = new ValuationsReport();
		report.setId(reportId);
		report.setValuationValue(99999.0);
		
		valReportRepo.report = report;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(valTargetRecord);
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(priorMonthTargetRecord.getValueDate(), portCode)).thenReturn(priorMonthTargetRecord);
		
		assertEquals(99999, report.getValuationValue(), 0);
		valService.transfer(valTargetRecord.getValueDate(), "Test Port Code", null);
		assertNotEquals(99999, report.getValuationValue(), 0);
	}

	@Test
	public void serviceSavesNothingIfNoDataInTargetRepository() {
		valReportRepo.report = null;
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetRecord.getValueDate(), portCode)).thenReturn(null);
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(priorMonthTargetRecord.getValueDate(), portCode)).thenReturn(null);

		valService.transfer(valTargetRecord.getValueDate(), "Test Port Code", null);
		
		assertEquals(0, valReportRepo.dataMap.size());
	}
}

com.vanguard.corp.ics.sdt.service.impl.characteristics
		CharacteristicsRepoWrapperTest.java

package com.vanguard.corp.ics.sdt.service.impl.characteristics;

import static org.junit.Assert.*;

import org.junit.Test;

import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRepoWrapper.DeleteCombo;


public class CharacteristicsRepoWrapperTest {

	@Test
	public void testSillyPermutationsOfDeleteComboEqualsForCoverage() {
		
		DeleteCombo combo1 = new DeleteCombo("ABC", "123");
		DeleteCombo combo2 = new DeleteCombo("ABC", "123");
		DeleteCombo combo3 = new DeleteCombo("ABC", "124");
		DeleteCombo combo4 = new DeleteCombo("ABD", "123");
		
		assertTrue(combo1.equals(combo1));
		assertTrue(combo1.equals(combo2));
		assertFalse(combo1.equals(combo3));
		assertFalse(combo1.equals(combo4));
		assertFalse(combo1.equals(null));
		assertFalse(combo1.equals(new Object()));
	}

}

com.vanguard.corp.ics.sdt.test.characteristics
		CharacteristicsConverterGetter.java

package com.vanguard.corp.ics.sdt.test.characteristics;

import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;

public interface CharacteristicsConverterGetter {

	public CharacteristicsConverter getConverter();
}

		DataTransferServiceApplicationTester.java


package com.vanguard.corp.ics.sdt.test.characteristics;

import static org.mockito.Mockito.mock;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

public class DataTransferServiceApplicationTester extends JerseyTest {

	private DataTransferService mockService;

	public DataTransferService getMockService() {
		return mockService;
	}

	@Override
	protected Application configure() {

		forceSet(TestProperties.CONTAINER_PORT, "0");

		ApplicationContext context = new AnnotationConfigApplicationContext(DataTransferServiceApplicationTester.BeanConfig.class);
		mockService = context.getBean(DataTransferService.class);

		return new ResourceConfig().register(DataTransferResource.class).property("contextConfig", context);
	}

	@Configuration
	public static class BeanConfig {

		@Bean
		public DataTransferService dataTransferService() {
			return mock(DataTransferService.class);
		}
	}
}

		PortfolioCharacteristicsType.java
/*
 ****************************************************************************
 *
 * Copyright (c)2017 The Vanguard Group of Investment Companies (VGI)
 * All rights reserved.
 *
 * This source code is CONFIDENTIAL and PROPRIETARY to VGI. Unauthorized
 * distribution, adaptation, or use may be subject to civil and criminal
 * penalties.
 *
 ****************************************************************************
 Module Description:

 $HeadURL:$
 $LastChangedRevision:$
 $Author:$
 $LastChangedDate:$
*/
package com.vanguard.corp.ics.sdt.test.characteristics;


public enum PortfolioCharacteristicsType {

	NUMBER_OF_SECURITIES	("Number of Securities")
	, MARKET_CAPITALIZATION	("Market Capitalization")
	, MIN_MARKET_CAP		("Minimum Market Capitalization")
	, MAX_MARKET_CAP		("Maximum Market Capitalization")
	, DIVIDEND_YIELD		("Dividend Yield")
	, PRICE_PER_EARNINGS	("Price/Earnings")
	, PPE_USING_FY1_EST		("P/E using FY1 Est")
	, PRICE_PER_CASH_FLOW	("Price/Cash Flow")
	, PRICE_PER_BOOK		("Price/Book")
	, PRICE_PER_SALES		("Price/Sales")
	, ROE					("ROE")
	, EARNINGS_GROWTH_RATE	("Earnings Growth Rate")
	, TURNOVER_1_MON		("Turnover - 1 Month")
	, TURNOVER_3_MON		("Turnover - 3 Months")
	, TURNOVER_12_MON		("Turnover - 12 Months")
	;

	private final String label;

	private PortfolioCharacteristicsType(final String label) {
		this.label = label;
	}

	public String getLabel() {
		return this.label;
	}
}

		TestCharacteristicsType.java

package com.vanguard.corp.ics.sdt.test.characteristics;

import java.util.HashMap;
import java.util.Map;

import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CountryAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CurrencyAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.MarketSegmentationByCapAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.PortfolioCharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.RegionalAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.SectorAllocationConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.TopTenHoldingsCharacteristicsConverter;

public enum TestCharacteristicsType implements CharacteristicsConverterGetter {

	PORTFOLIO_CHARACTERISTICS	(CharacteristicsType.PORTFOLIO_CHARACTERISTICS, "Portfolio Characteristics", new PortfolioCharacteristicsConverter())
	, COUNTRY_ALLOCATION		(CharacteristicsType.COUNTRY_ALLOCATION, "Country Allocation", new CountryAllocationConverter())
	, CURRENCY_ALLOCATION		(CharacteristicsType.CURRENCY_ALLOCATION, "Currency Allocation", new CurrencyAllocationConverter())
	, MARKET_SEGMENTATION		(CharacteristicsType.MARKET_SEGMENTATION, "Market Segmentation by Capitalization", new MarketSegmentationByCapAllocationConverter())
	, REGIONAL_ALLOCATION		(CharacteristicsType.REGIONAL_ALLOCATION, "Regional Allocation", new RegionalAllocationConverter())
	, SECTOR_ALLOCATION			(CharacteristicsType.SECTOR_ALLOCATION, "Sector Allocation", new SectorAllocationConverter())
	, TOP_TEN_HOLDINGS			(CharacteristicsType.TOP_TEN_HOLDINGS, "Top 10 Holdings", new TopTenHoldingsCharacteristicsConverter())
	;

	private static final Map<String, TestCharacteristicsType> typesByName;
	static {
		typesByName = new HashMap<>();
		for (TestCharacteristicsType type : TestCharacteristicsType.values()) {
			typesByName.put(type.fullName, type);
		}
	}

	private final CharacteristicsType type;
	private final String fullName;
	private final CharacteristicsConverter converter;

	private TestCharacteristicsType(CharacteristicsType type, String fullName,  CharacteristicsConverter converter) {
		this.type = type;
		this.fullName = fullName;
		this.converter = converter;
	}

	public CharacteristicsType getType() {
		return type;
	}

	public String getCode() {
		return type.getCode();
	}

	public static TestCharacteristicsType getType(final String name) {
		return typesByName.get(name);
	}

	@Override
	public CharacteristicsConverter getConverter() {
		return converter;
	}
}


com.vanguard.corp.ics.sdt.webservice
		ApplicationTest.java

package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.HashMap;

import javax.sql.DataSource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.FilterRegistrationBean;
import org.springframework.core.env.Environment;
import org.springframework.security.config.annotation.ObjectPostProcessor;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.test.util.ReflectionTestUtils;

import com.vanguard.corp.ics.sdt.webservice.Application.ApplicationSecurity;

@RunWith(MockitoJUnitRunner.class)
public class ApplicationTest {
	
	@Mock
	private Environment env;
	
	@InjectMocks
	private Application application;

	@Mock
	private ObjectPostProcessor<Object> mockObjectPostProcessor;

	@Mock
	private AuthenticationManagerBuilder mockAuthenticationManagerBuilder;
	
	@Test
	public void testLocalProperties() {
		SpringApplication app = mock(SpringApplication.class);
		doNothing().when(app).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
		
		Application.setLocalProperties(app);
		
		if (Application.IS_OS_WINDOWS) {
			assertEquals(Application.LOCAL_RTEID, System.getProperty(Application.KEY_RTEID));
			verify(app).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
		} else {
			verify(app, never()).setAdditionalProfiles(Application.LOCAL_SPRING_PROFILE);
		}
	}
	
	@Test
	public void testServletContainer() {
		EmbeddedServletContainerFactory servletContainer = application.servletContainer();
		assertNotNull(servletContainer);
	}
	
	@Test
	public void testRequestContextFilter() {
		FilterRegistrationBean registration = application.requestContextFilter();
		assertEquals("/*", registration.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("RequestContextFilter", filterName);
	}
	
	@Test
	public void testSpringSecurityFilterChain() {
		FilterRegistrationBean registration = application.springSecurityFilterChain();
		assertEquals("/*", registration.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("SpringSecurityFilterChain", filterName);
	}
	
	@Test
	public void testF5Filter() {
		FilterRegistrationBean requestContextFilter = application.f5Filter();
		assertEquals("/" + Application.BASE_PATH + "/*", requestContextFilter.getUrlPatterns().iterator().next());
		
		// With great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(requestContextFilter, "name"));
		assertEquals("F5Filter", filterName);
	}
	
	@Test
	public void testH2DataSource() {
		DataSource dataSource = application.h2DataSource();

		assertNotNull(dataSource);
	}
	
	@Test
	public void testJaxrsFilter() throws InstantiationException, IllegalAccessException, ClassNotFoundException {
		FilterRegistrationBean registration = application.jaxrsFilter();
		
		assertEquals("/" + Application.BASE_PATH + "/*", registration.getUrlPatterns().iterator().next());
		assertEquals(Application.BASE_PATH, registration.getInitParameters().get("jersey.config.servlet.filter.contextPath"));
		assertEquals("com.vanguard.jaxrs.feature;com.vanguard.corp.ics.sdt", registration.getInitParameters().get("jersey.config.server.provider.packages"));
		assertEquals("xml:application/xml, json:application/json", registration.getInitParameters().get("jersey.config.server.mediaTypeMappings"));
		assertEquals("true", registration.getInitParameters().get("jersey.config.beanValidation.enableOutputValidationErrorEntity.servers"));
		assertEquals("true", registration.getInitParameters().get("jersey.config.servlet.filter.forwardOn404"));
		
		// WIth great power comes great responsibility
		String filterName = String.class.cast(ReflectionTestUtils.getField(registration, "name"));
		assertEquals("JerseyFilter", filterName);
	}
	
	@Test
	public void testJaxrsFilterJerseyDebugEnabledParamsWhenEnabled() throws InstantiationException, IllegalAccessException, ClassNotFoundException {
		when(env.getProperty("jersey.config.server.debug")).thenReturn("false");
		
		FilterRegistrationBean registration = application.jaxrsFilter();
		assertNull(registration.getInitParameters().get("jersey.config.server.monitoring.statistics.enabled"));
		assertNull(registration.getInitParameters().get("jersey.config.server.tracing.type"));
		assertNull(registration.getInitParameters().get("jersey.config.server.tracing.threshold"));
	}
	
	@Test
	public void testJaxrsFilterJerseyDebugEnabledParamsWhenDisabled() throws InstantiationException, IllegalAccessException, ClassNotFoundException {
		when(env.getProperty("jersey.config.server.debug")).thenReturn("true");
		
		FilterRegistrationBean registration = application.jaxrsFilter();
		assertEquals("true", registration.getInitParameters().get("jersey.config.server.monitoring.statistics.enabled"));
		assertEquals("ALL", registration.getInitParameters().get("jersey.config.server.tracing.type"));
		assertEquals("VERBOSE", registration.getInitParameters().get("jersey.config.server.tracing.threshold"));
	}
	
	@Test
	public void testApplicationSecurity() throws Exception {
		ApplicationSecurity applicationSecurity = application.applicationSecurity();
		assertNotNull(applicationSecurity);
		
		applicationSecurity.configure(new HttpSecurity(mockObjectPostProcessor, mockAuthenticationManagerBuilder, new HashMap<>()));
	}

	@Test
	public void testNtFilter() {
		FilterRegistrationBean ntFilter = application.ntFilter();
		assertNotNull(ntFilter);
	}
}

		NonProductionConditionTest.java

package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;


public class NonProductionConditionTest {

	private NonProductionCondition classUnderTest = new NonProductionCondition();

	@Mock
	private ConditionContext mockContext;

	@Mock
	private Environment mockEnvironment;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testMatchesNonProd() {
		when(mockContext.getEnvironment()).thenReturn(mockEnvironment);
		when(mockEnvironment.getProperty("RTEID")).thenReturn("test");
		
		assertTrue(classUnderTest.matches(mockContext, null));
	}

	@Test
	public void testMatchesProd() {
		when(mockContext.getEnvironment()).thenReturn(mockEnvironment);
		when(mockEnvironment.getProperty("RTEID")).thenReturn("prdprd");
		
		assertFalse(classUnderTest.matches(mockContext, null));
	}

}


		NTHeaderFilterTest.java

package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.Principal;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Locale;
import java.util.Map;

import javax.servlet.AsyncContext;
import javax.servlet.DispatcherType;
import javax.servlet.FilterChain;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletInputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.vanguard.corp.ics.sdt.webservice.NTHeaderFilter.FakeHeadersRequest;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpUpgradeHandler;
import javax.servlet.http.Part;


public class NTHeaderFilterTest {

	private NTHeaderFilter classUnderTest = new NTHeaderFilter();

//	@Mock
	private HttpServletRequest mockRequest;
	private ServletResponse mockResponse;

	@Mock
	private FilterChain mockChain;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
		
		mockRequest = new HttpServletRequest() {

			@Override
			public AsyncContext getAsyncContext() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Object getAttribute(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<String> getAttributeNames() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getCharacterEncoding() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getContentLength() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public long getContentLengthLong() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public String getContentType() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public DispatcherType getDispatcherType() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public ServletInputStream getInputStream() throws IOException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getLocalAddr() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getLocalName() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getLocalPort() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public Locale getLocale() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<Locale> getLocales() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getParameter(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Map<String, String[]> getParameterMap() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<String> getParameterNames() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String[] getParameterValues(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getProtocol() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public BufferedReader getReader() throws IOException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRealPath(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRemoteAddr() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRemoteHost() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getRemotePort() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public RequestDispatcher getRequestDispatcher(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getScheme() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getServerName() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getServerPort() {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public ServletContext getServletContext() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public boolean isAsyncStarted() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isAsyncSupported() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isSecure() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public void removeAttribute(String arg0) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void setAttribute(String arg0, Object arg1) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {
				// TODO Auto-generated method stub
				
			}

			@Override
			public AsyncContext startAsync() throws IllegalStateException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public AsyncContext startAsync(ServletRequest arg0, ServletResponse arg1) throws IllegalStateException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public boolean authenticate(HttpServletResponse arg0) throws IOException, ServletException {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public String changeSessionId() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getAuthType() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getContextPath() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Cookie[] getCookies() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public long getDateHeader(String arg0) {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public String getHeader(String arg0) {
				return "Hi!  I'm a header value!";
			}

			@Override
			public Enumeration<String> getHeaderNames() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Enumeration<String> getHeaders(String arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public int getIntHeader(String arg0) {
				// TODO Auto-generated method stub
				return 0;
			}

			@Override
			public String getMethod() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Part getPart(String arg0) throws IOException, ServletException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Collection<Part> getParts() throws IOException, ServletException {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getPathInfo() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getPathTranslated() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getQueryString() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRemoteUser() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRequestURI() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public StringBuffer getRequestURL() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getRequestedSessionId() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getServletPath() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public HttpSession getSession() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public HttpSession getSession(boolean arg0) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public Principal getUserPrincipal() {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public boolean isRequestedSessionIdFromCookie() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isRequestedSessionIdFromURL() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isRequestedSessionIdFromUrl() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isRequestedSessionIdValid() {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public boolean isUserInRole(String arg0) {
				// TODO Auto-generated method stub
				return false;
			}

			@Override
			public void login(String arg0, String arg1) throws ServletException {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void logout() throws ServletException {
				// TODO Auto-generated method stub
				
			}

			@Override
			public <T extends HttpUpgradeHandler> T upgrade(Class<T> arg0) throws IOException, ServletException {
				// TODO Auto-generated method stub
				return null;
			}
			
		};
	}

	@Test
	public void testNTHeaderFilter() {
		assertNotNull(new NTHeaderFilter());
	}

	@Test
	public void testDestroy() {
		classUnderTest.destroy();
	}

	@Test
	public void testInit() throws ServletException {
		classUnderTest.init(null);
	}

	@Test
	public void testDoFilter() throws IOException, ServletException {
		doNothing().when(mockChain).doFilter(any(FakeHeadersRequest.class), any(ServletResponse.class));
		
		classUnderTest.doFilter(mockRequest, mockResponse, mockChain);
	}

	@Test
	public void testFakeHeadersRequest() {
		NTHeaderFilter x = new NTHeaderFilter();
		FakeHeadersRequest req = x.new FakeHeadersRequest(mockRequest);
		
		String header = req.getHeader("APP_CODE");
		assertEquals("SDT", header);
		
		header = req.getHeader("other");
		assertEquals("Hi!  I'm a header value!", header);
	}
}

		WindowsConditionTest.java

package com.vanguard.corp.ics.sdt.webservice;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.env.Environment;


public class WindowsConditionTest {

	private WindowsCondition classUnderTest = new WindowsCondition();

	@Mock
	private ConditionContext mockContext;

	@Mock
	private Environment mockEnvironment;

	@Before
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testMatchesWindows() {
		when(mockContext.getEnvironment()).thenReturn(mockEnvironment);
		when(mockEnvironment.getProperty("os.name")).thenReturn("blah blah Windows blah");
		
		assertTrue(classUnderTest.matches(mockContext, null));
	}

	@Test
	public void testMatchesLinux() {
		when(mockContext.getEnvironment()).thenReturn(mockEnvironment);
		when(mockEnvironment.getProperty("os.name")).thenReturn("Linux is free, dude!");
		
		assertFalse(classUnderTest.matches(mockContext, null));
	}

}


com.vanguard.corp.ics.sdt.webservice.cucumber
		RunAdHocCuke.java
		
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = { "@AdHoc" }
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT + "adhoc"
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS + "adhoc/adhoc-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT + "adhoc/adhoc-test-reports.xml"
				}
)
public class RunAdHocCuke {


}
		RunEndToEndCukeTest.java
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;
import com.vanguard.test.categories.EndToEndTest;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@Category(EndToEndTest.class)
@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = {
				"~@ManualTest"
				, "~@SlowTest"
				, "~@IgnoreTest"
				, "~@AdHoc"
				, "@EndToEndTest"
				}
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT_ENDTOEND
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS_ENDTOEND + "endtoend-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT_ENDTOEND + "endtoend-test-reports.xml"
				}
)
public class RunEndToEndCukeTest {

}

		RunIgnoreCukeTest.java
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = false
		, monochrome = true
		, tags = { "@IgnoreTest" }
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT + "ignore/ignore"
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS + "ignore/ignore-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT + "ignore/ignore-test-reports.xml"
				}
)
public class RunIgnoreCukeTest {

//	This is a tagged hook so that test marked Ignore will show up in the Cucumber Jenkins Report.
//	This code should be added in a Hooks class for use. For more information on Hooks see Best Practices or cucumber book.
//	@Before("@IgnoreTest")
//	public void beforeScenario() {
//		Assume.assumeTrue("These tests are marked IGNORE and will be counted as Skipped.", false);
//	} 
}

		RunIntegrationCukeTest.java
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;
import com.vanguard.test.categories.IntegrationTest;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@Category(IntegrationTest.class)
@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = {
				"~@ManualTest"
				, "~@SlowTest"
				, "~@IgnoreTest"
				, "~@AdHoc"
				, "@IntegrationTest"
				}
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT_INTEGRATION
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS_INTEGRATION + "integration-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT_INTEGRATION + "integration-test-reports.xml"
				}
)
public class RunIntegrationCukeTest {
	
}

		RunRegressionCukeTest.java
package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = false
		, monochrome = true
		, tags = { "@ManualTest" }
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, glue = { "com.vanguard.shared" }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT + "manual/manual"
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS + "manual/manual-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT + "manual/manual-test-reports.xml"
				}
)
public class RunRegressionCukeTest {


}

		RunUnitCukeTest.java

package com.vanguard.corp.ics.sdt.webservice.cucumber;

import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;

import com.vanguard.shared.CucumberRunnerUtil;
import com.vanguard.test.categories.UnitTest;

import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import cucumber.api.junit.Cucumber;

@Category(UnitTest.class)
@RunWith(Cucumber.class)
@CucumberOptions(
		snippets = SnippetType.CAMELCASE
		, strict = true
		, monochrome = true
		, tags = {
				"~@ManualTest"
				, "~@SlowTest"
				, "~@IgnoreTest"
				, "~@AdHoc"
				, "@UnitTest"
				}
		, features = { CucumberRunnerUtil.CukeFormat.FEATURE_FILE_LOCATION }
		, plugin = {
				"pretty"
				, CucumberRunnerUtil.CukeFormat.CD_HTML_REPORT_UNIT
				, CucumberRunnerUtil.CukeFormat.CD_JSON_RESULTS_UNIT + "unit-test-reports.json"
				, CucumberRunnerUtil.CukeFormat.CD_JUNIT_XML_REPORT_UNIT + "unit-test-reports.xml"
				}
)
public class RunUnitCukeTest {
	
}


com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs

		InvestmentObjectiveStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ProductDataServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class InvestmentObjectiveStepDefs {
	
	private static final String PRODUCT_CODE = "ONE90";
	private static final String PRODUCT_NAME = "OnePath Australian Listed Property Index Pool";
	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String CURRENCY_CODE = "AUD";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final String CLIENT_ID = "ANZ OnePath";
	private static final String BENCHMARK_NAME = "test";
	
	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;
	
	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();
	
	@InjectMocks
	private ProductDataServiceImpl productDataService;
	
	@Mock
	private Utilities utilities;
	
	private PortalProduct portalProduct;
	
	private Currency currency;

	private InvestmentGroup investmentGroup;
	
	private List<PortalProduct> portalProducts;
	
	@Given("^a portfolio with Investment Objective that exists in Product Portal$")
	public void a_portfolio_with_Investment_Objective_that_exists_in_Product_Portal() throws Throwable {
	    // Write code here that turns the phrase above into concrete actions
		MockitoAnnotations.initMocks(this);
		
		portalProducts = new ArrayList<>();
		
		portalProduct = new PortalProduct();
		currency = new Currency();
		investmentGroup = new InvestmentGroup();
		
		portalProduct.setBaseCurrencyID(Long.valueOf(1));
		portalProduct.setBenchMarkName(BENCHMARK_NAME);
		portalProduct.setClientID(CLIENT_ID);
		portalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct.setProductCode(PRODUCT_CODE);
		portalProduct.setProductName(PRODUCT_NAME);
		portalProduct.setInvestmentObjective(INVSTMNT_OBJ);

		
		currency.setCurrencyCode(CURRENCY_CODE);
		currency.setCurrencyId(Long.valueOf(1));
		currency.setCurrencyName("Australian Dollar123");

		investmentGroup.setInvestmentGroupCode("EIG");
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);
		
		portalProducts.add(portalProduct);
		
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		when(productPortalService.getProduct(portalProducts, PRODUCT_CODE)).thenReturn(this.portalProduct);
		when(utilities.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(utilities.generateDateFromString(portalProduct.getPerfInceptionDate(), RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT)).thenReturn(PERF_INCEPT_DATE);
		when(productPortalService.getProductCurrency(portalProduct, request)).thenReturn(currency);
		when(productPortalService.getInvestmentGroup(portalProduct, request)).thenReturn(investmentGroup);
	}

	@When("^user runs the report service$")
	public void user_runs_the_report_service() throws Throwable {
		productDataService.moveProductPortalDataToReport(portalProduct, request);
	}

	@Then("^the table shall contain Investment Objective$")
	public void the_table_shall_contain_Investment_Objective() throws Throwable {
		assertEquals(INVSTMNT_OBJ, testAccountFundRepository.accountFunds.get(0).getInvestmentObjective());
	}
}

		PortfolioOverviewStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ProductDataServiceImpl;

import cucumber.api.DataTable;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class PortfolioOverviewStepDefs {
	
	private static final String CURRENT_USERNAME = "UXXX";
	private static final String DATE_STRING = "dd-MMM-yyyy";
	private static final DateFormat DATE_FORMAT = new SimpleDateFormat(DATE_STRING);
	private static final String CURRENCY_NAME = "Australian Dollar123";
	private static final String INVESTMENT_GROUP_CODE = "EIG";
	private static final int FIRST_RECORD = 0;
	private static final Long DEFAULT_LONG = Long.valueOf(1);
	private static final int DATA_ROW = 1;
	private static final int PRODUCT_CODE_COL = 0;
	private static final int PORTFOLIO_MANAGER_COL = 1;
	private static final int INCEPTION_DATE_COL = 2;
	private static final int BENCHMARK_COL = 3;
	private static final int PORTFOLIO_CURRENCY_COL = 4;
	
	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();
	
	@InjectMocks
	private ProductDataServiceImpl productDataService;
	
	@Mock
	private Utilities utilities;
	
	private PortalProduct portalProduct;
	
	private List<PortalProduct> portalProducts;

	private Currency currency;

	private InvestmentGroup investmentGroup;
	
	@Given("^a portfolio with the following attributes$")
	public void a_portfolio_with_the_following_attributes(DataTable table) throws Exception {
		MockitoAnnotations.initMocks(this);
		
		List<List<String>> data = table.raw();
		
		portalProducts = new ArrayList<>();
		portalProduct = new PortalProduct();
		currency = new Currency();
		investmentGroup = new InvestmentGroup();
		
		portalProduct.setBaseCurrencyID(DEFAULT_LONG);
		portalProduct.setBenchMarkName(data.get(DATA_ROW).get(BENCHMARK_COL));
		portalProduct.setPerfInceptionDate(data.get(DATA_ROW).get(INCEPTION_DATE_COL));
		portalProduct.setProductCode(data.get(DATA_ROW).get(PRODUCT_CODE_COL));
		
		currency.setCurrencyId(DEFAULT_LONG);
		currency.setCurrencyCode(data.get(DATA_ROW).get(PORTFOLIO_CURRENCY_COL));
		currency.setCurrencyName(CURRENCY_NAME);

		investmentGroup.setInvestmentGroupId(DEFAULT_LONG);
		investmentGroup.setInvestmentGroupCode(INVESTMENT_GROUP_CODE);
		investmentGroup.setInvestmentGroupName(data.get(DATA_ROW).get(PORTFOLIO_MANAGER_COL));
		
		portalProducts.add(portalProduct);
		
		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		when(productPortalService.getProduct(portalProducts, portalProduct.getProductCode())).thenReturn(this.portalProduct);
		when(utilities.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(utilities.generateDateFromString(portalProduct.getPerfInceptionDate(), DATE_STRING)).thenReturn(DATE_FORMAT.parse(portalProduct.getPerfInceptionDate()));
		when(productPortalService.getProductCurrency(portalProduct, request)).thenReturn(currency);
		when(productPortalService.getInvestmentGroup(portalProduct, request)).thenReturn(investmentGroup);
	}
	
	@When("^report service is run by user$")
	public void report_service_is_run_by_user_for_TEMP() {
		productDataService.moveProductPortalDataToReport(portalProduct, request);
	}
	
	@Then("^the table shall contain the following information$")
	public void the_table_shall_contain_the_following_information(DataTable table) throws Exception{
		List<List<String>> data = table.raw();
		
		Date inceptionDate = DATE_FORMAT.parse(data.get(DATA_ROW).get(INCEPTION_DATE_COL));

		assertEquals(data.get(DATA_ROW).get(PORTFOLIO_MANAGER_COL),testAccountFundRepository.accountFunds.get(FIRST_RECORD).getPortfolioManager());
		assertEquals(inceptionDate,testAccountFundRepository.accountFunds.get(FIRST_RECORD).getInceptionDate());
		assertEquals(data.get(DATA_ROW).get(BENCHMARK_COL),testAccountBenchmarkAssociationRepository.accountBenchmarkAssociationList.get(FIRST_RECORD).getBenchmarkName());
		assertEquals(data.get(DATA_ROW).get(PORTFOLIO_CURRENCY_COL),testAccountFundRepository.accountFunds.get(FIRST_RECORD).getPortfolioBaseCurrency());
	}
}

		ReportHeaderStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.constants.RestServiceConstants;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.Currency;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.InvestmentGroup;
import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.api.portal.ProductPortalService;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountBenchmarkAssociationRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountFundRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestAccountSetupRepository;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ProductDataServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class ReportHeaderStepDefs {

	private static final Long INVSTMNT_GRP_ID = Long.valueOf(1);
	private static final String INVSTMNT_GRP_NAME = "Equity Investment Group";
	private static final String CURRENCY_CODE = "AUD";
	private static final Date PERF_INCEPT_DATE = new Date(1);
	private static final String INVSTMNT_OBJ = "Investment Objective 1";
	private static final String CURRENT_USERNAME = "Utilities Username";
	private static final String BENCHMARK_NAME = "test";

	@Mock
	ProductPortalService productPortalService;

	@Mock
	HttpServletRequest request;

	@Spy
	TestAccountSetupRepository testAccountSetupRepository = new TestAccountSetupRepository();

	@Spy
	TestAccountFundRepository testAccountFundRepository = new TestAccountFundRepository();

	@Spy
	TestAccountBenchmarkAssociationRepository testAccountBenchmarkAssociationRepository = new TestAccountBenchmarkAssociationRepository();

	@InjectMocks
	private ProductDataServiceImpl productDataService;

	@Mock
	private Utilities utilities;

	private PortalProduct portalProduct;

	private Currency currency;

	private InvestmentGroup investmentGroup;

	private List<PortalProduct> portalProducts;

	@Given("^a portfolio with (.*) that has (.*) and (.*) which exists in Product Portal$")
	public void a_portfolio_with_that_has_and_which_exists_in_Product_Portal(String productCode, String clientName,
			String mandateName) throws Throwable {
		MockitoAnnotations.initMocks(this);
		portalProducts = new ArrayList<>();
		portalProduct = new PortalProduct();
		currency = new Currency();
		investmentGroup = new InvestmentGroup();

		portalProduct.setBaseCurrencyID(Long.valueOf(1));
		portalProduct.setBenchMarkName(BENCHMARK_NAME);
		portalProduct.setClientID(clientName);
		portalProduct.setInvestmentGroupID(INVSTMNT_GRP_ID);
		portalProduct.setPerfInceptionDate(PERF_INCEPT_DATE.toString());
		portalProduct.setProductCode(productCode);
		portalProduct.setProductName(mandateName);
		portalProduct.setInvestmentObjective(INVSTMNT_OBJ);

		currency.setCurrencyCode(CURRENCY_CODE);
		currency.setCurrencyId(Long.valueOf(1));
		currency.setCurrencyName("Australian Dollar123");

		investmentGroup.setInvestmentGroupCode("EIG");
		investmentGroup.setInvestmentGroupId(Long.valueOf(1));
		investmentGroup.setInvestmentGroupName(INVSTMNT_GRP_NAME);

		portalProducts.add(portalProduct);

		when(productPortalService.getProducts(request)).thenReturn(this.portalProducts);
		when(productPortalService.getProduct(portalProducts, productCode)).thenReturn(this.portalProduct);
		when(utilities.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(utilities.generateDateFromString(portalProduct.getPerfInceptionDate(),
				RestServiceConstants.PRODUCT_PORTAL_INCEPTION_DATE_FORMAT)).thenReturn(PERF_INCEPT_DATE);
		when(productPortalService.getProductCurrency(portalProduct, request)).thenReturn(currency);
		when(productPortalService.getInvestmentGroup(portalProduct, request)).thenReturn(investmentGroup);
	}

	@When("^report service is run by user for (.*)$")
	public void report_service_is_run_by_user(String productCode) throws Throwable {
		productDataService.moveProductPortalDataToReport(portalProduct, request);
	}

	@Then("^the table shall contain (.*) and (.*) for (.*)$")
	public void the_table_shall_contain_CBUS(String clientName, String mandateName, String productCode)
			throws Throwable {
		assertEquals(clientName, testAccountSetupRepository.accountSetupList.get(0).getAccountClientName());
		assertEquals(mandateName, testAccountFundRepository.accountFunds.get(0).getAccountName());
		assertEquals(productCode, testAccountFundRepository.accountFunds.get(0).getPortfolioId());
	}
}

		RunATestIntegrationSteps.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class RunATestIntegrationSteps {

	@When("^user calls a service$")
	public void user_calls_a_service() throws Throwable {
		// Implement
	}
	
	@Then("^the response code is (.*)$")
	public void the_response_code_is_OK(final String responseName) throws Throwable {
		Status expectedResponse = Response.Status.valueOf(responseName);
	}
	
}

		ValuationsStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.dao.target.ValuationsTargetDAO;
import com.vanguard.corp.ics.repository.target.ValuationsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestValuationReportRepository;
import com.vanguard.corp.ics.sdt.service.api.constants.SecurityTypeCode;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.ValuationsServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class ValuationsStepDefs {

	@InjectMocks
	ValuationsServiceImpl valService = new ValuationsServiceImpl();
	
	@Spy
	TestValuationReportRepository valuationsReportRepository = new TestValuationReportRepository();
	
	@Mock
	ValuationsRepository valuationsTargetRepository;
	
	@Mock
	Utilities utilities;
	
	private ValuationsTargetDAO valTargetDAO;
	private ValuationsTargetDAO priorMonthTargetDAO;
	private DateFormat df = new SimpleDateFormat("dd-MMM-yy");
	
	@Given("^a portfolio with (.*) with (.*) and (.*)$")
	public void a_portfolio_with_Equity_with_and(String assetType, double currentMonthSource, double priorMonthSource) throws Throwable {
		MockitoAnnotations.initMocks(this);
		valTargetDAO = new ValuationsTargetDAO();
		priorMonthTargetDAO = new ValuationsTargetDAO();
		
		valTargetDAO.setId(Long.valueOf(1));
		valTargetDAO.setEquityValue(0.0);
		valTargetDAO.setDerivitivesValue(0.0);
		valTargetDAO.setLiquidityValue(0.0);
		valTargetDAO.setFixedInterestValue(0.0);
		valTargetDAO.setForwardForiegnExchangeValue(0.0);
		valTargetDAO.setFuturesValue(0.0);
		valTargetDAO.setTotalValue(currentMonthSource);
		valTargetDAO.setPortfolioCode("TEST");
		valTargetDAO.setValueDate(df.parse("31-jul-17"));
		
		priorMonthTargetDAO.setId(Long.valueOf(2));
		priorMonthTargetDAO.setEquityValue(0.0);
		priorMonthTargetDAO.setDerivitivesValue(0.0);
		priorMonthTargetDAO.setLiquidityValue(0.0);
		priorMonthTargetDAO.setFixedInterestValue(0.0);
		priorMonthTargetDAO.setForwardForiegnExchangeValue(0.0);
		priorMonthTargetDAO.setFuturesValue(0.0);
		priorMonthTargetDAO.setTotalValue(priorMonthSource);
		priorMonthTargetDAO.setPortfolioCode("TEST");
		priorMonthTargetDAO.setValueDate(df.parse("30-jun-17"));
		
		switch(assetType){
			case "Equity" : 
				valTargetDAO.setEquityValue(currentMonthSource);
				priorMonthTargetDAO.setEquityValue(priorMonthSource);
				
				break;
				
			case "Liquidity" : 
				valTargetDAO.setLiquidityValue(currentMonthSource);
				priorMonthTargetDAO.setLiquidityValue(priorMonthSource);
				
				break;
				
			case "Futures Exposure" :
				valTargetDAO.setFuturesValue(currentMonthSource);
				priorMonthTargetDAO.setFuturesValue(priorMonthSource);
				
				break;
				
			case "Derivitives" : 
				valTargetDAO.setDerivitivesValue(currentMonthSource);
				priorMonthTargetDAO.setDerivitivesValue(priorMonthSource);
				
				break;
				
			case "Securities" : 
				valTargetDAO.setFixedInterestValue(currentMonthSource);
				priorMonthTargetDAO.setFixedInterestValue(priorMonthSource);
				
				break;
			
			case "FFX" :
				valTargetDAO.setForwardForiegnExchangeValue(currentMonthSource);
				priorMonthTargetDAO.setForwardForiegnExchangeValue(priorMonthSource);
				
		}
		
		List<ValuationsTargetDAO> valTargetRecords = new ArrayList<ValuationsTargetDAO>();
		
		valTargetRecords.add(valTargetDAO);
		valTargetRecords.add(priorMonthTargetDAO);
		
		when(utilities.getPreviousMonthEnd(df.parse("31-jul-17"))).thenReturn(df.parse("30-jun-17"));
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetDAO.getValueDate(), "TEST")).thenReturn(valTargetDAO);
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(priorMonthTargetDAO.getValueDate(), "TEST")).thenReturn(priorMonthTargetDAO);
		
	}
	
	
	@Given("^a portfolio with multiple asset types$")
	public void a_portfolio_with_multiple_asset_types() throws Throwable {
		MockitoAnnotations.initMocks(this);
		valTargetDAO = new ValuationsTargetDAO();
		priorMonthTargetDAO = new ValuationsTargetDAO();
		
		valTargetDAO.setId(Long.valueOf(3));
		valTargetDAO.setEquityValue(100.0);
		valTargetDAO.setDerivitivesValue(100.0);
		valTargetDAO.setLiquidityValue(100.0);
		valTargetDAO.setFixedInterestValue(100.0);
		valTargetDAO.setForwardForiegnExchangeValue(100.0);
		valTargetDAO.setFuturesValue(100.0);
		double totalValue = valTargetDAO.getEquityValue() + valTargetDAO.getDerivitivesValue() + valTargetDAO.getLiquidityValue() + valTargetDAO.getFixedInterestValue() + valTargetDAO.getForwardForiegnExchangeValue() + valTargetDAO.getFuturesValue();
		valTargetDAO.setTotalValue(totalValue);
		valTargetDAO.setPortfolioCode("TEST");
		valTargetDAO.setValueDate(df.parse("31-jul-17"));
		
		
		priorMonthTargetDAO.setId(Long.valueOf(4));
		priorMonthTargetDAO.setEquityValue(50.0);
		priorMonthTargetDAO.setDerivitivesValue(50.0);
		priorMonthTargetDAO.setLiquidityValue(50.0);
		priorMonthTargetDAO.setFixedInterestValue(50.0);
		priorMonthTargetDAO.setForwardForiegnExchangeValue(50.0);
		priorMonthTargetDAO.setFuturesValue(50.0);
		double priorTotalValue = priorMonthTargetDAO.getEquityValue() + priorMonthTargetDAO.getDerivitivesValue() + priorMonthTargetDAO.getLiquidityValue() + priorMonthTargetDAO.getFixedInterestValue() + priorMonthTargetDAO.getForwardForiegnExchangeValue() + priorMonthTargetDAO.getFuturesValue();
		priorMonthTargetDAO.setTotalValue(priorTotalValue);
		priorMonthTargetDAO.setPortfolioCode("TEST");
		priorMonthTargetDAO.setValueDate(df.parse("30-jun-17"));
		 
		
		List<ValuationsTargetDAO> valTargetRecords = new ArrayList<ValuationsTargetDAO>();
		
		valTargetRecords.add(valTargetDAO);
		valTargetRecords.add(priorMonthTargetDAO);
		
		when(utilities.getPreviousMonthEnd(df.parse("31-jul-17"))).thenReturn(df.parse("30-jun-17"));
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(valTargetDAO.getValueDate(), "TEST")).thenReturn(valTargetDAO);
		when(valuationsTargetRepository.findByValueDateIsAndPortfolioCodeIs(priorMonthTargetDAO.getValueDate(), "TEST")).thenReturn(priorMonthTargetDAO);
	}

	@When("^user runs portfolio valuation calculations for June (\\d+)$")
	public void user_runs_portfolio_valuation_calculations(int year) throws Throwable {
		valService.moveValuationsFromTargetToReport("TEST", valTargetDAO.getValueDate());
	}
	
	@When("^user runs portfolio valuation calculations for <current month>$")
	public void userRunsPortfolioValuationCalculationsForCurrentMonth() throws Throwable {
		valService.moveValuationsFromTargetToReport("TEST", valTargetDAO.getValueDate());
	}

	@Then("^prior month NAV value matches value for < prior month report>$")
	public void prior_month_NAV_value_matches_value_for_prior_month_report() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			assertEquals(priorMonthTargetDAO.getTotalValue(), valuationsReportRepository.dataMap.get(priorMonthTargetDAO.getPortfolioCode() + priorMonthTargetDAO.getValueDate().toString() + value.getCode()).getTotalValue(),0);
		}
	}
	
	@Then("^current month NAV value matches value for < current month report>$")
	public void current_month_NAV_value_matches_value_for_current_month_report() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			assertEquals(valTargetDAO.getTotalValue(), valuationsReportRepository.dataMap.get(valTargetDAO.getPortfolioCode() + valTargetDAO.getValueDate().toString() + value.getCode()).getTotalValue(),0);	}
		}
		
	@Then("^current month total will be the sum of all current month assets$")
	public void current_month_total_will_be_Sum_of_all_current_month_assets() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			assertEquals(valTargetDAO.getTotalValue(), valuationsReportRepository.dataMap.get(valTargetDAO.getPortfolioCode() + valTargetDAO.getValueDate().toString() + value.getCode()).getTotalValue(),0);	}
		}
		
	@Then("^prior month total will be total of prior month assets$")
	public void prior_month_total_will_be_total_of_all_prior_month_assets() throws Throwable {
		for (SecurityTypeCode value : SecurityTypeCode.values()){
			assertEquals(priorMonthTargetDAO.getTotalValue(), valuationsReportRepository.dataMap.get(priorMonthTargetDAO.getPortfolioCode() + priorMonthTargetDAO.getValueDate().toString() + value.getCode()).getTotalValue(),0);	}
		}
}
com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e
		AttributionSummaryStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.PendingException;
import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

/**
 * @author um2a
 *
 */
public class AttributionSummaryStepDefs {
	
	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	
	@Given("^test attribution_Summary data are loaded into target tables$")
	public void testAttribution_SummaryDataAreLoadedIntoTargetTables() throws Throwable {
	    // Write code here that turns the phrase above into concrete actions
	    throw new PendingException();
	}

	@When("^transfer of attribution_Summary data is requested$")
	public void transferOfAttribution_SummaryDataIsRequested() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-06-30");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "TEST01");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.ATTRIBUTION_SUMMARY.toString());
		response = webTarget.request().get();
		// response.bufferEntity();
	    throw new PendingException();
	}

	@Then("^the system indicates successful completion of the attribution_Summary transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheAttribution_SummaryTransfer() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	    throw new PendingException();
	}

	@Then("^the test attribution_Summary data are saved in reporting tables$")
	public void theTestAttribution_SummaryDataAreSavedInReportingTables() throws Throwable {
	    // Write code here that turns the phrase above into concrete actions
	    throw new PendingException();
	}

	@Then("^the test attribution_Summary data are cleaned up from the target tables$")
	public void theTestAttribution_SummaryDataAreCleanedUpFromTheTargetTables() throws Throwable {
	    // Write code here that turns the phrase above into concrete actions
	    throw new PendingException();
	}

	@Then("^the test attribution_Summary data are cleaned up from the reporting tables$")
	public void theTestAttribution_SummaryDataAreCleanedUpFromTheReportingTables() throws Throwable {
	    // Write code here that turns the phrase above into concrete actions
	    throw new PendingException();
	}

}

		CharacteristicsStepDefs.java


package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.service.api.constants.DataSetType;
import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CharacteristicsStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}

	@Given("^test characteristics data are loaded into target tables$")
	public void testCharacteristicsDataAreLoadedIntoTargetTables() throws Throwable {
		// no need for this (yet) as target table & repository are not complete
	}

	@When("^transfer of characteristics data is requested$")
	public void transferOfCharacteristicsDataIsRequested() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(DataTransferResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2017-06-30");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "TEST01");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_DATA_SET, DataSetType.CHARACTERISTICS.toString());
		response = webTarget.request().get();
		// response.bufferEntity();
	}

	@Then("^the system indicates successful completion of the characteristics transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheCharacteristicsTransfer() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the test characteristics data are saved in reporting tables$")
	public void theTestCharactersisticsDataAreSavedInReportingTables() throws Throwable {
		// TODO figure out how to check database without exposing an endpoint to prod
	}

	@Then("^the test characteristics data are cleaned up from the target tables$")
	public void theTestCharacteristicsDataAreCleanedUpFromTheTargetTables() throws Throwable {
		// not necessary at this time
	}

	@Then("^the test characteristics data are cleaned up from the reporting tables$")
	public void theTestCharacteristicsDataAreCleanedUpFromTheReportingTables() throws Throwable {
		// TODO figure out how to clean up without exposing an endpoint to prod
	}
}

		CommentaryStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import static org.junit.Assert.assertEquals;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import com.vanguard.corp.ics.sdt.webservice.Application;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryDTO;
import com.vanguard.corp.ics.sdt.webservice.resource.CommentaryResource;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CommentaryStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	@Given("^a mandate exists in the product portal$")
	public void a_mandate_exists_in_the_product_portal() throws Throwable {
	    // Not sure we need this yet
	}
	
	@Given("^a commentary entry exists for a mandate on a specified date$")
	public void a_commentary_entry_exists_for_a_mandate_on_a_specified_date() throws Throwable {
	   // Table doesn't exist yet.  Update when it does.
	}

	@When("^commentary is added for a mandate on a specified date$")
	public void commentary_is_added_for_that_mandate_on_a_specified_date() throws Throwable {
		CommentaryDTO commentary = new CommentaryDTO();
		
		commentary.setAsOfDate("2016-03-31");
		commentary.setPortId("TEST01");
		commentary.setCommentary("Here is a short commentary");
		
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(CommentaryResource.PATH);
		response = webTarget.request().post(Entity.json(commentary));
	}

	@When("^commentary is requested for a manadate on a specified date$")
	public void commentary_is_requested_for_that_manadate_on_a_specified_date() throws Throwable {
		WebTarget webTarget = client.target(HOST).path(Application.BASE_PATH).path(CommentaryResource.PATH);
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_AS_OF_DATE, "2016-03-31");
		webTarget = webTarget.queryParam(DataTransferParameters.PARM_PORT_ID, "TEST01");
		response = webTarget.request().get();
	}

	@Then("^the system indicates successful completion of the commentary entry$")
	public void the_system_indicates_successful_completion_of_the_commentary_entry() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the system indicates successful completion of the commentary update$")
	public void the_system_indicates_successful_completion_of_the_commentary_update() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}

	@Then("^the system indicates successful completion of the commentary retrieval$")
	public void the_system_indicates_successful_completion_of_the_commentary_retrieval() throws Throwable {
		assertEquals(Response.Status.Family.SUCCESSFUL, response.getStatusInfo().getFamily());
	}
}

		SecurityStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.e2e;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.Response;

import com.vanguard.jaxrs.feature.SecureClientRequestFeature;

import cucumber.api.PendingException;
import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class SecurityStepDefs {

	private static final String HOST = System.getProperty("route.urls", "http://localhost.vanguard.com:8080");

	private Client client = null;
	private Response response;

	@Before
	public void setup() {
		if (client == null) {
			client = ClientBuilder.newClient().register(SecureClientRequestFeature.class);
		}
		response = null;
	}
	
	@Given("^test data are loaded into target tables$")
	public void testDataAreLoadedIntoTargetTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Given("^a user with valid permission to request transfer of data$")
	public void aUserWithValidPermissionToRequestTransferOfData() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Given("^a user without valid permission to request transfer of data$")
	public void aUserWithoutValidPermissionToRequestTransferOfData() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@When("^transfer of data is requested$")
	public void transferOfDataIsRequested() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the system indicates successful completion of the transfer$")
	public void theSystemIndicatesSuccessfulCompletionOfTheTransfer() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the system indicates failure due to no permission$")
	public void theSystemIndicatesFailureDueToNoPermission() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are saved in reporting tables$")
	public void theTestDataAreSavedInReportingTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are not saved in reporting tables$")
	public void theTestDataAreNotSavedInReportingTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are cleaned up from the target tables$")
	public void theTestDataAreCleanedUpFromTheTargetTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
	
	@Then("^the test data are cleaned up from the reporting tables$")
	public void theTestDataAreCleanedUpFromTheReportingTables() throws Throwable {
		//TODO when we apply SBF security
		throw new PendingException();
	}
}

com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration
		CharacteristicsStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.inject.Inject;

import org.powermock.reflect.Whitebox;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.repository.target.FactsetMonthlyCharacteristicsRepository;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.DataTransferService;
import com.vanguard.corp.ics.sdt.service.api.TransferService;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.impl.DataTransferServiceImpl;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsConverter;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsRepoWrapper;
import com.vanguard.corp.ics.sdt.service.impl.characteristics.CharacteristicsTransferService;
import com.vanguard.corp.ics.sdt.test.characteristics.PortfolioCharacteristicsType;
import com.vanguard.corp.ics.sdt.test.characteristics.TestCharacteristicsType;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.CharacteristicsIntegrationData;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferParameters;
import com.vanguard.corp.ics.sdt.webservice.resource.DataTransferResource;

import cucumber.api.java.Before;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class CharacteristicsStepDefs {

	private static final String DATE_FORMAT = "yyyy-MM-dd";
	private static final String AS_OF_DATE_1 = "2016-01-31";
	private static final String AS_OF_DATE_2 = "2016-02-29";
	private static final String PORT_ID_1 = "TEST01";
	private static final String PORT_ID_2 = "TEST02";

	@Inject
	private CharacteristicsIntegrationData characteristicsIntegrationData;

	private List<FactsetMonthlyCharacteristicsTargetDAO> retrievableTargetCharacteristics;
	private String targetPortId;
	private CheckableCharacteristicsRepoWrapper checkableWrapper;

	@Before
	public void setup() {
		characteristicsIntegrationData.setAvailableTargetCharacteristics(new ArrayList<>());
		characteristicsIntegrationData.setSavedCharacteristics(null);
		characteristicsIntegrationData.setTargetAsOfDate(null);
		retrievableTargetCharacteristics = new ArrayList<>();
		targetPortId = null;
		checkableWrapper = null;
	}

	@Given("^target tables contain characteristics data for multiple port ids and multiple as of dates$")
	public void targetTablesContainPortfolioCharacteristicsDataForMultiplePortIdsAndMultipleAsOfDates() throws Throwable {
		SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);

		FactsetMonthlyCharacteristicsTargetDAO ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MARKET_CAPITALIZATION.getLabel());
		ch.setPortfolioValue(1234567890.12345);
		ch.setBenchMarkValue(1123456789.01234);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(1001234567.89012);
		ch.setBenchMarkValue(1001234567.89012);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(2345678901.23456);
		ch.setBenchMarkValue(2456789012.34567);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MARKET_CAPITALIZATION.getLabel());
		ch.setPortfolioValue(9876543210.98765);
		ch.setBenchMarkValue(9765432101.23456);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(987654321.09876);
		ch.setBenchMarkValue(987654321.09876);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(9987654321.09876);
		ch.setBenchMarkValue(9998765432.10987);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MARKET_CAPITALIZATION.getLabel());
		ch.setPortfolioValue(1000000000.00000);
		ch.setBenchMarkValue(100000000.00000);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(999999.99999);
		ch.setBenchMarkValue(999999.99999);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(2000000000.00000);
		ch.setBenchMarkValue(2500000000.00000);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MARKET_CAPITALIZATION.getLabel());
		ch.setPortfolioValue(-543210987.65432);
		ch.setBenchMarkValue(-532109876.54321);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(-987654321.01234);
		ch.setBenchMarkValue(-987654321.01234);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(PortfolioCharacteristicsType.MIN_MARKET_CAP.getLabel());
		ch.setPortfolioValue(-123456789.01234);
		ch.setBenchMarkValue(-234567890.12345);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);
	}

	@Given("^target tables contain characteristics data with name \"([^\"]*)\"$")
	public void targetTablesContainPortfolioCharacteristicsDataWithName(String name) throws Throwable {
		SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);

		FactsetMonthlyCharacteristicsTargetDAO ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(name);
		ch.setPortfolioValue(77.77777);
		ch.setBenchMarkValue(77.77777);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_1));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(name);
		ch.setPortfolioValue(66.66666);
		ch.setBenchMarkValue(66.66666);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_1);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(name);
		ch.setPortfolioValue(55.55555);
		ch.setBenchMarkValue(55.55555);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);

		ch = new FactsetMonthlyCharacteristicsTargetDAO();
		ch.setEffectiveDate(formatter.parse(AS_OF_DATE_2));
		ch.setPortfolioCode(PORT_ID_2);
		ch.setCharacteristicsType(CharacteristicsType.PORTFOLIO_CHARACTERISTICS.getCode());
		ch.setCharacteristicsName(name);
		ch.setPortfolioValue(55.55555);
		ch.setBenchMarkValue(55.55555);
		characteristicsIntegrationData.getAvailableTargetCharacteristics().add(ch);
	}

	@Given("^target tables contain no characteristics data$")
	public void targetTablesContainNoPortfolioCharacteristicsData() throws Throwable {
		// no characteristics added to availableTargetCharacteristics
	}

	@Given("^one of the included as of dates is targeted$")
	public void oneOfTheIncludedAsOfDatesIsTargeted() throws Throwable {
		characteristicsIntegrationData.setTargetAsOfDate((new Random()).nextBoolean() ? AS_OF_DATE_1 : AS_OF_DATE_2);
	}

	@Given("^an as of date is targeted anyway$")
	public void anAsOfDatesIsTargetedAnyway() throws Throwable {
		characteristicsIntegrationData.setTargetAsOfDate((new Random()).nextBoolean() ? AS_OF_DATE_1 : AS_OF_DATE_2);
	}

	@Given("^one of the included port ids is targeted$")
	public void oneOfTheIncludedPortIdsIsTargeted() throws Throwable {
		targetPortId = (new Random()).nextBoolean() ? PORT_ID_1 : PORT_ID_2;
	}

	@When("^characteristics data are transferred$")
	public void portfolioCharacteristicsDataAreTransferred() throws Throwable {
		SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
		Date targetDate = formatter.parse(characteristicsIntegrationData.getTargetAsOfDate());

		for (FactsetMonthlyCharacteristicsTargetDAO ch : characteristicsIntegrationData.getAvailableTargetCharacteristics()) {
			if (ch.getEffectiveDate().equals(targetDate) && (targetPortId == null || ch.getPortfolioCode().equals(targetPortId))) {
				retrievableTargetCharacteristics.add(ch);
			}
		}

		final DataTransferParameters parms = new DataTransferParameters();
		parms.setAsOfDate(characteristicsIntegrationData.getTargetAsOfDate());
		parms.setPortId(targetPortId);

		final DataTransferResource resource = buildDataTransferResource();
		resource.transfer(parms);

		assertNotNull("checkableWrapper is null", checkableWrapper);
		characteristicsIntegrationData.setSavedCharacteristics(checkableWrapper.getSavedCharacteristics());
	}

	@Then("^the characteristics data for the targeted as of date are saved to reporting tables$")
	public void thePortfolioCharacteristicsDataForTheTargetedAsOfDateAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());

		int foundCount = 0;
		for (FactsetMonthlyCharacteristicsTargetDAO dao : retrievableTargetCharacteristics) {
			for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
				if (dao.getEffectiveDate().equals(ch.getEffectiveDate())
//						&& dao.getBenchMarkValue().equals(ch.getBenchmark().doubleValue())
						&& dao.getCharacteristicsName().equals(ch.getName())
						&& dao.getCharacteristicsType().equals(ch.getType())
						&& dao.getPortfolioCode().equals(ch.getPortId())
//						&& dao.getPortfolioValue().equals(ch.getPortfolio().doubleValue())
						) {
					foundCount++;
					break;
				}
			}
		}

		assertEquals(retrievableTargetCharacteristics.size(), foundCount);
	}

	@Then("^no characteristics data for other as of dates are saved to reporting tables$")
	public void noPortfolioCharacteristicsDataForOtherAsOfDatesAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		assertEquals(retrievableTargetCharacteristics.size(), characteristicsIntegrationData.getSavedCharacteristics().size());
	}

	@Then("^the saved characteristics data exactly match the source data$")
	public void theSavedPortfolioCharacteristicsDataExactlyMatchTheSourceData() throws Throwable {
		// yeah, already did that above
	}

	@Then("^the characteristics data for the targeted port id and as of date are saved to reporting tables$")
	public void thePortfolioCharacteristicsDataForTheTargetedPortIdAndAsOfDateAreSavedToReportingTables() throws Throwable {
		// did that above also
	}

	@Then("^no characteristics data for other port ids or as of dates are saved to reporting tables$")
	public void noPortfolioCharacteristicsDataForOtherPortIdsOrAsOfDatesAreSavedToReportingTables() throws Throwable {
		// look, we made super sure above already
	}

	@Then("^no characteristics data are saved to reporting tables$")
	public void noPortfolioCharacteristicsDataAreSavedToReportingTables() throws Throwable {
		assertNotNull("savedCharacteristics is null", characteristicsIntegrationData.getSavedCharacteristics());
		assertEquals(0, characteristicsIntegrationData.getSavedCharacteristics().size());
	}

	@Then("^characteristics data with name \"([^\"]*)\" are saved to reporting tables$")
	public void portfolioCharacteristicsDataWithNameAreSavedToReportingTables(String name) throws Throwable {
		boolean found = false;
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			if (ch.getName().equals(name)) {
				found = true;
				break;
			}
		}
		assertTrue(found);
	}

	private DataTransferResource buildDataTransferResource() {
		final DataTransferResource resource = new DataTransferResource();
		Whitebox.setInternalState(resource, DataTransferService.class, buildDataTransferService());
		return resource;
	}

	private DataTransferService buildDataTransferService() {
		final DataTransferService service = new DataTransferServiceImpl();
		List<TransferService> services = new ArrayList<>();
		services.add(buildCharacteristicsTransferHandler());
		Whitebox.setInternalState(service, "services", services);
		return service;
	}

	private TransferService buildCharacteristicsTransferHandler() {
		final TransferService handler = new CharacteristicsTransferService();
		Whitebox.setInternalState(handler, FactsetMonthlyCharacteristicsRepository.class, buildReadCharacteristicsRepository());
		Whitebox.setInternalState(handler, "converters", buildCharacteristicsConverters());
		Whitebox.setInternalState(handler, CharacteristicsRepoWrapper.class, buildCharacteristicsRepoWrapper());
		return handler;
	}

	private FactsetMonthlyCharacteristicsRepository buildReadCharacteristicsRepository() {
		final FactsetMonthlyCharacteristicsRepository repo = new FactsetMonthlyCharacteristicsRepository() {

			private final List<FactsetMonthlyCharacteristicsTargetDAO> retrievable = retrievableTargetCharacteristics;

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findByEffectiveDateAndPortfolioCode(Date asOfDate, String portfolioCode) {
				return retrievable;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findByEffectiveDate(Date asOfDate) {
				return retrievable;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findAll() {
				return null;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findAll(Sort sort) {
				return null;
			}

			@Override
			public List<FactsetMonthlyCharacteristicsTargetDAO> findAll(Iterable<Long> ids) {
				return null;
			}

			@Override
			public <S extends FactsetMonthlyCharacteristicsTargetDAO> List<S> save(Iterable<S> entities) {
				return null;
			}

			@Override
			public void flush() {
			}

			@Override
			public <S extends FactsetMonthlyCharacteristicsTargetDAO> S saveAndFlush(S entity) {
				return null;
			}

			@Override
			public void deleteInBatch(Iterable<FactsetMonthlyCharacteristicsTargetDAO> entities) {
			}

			@Override
			public void deleteAllInBatch() {
			}

			@Override
			public FactsetMonthlyCharacteristicsTargetDAO getOne(Long id) {
				return null;
			}

			@Override
			public Page<FactsetMonthlyCharacteristicsTargetDAO> findAll(Pageable arg0) {
				return null;
			}

			@Override
			public long count() {
				return 0;
			}

			@Override
			public void delete(Long arg0) {
			}

			@Override
			public void delete(FactsetMonthlyCharacteristicsTargetDAO arg0) {
			}

			@Override
			public void delete(Iterable<? extends FactsetMonthlyCharacteristicsTargetDAO> arg0) {
			}

			@Override
			public void deleteAll() {
			}

			@Override
			public boolean exists(Long arg0) {
				return false;
			}

			@Override
			public FactsetMonthlyCharacteristicsTargetDAO findOne(Long arg0) {
				return null;
			}

			@Override
			public <S extends FactsetMonthlyCharacteristicsTargetDAO> S save(S arg0) {
				return null;
			}

			
		};
		return repo;
	}

	private List<CharacteristicsConverter> buildCharacteristicsConverters() {
		List<CharacteristicsConverter> converters = new ArrayList<>();
		
		for (TestCharacteristicsType type : TestCharacteristicsType.values()) {
			converters.add(type.getConverter());
		}
		
		return converters;
	}

	private static interface CheckableCharacteristicsRepoWrapper extends CharacteristicsRepoWrapper {

		List<Characteristics> getSavedCharacteristics();
	}

	private CharacteristicsRepoWrapper buildCharacteristicsRepoWrapper() {
		final CheckableCharacteristicsRepoWrapper wrapper = new CheckableCharacteristicsRepoWrapper() {

			private final List<Characteristics> saved = new ArrayList<>();

			@Override
			public List<Characteristics> getSavedCharacteristics() {
				return saved;
			}

			@Override
			public List<Characteristics> saveAll(List<Characteristics> saveList) {
				saved.addAll(saveList);
				return saveList;
			}

			@Override
			public List<Characteristics> retrieveAll(Date asOfDate, String portId) {
				return null;
			}

			@Override
			public List<Characteristics> retrieveAll(Date asOfDate) {
				return null;
			}

			@Override
			public void logicalDelete(Date asOfDate, String portId, String characteristicsType) {
			}
		};

		checkableWrapper = wrapper;
		return wrapper;
	}
}

		RoundingStepDefs.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.inject.Inject;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;
import com.vanguard.corp.ics.sdt.service.api.constants.CharacteristicsType;
import com.vanguard.corp.ics.sdt.service.api.util.DateParser;
import com.vanguard.corp.ics.sdt.test.characteristics.TestCharacteristicsType;
import com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared.CharacteristicsIntegrationData;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;

public class RoundingStepDefs {

	private static final String AS_OF_DATE = "2016-01-31";

	@Inject
	private CharacteristicsIntegrationData characteristicsIntegrationData;

	@Given("^target tables contain the following (.*) section data$")
	public void targetTablesContainTheFollowingSectionData(final String sectionName, final List<Map<String, String>> dataRows) throws Throwable {
		
		DateParser dateParser = new DateParser();
		
		TestCharacteristicsType characteristicsType = TestCharacteristicsType.getType(sectionName);
		assertNotNull("Unknown characteristics name: "+sectionName, characteristicsType);
		
		List<FactsetMonthlyCharacteristicsTargetDAO> available = new ArrayList<>();
		FactsetMonthlyCharacteristicsTargetDAO dao;
		String portId, portfolio, benchmark;
		for (Map<String, String> dataRow : dataRows) {
			portId = dataRow.get("port id");
			portfolio = dataRow.get("portfolio value");
			benchmark = dataRow.get("benchmark value");
			
			dao = new FactsetMonthlyCharacteristicsTargetDAO();
			dao.setBenchMarkValue(benchmark.equals("null") ? null : Double.valueOf(benchmark));
			dao.setCharacteristicsName("");
			dao.setCharacteristicsType(characteristicsType.getCode());
			dao.setEffectiveDate(dateParser.parse(AS_OF_DATE));
			dao.setPortfolioCode(portId);
			dao.setPortfolioValue(portfolio.equals("null") ? null : Double.valueOf(portfolio));
			
			available.add(dao);
		}
		
		characteristicsIntegrationData.setAvailableTargetCharacteristics(available);
		characteristicsIntegrationData.setTargetAsOfDate(AS_OF_DATE);
	}

	@Then("^reporting tables contain the following (.*) section data$")
	public void reportingTablesContainTheFollowingSectionData(final String sectionName, final List<Map<String, String>> dataRows) throws Throwable {
		
		TestCharacteristicsType characteristicsType = TestCharacteristicsType.getType(sectionName);
		assertNotNull("Unknown characteristics name: "+sectionName, characteristicsType);
		
		Set<String> portIdsWithNullPortfolioValues = new HashSet<>();
		Set<String> portIdsWithNullBenchmarkValues = new HashSet<>();
		Map<String, List<String>> portIdEntryCounter = new HashMap<>();
		
		Set<String> portIds = new HashSet<>();
		String portId, portfolio, benchmark;
		List<String> counterList;
		boolean found = false;
		for (Map<String, String> dataRow : dataRows) {
			portId = dataRow.get("port id");
			portIds.add(portId);
			portfolio = dataRow.get("portfolio value");
			benchmark = dataRow.get("benchmark value");
			found = false;
			
			counterList = portIdEntryCounter.get(portId);
			if (counterList == null) {
				counterList = new ArrayList<>();
				portIdEntryCounter.put(portId, counterList);
			}
			counterList.add(portfolio+"-"+benchmark);
			
			if ("null".equals(portfolio)) {
				portIdsWithNullPortfolioValues.add(portId);
			}
			if ("null".equals(benchmark)) {
				portIdsWithNullBenchmarkValues.add(portId);
			}
			
			for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
				if (ch.getPortId().equals(portId)
						&& ch.getType().equals(characteristicsType.getCode())
						&& (
								("null".equals(portfolio) && ch.getPortfolio() == null)
								|| (!"null".equals(portfolio) && ch.getPortfolio() != null && ch.getPortfolio().compareTo(new BigDecimal(portfolio)) == 0)
								)
						&& (
								("null".equals(benchmark) && ch.getBenchmark() == null)
								|| (!"null".equals(benchmark) && ch.getBenchmark() != null && ch.getBenchmark().compareTo(new BigDecimal(benchmark)) == 0)
								)
						) {
					found = true;
					break;
				}
			}
			assertTrue(String.format("didn't find: portId:%s portfolio:%s benchmark:%s", portId, portfolio, benchmark), found);
		}
		
		if (characteristicsType.getType() == CharacteristicsType.PORTFOLIO_CHARACTERISTICS) {
			return; // yay, successful!
		}
		
		Map<String, BigDecimal> portfolioTotalsByPortId = new HashMap<>();
		Map<String, BigDecimal> benchmarkTotalsByPortId = new HashMap<>();
		Iterator<String> iterator = portIds.iterator();
		while (iterator.hasNext()) {
			portId = iterator.next();
			portfolioTotalsByPortId.put(portId, new BigDecimal("0.00000"));
			benchmarkTotalsByPortId.put(portId, new BigDecimal("0.00000"));
		}
		
		for (Characteristics ch : characteristicsIntegrationData.getSavedCharacteristics()) {
			portfolioTotalsByPortId.put(ch.getPortId(), portfolioTotalsByPortId.get(ch.getPortId()).add(ch.getPortfolio() == null ? BigDecimal.ZERO : ch.getPortfolio()));
			benchmarkTotalsByPortId.put(ch.getPortId(), benchmarkTotalsByPortId.get(ch.getPortId()).add(ch.getBenchmark() == null ? BigDecimal.ZERO : ch.getBenchmark()));
		}
		for (String key : portfolioTotalsByPortId.keySet()) {
			
			if (characteristicsType.getType() == CharacteristicsType.TOP_TEN_HOLDINGS
					&& portIdEntryCounter.get(key).size() > 9
					) {
				continue; // don't magic round more than 9 entries
			}
			
			if (!portIdsWithNullPortfolioValues.contains(key)) {
				assertEquals(String.format("type %s %s portfolio total is: %s", characteristicsType.getCode(), key, portfolioTotalsByPortId.get(key)), 0, portfolioTotalsByPortId.get(key).compareTo(new BigDecimal("100.0")));
			}
			if (!portIdsWithNullBenchmarkValues.contains(key)) {
				assertEquals(String.format("type %s %s benchmark total is: %s", characteristicsType.getCode(), key, benchmarkTotalsByPortId.get(key)), 0, benchmarkTotalsByPortId.get(key).compareTo(new BigDecimal("100.0")));
			}
		}
	}

}

com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared
		CharacteristicsIntegrationData.java


package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared;

import java.util.List;

import javax.inject.Named;

import org.springframework.context.annotation.Scope;

import com.vanguard.corp.ics.dao.target.FactsetMonthlyCharacteristicsTargetDAO;
import com.vanguard.corp.ics.sdt.dao.impl.entity.report.Characteristics;

@Named
@Scope("cucumber-glue")
public class CharacteristicsIntegrationData {

	private List<FactsetMonthlyCharacteristicsTargetDAO> availableTargetCharacteristics;
	private String targetAsOfDate;
	private List<Characteristics> savedCharacteristics;

	public List<FactsetMonthlyCharacteristicsTargetDAO> getAvailableTargetCharacteristics() {
		return availableTargetCharacteristics;
	}

	public void setAvailableTargetCharacteristics(List<FactsetMonthlyCharacteristicsTargetDAO> availableTargetCharacteristics) {
		this.availableTargetCharacteristics = availableTargetCharacteristics;
	}

	public String getTargetAsOfDate() {
		return targetAsOfDate;
	}

	public void setTargetAsOfDate(String targetAsOfDate) {
		this.targetAsOfDate = targetAsOfDate;
	}

	public List<Characteristics> getSavedCharacteristics() {
		return savedCharacteristics;
	}

	public void setSavedCharacteristics(List<Characteristics> savedCharacteristics) {
		this.savedCharacteristics = savedCharacteristics;
	}
}

com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.unit
		RiskSummaryServiceSteps.java

package com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.unit;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.nullable;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.vanguard.corp.ics.sdt.dao.api.domain.portal.PortalProduct;
import com.vanguard.corp.ics.sdt.dao.impl.portal.ProductPortalServiceImpl;
import com.vanguard.corp.ics.sdt.dao.impl.repository.TestPortfolioLimitRepository;
import com.vanguard.corp.ics.sdt.service.api.constants.AnalyticsTypeCode;
import com.vanguard.corp.ics.sdt.service.api.util.Utilities;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.LimitValidator;
import com.vanguard.corp.ics.sdt.service.impl.risksummary.RiskSummaryServiceImpl;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;

public class RiskSummaryServiceSteps {

	private static final String CURRENT_USERNAME = "Utilities Username";
	
	@Mock
	ProductPortalServiceImpl productPortalService;
	
	@Mock
	Utilities utilities;
	
	@Mock
	LimitValidator limitValidator;

	@Spy
	TestPortfolioLimitRepository portfolioAnalyticsRepository = new TestPortfolioLimitRepository();

	@InjectMocks
	RiskSummaryServiceImpl riskSummaryService;

	private PortalProduct product;

	private AnalyticsTypeCode type;

	@Given("^a portfolio with ([\\dA-z -]+) and (-?\\d+) that exists in Product Portal$")
	public void a_portfolio_with_Analytic_Type_and_risk_that_exists_in_Product_Portal(String analyticName, String limit) throws Throwable {
		MockitoAnnotations.initMocks(this);
		product = new PortalProduct();

		if (AnalyticsTypeCode.EX_ANTE_RISK.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.EX_ANTE_RISK;
			product.setExAnteMaxBreachIMA(limit);
		} else if (AnalyticsTypeCode.ONE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_EX_POST;
			product.setExPostMaxBreachIMA(limit);
		} else if (AnalyticsTypeCode.THREE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.THREE_YR_EX_POST;
			product.setExPostMaxBreachIMA(limit);
		} else if (AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_STANDARD_DEV;
		} else {
			type = AnalyticsTypeCode.THREE_YR_STANDARD_DEV;
		}

		product.setProductCode("TEST");

		List<PortalProduct> products = new ArrayList<PortalProduct>();

		products.add(product);

		when(utilities.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(productPortalService.getProducts(any(HttpServletRequest.class))).thenReturn(products);
		when(productPortalService.getProduct(products, "TEST")).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(Double.class), nullable(Double.class), nullable(Double.class))).thenReturn(true);
	}

	@Given("^a portfolio with ([\\dA-z -]+), (-?\\d+), (-?\\d+), and (\\d+) that exists in Product Portal$")
	public void a_portfolio_with_Analytic_type_and_split_attributes_that_exists_in_Product_Portal(String analyticName,
			String riskLowerLimit, String riskUpperLimit, Double fumSplitLimit) throws Throwable {
		MockitoAnnotations.initMocks(this);
		product = new PortalProduct();
		
		if (AnalyticsTypeCode.EX_ANTE_RISK.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.EX_ANTE_RISK;
			product.setExAnteMaxBreachIMA(riskLowerLimit);
			product.setExAnteMaxBreachIMAAbvLmt(riskUpperLimit);
			product.setExAnteFumSplitLimit(fumSplitLimit);
		} else if (AnalyticsTypeCode.ONE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_EX_POST;
			product.setExPostMaxBreachIMA(riskLowerLimit);
		} else if (AnalyticsTypeCode.THREE_YR_EX_POST.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.THREE_YR_EX_POST;
			product.setExPostMaxBreachIMA(riskLowerLimit);
		} else if (AnalyticsTypeCode.ONE_YR_STANDARD_DEV.getName().equals(analyticName)) {
			type = AnalyticsTypeCode.ONE_YR_STANDARD_DEV;
		} else {
			type = AnalyticsTypeCode.THREE_YR_STANDARD_DEV;
		}
		
		product.setProductCode("TEST");
		
		List<PortalProduct> products = new ArrayList<PortalProduct>();
		
		products.add(product);
		
		when(utilities.getCurrentUsername()).thenReturn(CURRENT_USERNAME);
		when(productPortalService.getProducts(any(HttpServletRequest.class))).thenReturn(products);
		when(productPortalService.getProduct(products, "TEST")).thenReturn(product);
		when(limitValidator.isValid(any(AnalyticsTypeCode.class), nullable(Double.class), nullable(Double.class), nullable(Double.class))).thenReturn(true);
	}

	@When("^user runs the Risk Summary calculations$")
	public void user_runs_the_Risk_Summary_calculations() throws Throwable {
		HttpServletRequest mock = Mockito.mock(HttpServletRequest.class);
		riskSummaryService.transfer(new Date(), "TEST", mock);
	}

	@Then("^the reporting table shall show (-?\\d+\\.?\\d+|\\s*)$")
	public void the_reporting_table_shall_show_limit(Double expected) throws Throwable {
		assertEquals(expected, portfolioAnalyticsRepository.dataMap.get(type.getName()).getLowerLimitValue());
	}

	@Then("^the reporting table shall show (-?\\d+\\.?\\d+|\\s*) and (-?\\d+\\.?\\d+|\\s*) and (\\d+|\\s*)$")
	public void the_reporting_table_shall_show_lower_limit_and_upper_limit_and_FUM_split_limit(Double lowerLimit,
			Double upperLimit, Double fumSplitLimit) throws Throwable {
		assertEquals(lowerLimit, portfolioAnalyticsRepository.dataMap.get(type.getName()).getLowerLimitValue());
		assertEquals(upperLimit, portfolioAnalyticsRepository.dataMap.get(type.getName()).getUpperLimitValue());
		assertEquals(fumSplitLimit, portfolioAnalyticsRepository.dataMap.get(type.getName()).getFumSplitLimitValue());
	}
}


com.vanguard.corp.ics.sdt.webservice.resource

		CommentaryTest.java

package com.vanguard.corp.ics.sdt.webservice.resource;

import static org.junit.Assert.*;

import org.junit.Test;

public class CommentaryTest {
	
	private final String TEST_ID = "1";
	private final String TEST_PORTFOLIO_ID = "TestPortId";
	private final String TEST_AS_OF_DATE = "2017-01-01";
	private final String TEST_COMMENTARY_TEXT = "Test Commentary.";

	/**
	 * Test getters and setters
	 */
	@Test
	public void shouldGetAndSetValues() {
		CommentaryDTO commentary = new CommentaryDTO();
		
		commentary.setId(TEST_ID);
		commentary.setPortId(TEST_PORTFOLIO_ID);
		commentary.setAsOfDate(TEST_AS_OF_DATE);
		commentary.setCommentary(TEST_COMMENTARY_TEXT);
		
		assertEquals(commentary.getId(), TEST_ID);
		assertEquals(commentary.getPortId(), TEST_PORTFOLIO_ID);
		assertEquals(commentary.getAsOfDate(), TEST_AS_OF_DATE);
		assertEquals(commentary.getCommentary(), TEST_COMMENTARY_TEXT);
		
	}

}

		TomcatDefaultErrorResourceTest.java

package com.vanguard.corp.ics.sdt.webservice.resource;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.times;

import java.io.IOException;

import javax.servlet.DispatcherType;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import com.vanguard.test.categories.UnitTest;

@Category(UnitTest.class)
@RunWith(MockitoJUnitRunner.class)
public class TomcatDefaultErrorResourceTest {
	
	@Mock
	private HttpServletResponse response;
	
	@Mock
	private HttpServletRequest request;
	
	@Mock
	private ServletOutputStream outputStream;
	
	@Test
	public void testHandleErrorWhenDispatcherTypeError() throws IOException {
		TomcatDefaultErrorResource resource = createTomcatDefaultErrorResource("ERROR");
		int returnCode = 401;
		
		when(request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).thenReturn(returnCode);
		when(request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).thenReturn("http://blahblahblah.com");
		when(request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).thenReturn("Success");
		when(request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).thenReturn(null);
		when(response.getStatus()).thenReturn(returnCode);
		when(response.getOutputStream()).thenReturn(outputStream);
		doNothing().when(outputStream).flush();
		doNothing().when(outputStream).close();

		resource.handleError(response, request);
		
		assertEquals(returnCode, response.getStatus());
		
	}

	@Test
	public void testHandleErrorWhenDispatcherTypeNotError() throws IOException {
		TomcatDefaultErrorResource resource = createTomcatDefaultErrorResource("REQUEST");
		int returnCode = 500;
		
		when(response.getOutputStream()).thenReturn(outputStream);
		when(response.getStatus()).thenReturn(returnCode);
		doNothing().when(outputStream).flush();
		doNothing().when(outputStream).close();

		resource.handleError(response, request);
		
		assertEquals(returnCode, response.getStatus());
	}
	
	private TomcatDefaultErrorResource createTomcatDefaultErrorResource(String dispatcherType) {
		TomcatDefaultErrorResource resource = new TomcatDefaultErrorResource() {

			@Override
			protected String getDispatcherType(HttpServletRequest request) {
				return dispatcherType;
			}
			
		};
		return resource;
	}

	@Test
	public void testGetDispatcherType() {
		when(request.getDispatcherType()).thenReturn(DispatcherType.FORWARD);
		
		TomcatDefaultErrorResource classUnderTest = new TomcatDefaultErrorResource();
		classUnderTest.getDispatcherType(request);
		
		verify(request, times(1)).getDispatcherType();
	}
}



----------------------------------------------------------------------------------------------------------
src/test/resources


	attributionSummary.feature
@AttributionSummary
Feature: Attribution Summary functionality
  
  Specifications:
  1. Calculating Attribution Summary values:
     a. read value from L2 (Target) table
     b. write value to L1 (Reporting) table
  
  2. 
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for Attribution Summary.
  2. Effective Date is a required input parameter.
  
  Definitions:
  1.

  @IntegrationTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contain attribution summary data for multiple port ids and multiple effective dates
    And one of the included effective dates is targeted
    When attribution summary data are transferred
    Then the attribution summary data for the targeted effective dates are saved to reporting tables
    And no attribution summary data for other effective dates are saved to reporting tables
    And the saved attribution summary data exactly match the source data

  @IntegrationTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contain attribution summary data for multiple port ids and multiple effective dates
    And one of the included effective dates is targeted
    And one of the included port ids is targeted
    When attribution summary data are transferred
    Then the attribution summary data for the targeted port id and effective dates are saved to reporting tables
    And no attribution summary data for other port ids or effective dates are saved to reporting tables
    And the saved attribution summary data exactly match the source data

  @IntegrationTest
  Scenario: no data found is fine
    Given target tables contain no attribution summary data
    And an effective date is targeted anyway
    When attribution summary data are transferred
    Then no attribution summary data are saved to reporting tables

  @IntegrationTest
  Scenario: no data validation is done
    Given target tables contain attribution summary data for multiple port ids and multiple effective dates
    And target tables contain attribution summary data with name "RHuisdgFO%ICHF31as0943&$aAWEG"
    And one of the included effective dates is targeted
    When attribution summary data are transferred
    Then the attribution summary data for the targeted effective dates are saved to reporting tables
    And no attribution summary data for other effective dates are saved to reporting tables
    And the saved attribution summary data exactly match the source data
    And attribution summary data with name "RHuisdgFO%ICHF31as0943&$aAWEG" are saved to reporting tables

  @EndToEndTest
  Scenario: transfer of attribution summary values
    Given test attribution summary data are loaded into target tables
    When transfer of attribution summary data is requested
    Then the system indicates successful completion of the attribution Summary transfer
    And the test attribution summary data are saved in reporting tables
    And the test attribution summary data are cleaned up from the target tables
    And the test attribution summary data are cleaned up from the reporting tables


Characteristics

	characteristics.feature

@Characteristics
Feature: characteristics functionality
  
  Specifications:
  1. Calculating characteristics values:
     a. read value from L2 (Target) table
     b. transformation as required, per characteristics type
     c. write value to L1 (Reporting) table
  
  2. 
  
  Assumptions:
  1. No data validation occurs when moving data from L2 to L1 tables for characteristics.
  2. AsOfDate is a required input parameter.
  
  Definitions:
  1.

  @IntegrationTest
  Scenario: happy path data transfer to reporting tables
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And one of the included as of dates is targeted
    When characteristics data are transferred
    Then the characteristics data for the targeted as of date are saved to reporting tables
    And no characteristics data for other as of dates are saved to reporting tables
    And the saved characteristics data exactly match the source data

  @IntegrationTest
  Scenario: if port id is specified, transfer only data for that port id
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And one of the included as of dates is targeted
    And one of the included port ids is targeted
    When characteristics data are transferred
    Then the characteristics data for the targeted port id and as of date are saved to reporting tables
    And no characteristics data for other port ids or as of dates are saved to reporting tables
    And the saved characteristics data exactly match the source data

  @IntegrationTest
  Scenario: no data found is fine
    Given target tables contain no characteristics data
    And an as of date is targeted anyway
    When characteristics data are transferred
    Then no characteristics data are saved to reporting tables

  @IntegrationTest
  Scenario: no data validation is done
    Given target tables contain characteristics data for multiple port ids and multiple as of dates
    And target tables contain characteristics data with name "RHuisdgFO%ICHF31as0943&$aAWEG"
    And one of the included as of dates is targeted
    When characteristics data are transferred
    Then the characteristics data for the targeted as of date are saved to reporting tables
    And no characteristics data for other as of dates are saved to reporting tables
    And the saved characteristics data exactly match the source data
    And characteristics data with name "RHuisdgFO%ICHF31as0943&$aAWEG" are saved to reporting tables

  @EndToEndTest
  Scenario: transfer of characteristics values
    Given test characteristics data are loaded into target tables
    When transfer of characteristics data is requested
    Then the system indicates successful completion of the characteristics transfer
    And the test characteristics data are saved in reporting tables
    And the test characteristics data are cleaned up from the target tables
    And the test characteristics data are cleaned up from the reporting tables

		rounding.feature

@Characteristics @Rounding
Feature: Magic and Mundane Rounding
  
  1. Magic rounding happens every time data is moved for the following sections:
     Market Segmentation by Capitalization
     Regional Allocation
     Country Allocation
     Sector Allocation
     Currency Allocation
  
  2. Mundane rounding happens every time data is moved for the following sections:
     Portfolio Characteristics
  
  3. Rounding type is determined based on the number of data points for the port id
     in the section for the following sections:
     Top 10 Holdings
     
       a. if less than 10 data points: magic rounding
       
       b. if greater than or equal to 10 data points: mundane rounding
  
  4. Mundane rounding changes the portfolio value and benchmark value by rounding half away
     from zero to one digit after the decimal place.
  
  5. Magic rounding forces the sum of the mundanely rounded portfolio values and the sum of
     the mundanely rounded benchmark values for each port id to equal 100.0 by adding the
     difference from 100.0 to the greatest portfolio value and the greatest benchmark value.
     
     Note: The greatest benchmark value may not correspond to the greatest portfolio value.
     
     a. When the sum of the portfolio values after mundane rounding for a port id is greater
        than 100.0, the difference is subtracted from the greatest portfolio value for that
        port id.
     
     b. When the sum of the benchmark values after mundane rounding for a port id is greater
        than 100.0, the difference is subtracted from the greatest benchmark value for that
        port id.
     
     c. When the sum of the portfolio values after mundane rounding for a port id is less
        than 100.0, the difference is added to the greatest portfolio value for that port id.
     
     d. When the sum of the benchmark values after mundane rounding for a port id is less
        than 100.0, the difference is added to the greatest benchmark value for that port id.
     
     e. When the sum of the portfolio values after mundane rounding for a port id is exactly
        equal to 100.0, none of the portfolio values are adjusted for that port id.
     
     f. When the sum of the benchmark values after mundane rounding for a port id is exactly
        equal to 100.0, none of the benchmark values are adjusted for that port id.
     
     g. When the sum of the portfolio values after mundane rounding differs from 100.0 and two
        or more portfolio values after mundane rounding are tied as the greatest portfolio
        value, one of them is arbitrarily selected as the greatest and is adjusted as
        specified above.
     
     h. When the sum of the benchmark values after mundane rounding differs from 100.0 and two
        or more benchmark values after mundane rounding are tied as the greatest benchmark
        value, one of them is arbitrarily selected as the greatest and is adjusted as
        specified above.
     
     i. When one or more portfolio values for a port id is missing data (has a null value),
        the portfolio values for that port id are NOT magically rounded, but are instead
        saved to be displayed in their mundanely rounded form, including the null value. 
     
     j. When one or more benchmark values for a port id is missing data (has a null value),
        the benchmark values for that port id are NOT magically rounded, but are instead
        saved to be displayed in their mundanely rounded form, including the null value.

  @IntegrationTest
  Scenario Outline: magic rounding when the greatest value for each port id needs not to be adjusted
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                                  |
      | 1111    | 59.49999        | 59.49999        |                                          |
      | 1111    | 30.34999        | 30.34999        |                                          |
      | 1111    | 10.15011        | 10.15011        |                                          |
      | 1111    | 0.04999         | 0.04999         |                                          |
      | 2222    | 44.85001        | 55.14999        | portfolio and benchmark values different |
      | 2222    | 55.14999        | 44.85001        | portfolio and benchmark values different |
      | 3333    | 30.64999        | 30.64999        |                                          |
      | 3333    | 69.35001        | 69.35001        |                                          |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 59.50000        | 59.50000        |
      | 1111    | 30.30000        | 30.30000        |
      | 1111    | 10.20000        | 10.20000        |
      | 1111    | 0.00000         | 0.00000         |
      | 2222    | 44.90000        | 55.10000        |
      | 2222    | 55.10000        | 44.90000        |
      | 3333    | 30.60000        | 30.60000        |
      | 3333    | 69.40000        | 69.40000        |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: magic rounding when the greatest value for each port id needs to be adjusted
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                            |
      | 1111    | 59.40000        | 59.40000        | max portfolio and benchmark values |
      | 1111    | 30.30001        | 30.30001        |                                    |
      | 1111    | 10.20001        | 10.20001        |                                    |
      | 1111    | 0.04999         | 0.04999         |                                    |
      | 1111    | 0.04999         | 0.04999         |                                    |
      | 2222    | 54.99999        | 54.99999        | max portfolio and benchmark values |
      | 2222    | 44.90003        | 44.90003        |                                    |
      | 2222    | 0.04999         | 0.04999         |                                    |
      | 2222    | 0.04999         | 0.04999         |                                    |
      | 3333    | 21.05000        | 20.05000        | max portfolio value                |
      | 3333    | 20.05000        | 21.05000        | max benchmark value                |
      | 3333    | 20.05000        | 20.05000        |                                    |
      | 3333    | 20.05000        | 20.05000        |                                    |
      | 3333    | 18.80000        | 18.80000        |                                    |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                                      |
      | 1111    | 59.5            | 59.5            | portfolio and benchmark mundane values: 59.4 |
      | 1111    | 30.3            | 30.3            |                                              |
      | 1111    | 10.2            | 10.2            |                                              |
      | 1111    | 0.0             | 0.0             |                                              |
      | 1111    | 0.0             | 0.0             |                                              |
      | 2222    | 55.1            | 55.1            | portfolio and benchmark mundane values: 55.0 |
      | 2222    | 44.9            | 44.9            |                                              |
      | 2222    | 0.0             | 0.0             |                                              |
      | 2222    | 0.0             | 0.0             |                                              |
      | 3333    | 20.9            | 20.1            | portfolio mundane value: 21.1                |
      | 3333    | 20.1            | 20.9            | benchmark mundane value: 21.1                |
      | 3333    | 20.1            | 20.1            |                                              |
      | 3333    | 20.1            | 20.1            |                                              |
      | 3333    | 18.8            | 18.8            |                                              |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: missing data, a.k.a. nulls, prevents magic rounding of the values
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                            |
      | 1111    | 59.40000        | 59.40000        |                                    |
      | 1111    | 30.30001        | 30.30001        |                                    |
      | 1111    | 10.20001        | 10.20001        |                                    |
      | 1111    | null            | 0.04999         | portfolio values have missing data |
      | 1111    | 0.04999         | 0.04999         |                                    |
      | 2222    | 54.99999        | 54.99999        |                                    |
      | 2222    | 44.90003        | 44.90003        |                                    |
      | 2222    | 0.04999         | null            | benchmark values have missing data |
      | 2222    | 0.04999         | 0.04999         |                                    |
      | 3333    | 21.05000        | 20.05000        |                                    |
      | 3333    | 20.05000        | 21.05000        |                                    |
      | 3333    | 20.05000        | 20.05000        |                                    |
      | 3333    | 20.05000        | null            | both benchmark and portfolio       |
      | 3333    | null            | 18.80000        | values have missing data           |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                       |
      | 1111    | 59.4            | 59.5            | benchmark mundane value: 59.4 |
      | 1111    | 30.3            | 30.3            |                               |
      | 1111    | 10.2            | 10.2            |                               |
      | 1111    | null            | 0.0             |                               |
      | 1111    | 0.0             | 0.0             |                               |
      | 2222    | 55.1            | 55.0            | portfolio mundane value: 55.0 |
      | 2222    | 44.9            | 44.9            |                               |
      | 2222    | 0.0             | null            |                               |
      | 2222    | 0.0             | 0.0             |                               |
      | 3333    | 21.1            | 20.1            |                               |
      | 3333    | 20.1            | 21.1            |                               |
      | 3333    | 20.1            | 20.1            |                               |
      | 3333    | 20.1            | null            |                               |
      | 3333    | null            | 18.8            |                               |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: If numbers are tied as the largest number only modify one. The one chosen for modification does not matter.
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.04999         | 0.04999         |
      | 1111    | 0.00004         | 0.00004         |
      | 1111    | 49.90000        | 49.90000        |
      | 1111    | 49.90000        | 49.90000        |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 0.0             | 0.0             |
      | 1111    | 49.9            | 49.9            |
      | 1111    | 50.1            | 50.1            |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario Outline: magic rounding occurs even if incoming data does not add up to approximately 100
    Given target tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value |
      | 1111    | 1.21020         | 5.21020         |
      | 1111    | 2.43039         | 2.43039         |
    When characteristics data are transferred
    Then reporting tables contain the following <characteristic> section data
      | port id | portfolio value | benchmark value | comment                      |
      | 1111    | 1.2             | 97.6            | benchmark mundane value: 5.2 |
      | 1111    | 98.8            | 2.4             | portfolio mundane value: 2.4 |

    Examples: 
      | characteristic                        |
      | Market Segmentation by Capitalization |
      | Regional Allocation                   |
      | Country Allocation                    |
      | Sector Allocation                     |
      | Currency Allocation                   |

  @IntegrationTest
  Scenario: magic and mundane rounding for Top 10 Holdings - sometimes needs to sum to 100.0
    Given target tables contain the following Top 10 Holdings section data
      | port id | portfolio value | benchmark value | comment                                         |
      | 1111    | 33.90002        | 33.90002        | port id has 14 values                           |
      | 1111    | 11.00000        | 11.00000        |                                                 |
      | 1111    | 10.00000        | 10.00000        |                                                 |
      | 1111    | 9.00000         | 9.00000         |                                                 |
      | 1111    | 8.00000         | 2.00000         | portfolio and benchmark values different        |
      | 1111    | 7.00000         | 7.00000         |                                                 |
      | 1111    | 6.00000         | 6.00000         |                                                 |
      | 1111    | 5.00000         | 5.00000         |                                                 |
      | 1111    | 4.00000         | 4.00000         |                                                 |
      | 1111    | 3.00000         | 3.00000         |                                                 |
      | 1111    | 2.00000         | 8.00000         | portfolio and benchmark values different        |
      | 1111    | 1.00000         | 1.00000         |                                                 |
      | 1111    | 0.04999         | 0.04999         |                                                 |
      | 1111    | 0.04999         | 0.04999         |                                                 |
      | 2222    | 33.90002        | 33.90002        | port id has 10 values                           |
      | 2222    | 11.00000        | 11.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 10.00000        | 10.00000        |                                                 |
      | 2222    | 5.00000         | 5.00000         |                                                 |
      | 2222    | 0.04999         | 0.04999         |                                                 |
      | 2222    | 0.04999         | 0.04999         |                                                 |
      | 3333    | 0.04999         | 0.04999         | port id has 5 values (magic rounding in effect) |
      | 3333    | 0.04999         | 0.04999         |                                                 |
      | 3333    | 59.40000        | 39.40000        | max portfolio value                             |
      | 3333    | 30.30001        | 50.30001        | max benchmark value                             |
      | 3333    | 10.20001        | 10.20001        |                                                 |
    When characteristics data are transferred
    Then reporting tables contain the following Top 10 Holdings section data
      | port id | portfolio value | benchmark value | comment                                                |
      | 1111    | 33.9            | 33.9            | sum for ten (of 14) displayed portfolio values is 96.9 |
      | 1111    | 11.0            | 11.0            | sum for ten (of 14) displayed benchmark values is 90.9 |
      | 1111    | 10.0            | 10.0            |                                                        |
      | 1111    | 9.0             | 9.0             |                                                        |
      | 1111    | 8.0             | 2.0             |                                                        |
      | 1111    | 7.0             | 7.0             |                                                        |
      | 1111    | 6.0             | 6.0             |                                                        |
      | 1111    | 5.0             | 5.0             |                                                        |
      | 1111    | 4.0             | 4.0             |                                                        |
      | 1111    | 3.0             | 3.0             |                                                        |
      | 1111    | 2.0             | 8.0             |                                                        |
      | 1111    | 1.0             | 1.0             |                                                        |
      | 1111    | 0.0             | 0.0             |                                                        |
      | 1111    | 0.0             | 0.0             |                                                        |
      | 2222    | 33.9            | 33.9            | sum for ten (of ten) displayed (both) values is 99.9   |
      | 2222    | 11.0            | 11.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 10.0            | 10.0            |                                                        |
      | 2222    | 5.0             | 5.0             |                                                        |
      | 2222    | 0.0             | 0.0             |                                                        |
      | 2222    | 0.0             | 0.0             |                                                        |
      | 3333    | 0.0             | 0.0             | sum for five displayed (both) values is 100.0          |
      | 3333    | 0.0             | 0.0             |                                                        |
      | 3333    | 59.5            | 39.4            | portfolio mundane value: 59.4                          |
      | 3333    | 30.3            | 50.4            | benchmark mundane value: 50.3                          |
      | 3333    | 10.2            | 10.2            |                                                        |

  @IntegrationTest
  Scenario: mundane rounding for Portfolio Characteristics - does not need to sum to 100.0
    Given target tables contain the following Portfolio Characteristics section data
      | port id | portfolio value | benchmark value | comment                                  |
      | 1111    | 59.40000        | 59.40000        |                                          |
      | 1111    | 30.30001        | 30.30001        |                                          |
      | 1111    | 10.20001        | 10.20001        |                                          |
      | 1111    | 0.04999         | 0.04999         |                                          |
      | 1111    | 0.04999         | 0.04999         |                                          |
      | 2222    | 54.99999        | 54.99999        |                                          |
      | 2222    | 44.90003        | 44.90003        |                                          |
      | 2222    | 0.04999         | 0.04999         |                                          |
      | 2222    | 0.04999         | 0.04999         |                                          |
      | 3333    | 21.05000        | 20.05000        | portfolio and benchmark values different |
      | 3333    | 20.05000        | 21.05000        | portfolio and benchmark values different |
      | 3333    | 20.05000        | 20.05000        |                                          |
      | 3333    | 20.05000        | 20.05000        |                                          |
      | 3333    | 18.80000        | 18.80000        |                                          |
    When characteristics data are transferred
    Then reporting tables contain the following Portfolio Characteristics section data
      | port id | portfolio value | benchmark value | comment                |
      | 1111    | 59.4            | 59.4            |                        |
      | 1111    | 30.3            | 30.3            |                        |
      | 1111    | 10.2            | 10.2            |                        |
      | 1111    | 0.0             | 0.0             |                        |
      | 1111    | 0.0             | 0.0             |                        |
      | 2222    | 55.0            | 55.0            |                        |
      | 2222    | 44.9            | 44.9            |                        |
      | 2222    | 0.0             | 0.0             |                        |
      | 2222    | 0.0             | 0.0             |                        |
      | 3333    | 21.1            | 20.1            | portfolio not adjusted |
      | 3333    | 20.1            | 21.1            | benchmark not adjusted |
      | 3333    | 20.1            | 20.1            |                        |
      | 3333    | 20.1            | 20.1            |                        |
      | 3333    | 18.8            | 18.8            |                        |


		commentary.feature

@Commentary
Feature: User can create or update commentary for a mandate through a REST call.

  @EndToEndTest
  Scenario: Create commentary entry for a mandate
    Given a mandate exists in the product portal
    When commentary is added for a mandate on a specified date
    Then the system indicates successful completion of the commentary entry

  @EndToEndTest
  Scenario: Update a commentary entry for a mandate
    Given a commentary entry exists for a mandate on a specified date
    When commentary is added for a mandate on a specified date
    Then the system indicates successful completion of the commentary update

  @EndToEndTest
  Scenario: Retrieve commentary for a mandate
    Given a commentary entry exists for a mandate on a specified date
    When commentary is requested for a manadate on a specified date
    Then the system indicates successful completion of the commentary retrieval

		investmentObjective.feature

@IntegrationTest
Feature: File for Investment Objective (Report Sections)

  Scenario: Investment Objective for portfolio
    Given a portfolio with Investment Objective that exists in Product Portal
    When user runs the report service
    Then the table shall contain Investment Objective
    
    # Maximum length is 2000 characters
    

		portfolioOverview.feature

@IntegrationTest
Feature: Portfolio Overview (Report Sections)

  Scenario: Portfolio Overview data load service
    Given a portfolio with the following attributes
      | Product Code | Portfolio Manager       | Inception Date | Benchmark                             | Portfolio Currency |
      | ONE90        | Equity Investment Group | 08-Mar-2016    | S&P/ASX 300 A-REIT Accumulation Index | AUD                |
    When report service is run by user
    Then the table shall contain the following information
      | Product Code | Portfolio Manager       | Inception Date | Benchmark                             | Portfolio Currency |
      | ONE90        | Equity Investment Group | 08-Mar-2016    | S&P/ASX 300 A-REIT Accumulation Index | AUD                |

    # Maximum length of data attributes:
    # Portfolio Manager: 30
    # Benchmark Name: 100 
    
    # Revisit scenario once Mandate Size requirements are finalized

		reportHeader.feature

@IntegrationTest
Feature: Report Header (Report Section)

  Scenario Outline: Report Header data load service
    Given a portfolio with <Product Code> that has <Client Name> and <Mandate Name> which exists in Product Portal
    When report service is run by user for <Product Code>
    Then the table shall contain <Client Name> and <Mandate Name> for <Product Code>

    # Maximum length of data attributes:
    #Client Name- 100
    #mandate Name- 100
    #Product Code- 20
    Examples: 
      | Product Code | Client Name           | Mandate Name|
      | CBUS39   | CBUS                              |CBUS Australian Fixed Income Fund|
      

		riskSummary.feature

@IntegrationTest
Feature: Risk Summary (Report Sections)

  Scenario Outline: Limits for Portfolio with analytics
    Given a portfolio with <Analytic Type> and <portal limit> that exists in Product Portal
    When user runs the Risk Summary calculations
    Then the reporting table shall show <table limit>

    Examples: 
      | portal limit | table limit | Analytic Type               |
      | 5            | 0.05        | Ex Ante- Tracking Error     |
      | 10           | 0.1         | Ex Ante- Tracking Error     |
      | 0            | 0.0         | Ex Ante- Tracking Error     |
      | -10          | -0.1        | Ex Ante- Tracking Error     |
      | 5            | 0.05        | 1 yr Ex-Post Tracking Error |
      | 10           | 0.1         | 1 yr Ex-Post Tracking Error |
      | 0            | 0.0         | 1 yr Ex-Post Tracking Error |
      | -10          | -0.1        | 1 yr Ex-Post Tracking Error |
      | 5            | 0.05        | 3 yr Ex-Post Tracking Error |
      | 10           | 0.1         | 3 yr Ex-Post Tracking Error |
      | 0            | 0.0         | 3 yr Ex-Post Tracking Error |
      | -10          | -0.1        | 3 yr Ex-Post Tracking Error |
      | 5            |             | 1 yr Standard Deviation     |
      | 10           |             | 1 yr Standard Deviation     |
      | 0            |             | 1 yr Standard Deviation     |
      | -10          |             | 1 yr Standard Deviation     |
      | 5            |             | 3 yr Standard Deviation     |
      | 10           |             | 3 yr Standard Deviation     |
      | 0            |             | 3 yr Standard Deviation     |
      | -10          |             | 3 yr Standard Deviation     |

  Scenario Outline: Split Limits for Portfolio with Analytics
    Given a portfolio with <Analytic Type>, <portal lower limit>, <portal upper limit>, and <portal split limit> that exists in Product Portal
    When user runs the Risk Summary calculations
    Then the reporting table shall show <table lower limit> and <table upper limit> and <table split limit>

    Examples: 
      | portal lower limit | table lower limit | Analytic Type               | portal upper limit | table upper limit | portal split limit | table split limit |
      | 5                  | 0.05              | Ex Ante- Tracking Error     | 10                 | 0.1               | 50000000           | 50000000          |
      | 10                 | 0.1               | Ex Ante- Tracking Error     | 20                 | 0.2               | 50000000           | 50000000          |
      | 0                  | 0.0               | Ex Ante- Tracking Error     | 0                  | 0.0               | 50000000           | 50000000          |
      | -10                | -0.1              | Ex Ante- Tracking Error     | -20                | -0.2              | 50000000           | 50000000          |
      | 5                  | 0.05              | 1 yr Ex-Post Tracking Error | 10                 |                   | 50000000           |                   |
      | 10                 | 0.1               | 1 yr Ex-Post Tracking Error | 20                 |                   | 50000000           |                   |
      | 0                  | 0.0               | 1 yr Ex-Post Tracking Error | 0                  |                   | 50000000           |                   |
      | -10                | -0.1              | 1 yr Ex-Post Tracking Error | -20                |                   | 50000000           |                   |
      | 5                  | 0.05              | 3 yr Ex-Post Tracking Error | 10                 |                   | 50000000           |                   |
      | 10                 | 0.1               | 3 yr Ex-Post Tracking Error | 20                 |                   | 50000000           |                   |
      | 0                  | 0.0               | 3 yr Ex-Post Tracking Error | 0                  |                   | 50000000           |                   |
      | -10                | -0.1              | 3 yr Ex-Post Tracking Error | -20                |                   | 50000000           |                   |
      | 5                  |                   | 1 yr Standard Deviation     | 10                 |                   | 50000000           |                   |
      | 10                 |                   | 1 yr Standard Deviation     | 20                 |                   | 50000000           |                   |
      | 0                  |                   | 1 yr Standard Deviation     | 0                  |                   | 50000000           |                   |
      | -10                |                   | 1 yr Standard Deviation     | -10                |                   | 50000000           |                   |
      | 5                  |                   | 3 yr Standard Deviation     | 10                 |                   | 50000000           |                   |
      | 10                 |                   | 3 yr Standard Deviation     | 20                 |                   | 50000000           |                   |
      | 0                  |                   | 3 yr Standard Deviation     | 0                  |                   | 50000000           |                   |
      | -10                |                   | 3 yr Standard Deviation     | -20                |                   | 50000000           |                   |

		runTest.feature

@RunATest
Feature:  We need to have an integration test

	@IntegrationTest
	Scenario: Run an integration test
	When user calls a service
	Then the response code is OK

	security.feature

@Security
Feature: security and permissions functionality
  
  Specifications:
  1. 
  
  Assumptions:
  1. We will have one or more SBFs that grant permission to transfer data.
  
  Definitions:
  1. IgnoreTest - eventually we will implement this

  @EndToEndTest @IgnoreTest
  Scenario: user has permission to transfer data
    Given test data are loaded into target tables
    And a user with valid permission to request transfer of data
    When transfer of data is requested
    Then the system indicates successful completion of the transfer
    And the test data are saved in reporting tables
    And the test data are cleaned up from the target tables
    And the test data are cleaned up from the reporting tables

  @EndToEndTest @IgnoreTest
  Scenario: negative test - user without permission to transfer data
    Given test data are loaded into target tables
    And a user without valid permission to request transfer of data
    When transfer of data is requested
    Then the system indicates failure due to no permission
    And the test data are not saved in reporting tables
    And the test data are cleaned up from the target tables


		valuations.feature

Feature: Valuation data movement from Target to Reporting

@IntegrationTest
  Scenario Outline: Portfolio with at least one Asset type
    Given a portfolio with <asset type> with <current month source> and <prior month source>
    When user runs portfolio valuation calculations for <current month>
    Then prior month NAV value matches value for < prior month report>
    And current month NAV value matches value for < current month report>

    Examples: 
      | current month source | prior month source | current month | prior month report | current month report | asset type        |
      | 0                    | 0                  | June 2017     | 0                  | 0                    | Equity            |
      | 10000                | 0                  | June 2017     | 0                  | 10000                | Equity            |
      | 0                    | 0                  | June 2017     | 0                  | 0                    | Liquidity         |
      | 10000                | 0                  | June 2017     | 0                  | 10000                | Liquidity         |
      | 0                    | 0                  | June 2017     | 0                  | 0                    | Futures Exposures |
      | 10000                | 0                  | June 2017     | 0                  | 10000                | Futures Exposures |
      | 0                    | 0                  | June 2017     | 0                  | 0                    | Derivatives       |
      | 10000                | 0                  | June 2017     | 0                  | 10000                | Derivatives       |
      | 0                    | 0                  | June 2017     | 0                  | 0                    | Securities        |
      | 10000                | 0                  | June 2017     | 0                  | 10000                | Securities        |
      | -10000               | 0                  | June 2017     | 0                  | -10000               | Futures Exposures |
      | -10000               | 0                  | June 2017     | 0                  | -10000               | FFX               |
      | -10000               | 0                  | June 2017     | 0                  | -10000               | Derivatives       |
      | 5000                 | 5000               | June 2017     | 5000               | 5000                 | Equity            |
      | 5000                 | 5000               | June 2017     | 5000               | 5000                 | Liquidity         |
      | 5000                 | 5000               | June 2017     | 5000               | 5000                 | Futures Exposures |
      | 5000                 | 5000               | June 2017     | 5000               | 5000                 | Derivatives       |
      | 5000                 | 5000               | June 2017     | 5000               | 5000                 | Securities        |
      | 5000                 | 5000               | June 2017     | 5000               | 5000                 | FFX               |
      | -10000               | 5000               | June 2017     | 5000               | -10000               | Futures Exposures |
      | -10000               | 5000               | June 2017     | 5000               | -10000               | FFX               |
      | -10000               | 5000               | June 2017     | 5000               | -10000               | Derivatives       |
      | 10000                | -5000              | June 2017     | -5000              | 10000                | Futures Exposures |
      | 10000                | -5000              | June 2017     | -5000              | 10000                | FFX               |
      | 10000                | -5000              | June 2017     | -5000              | 10000                | Derivatives       |

  # Securities Asset type are only applicable to Fixed Income
  @IntegrationTest
  Scenario: Total of all the assets in the portfolio
    Given a portfolio with multiple asset types
    When user runs portfolio valuation calculations for <current month>
    Then current month total will be the sum of all current month assets
    And prior month total will be total of prior month assets


applicationContext.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- The jersey-spring3 jar expects this applicationContext.xml classpath 
		file for running Jersey tests outside of a servlet container. -->
	<context:annotation-config />
	<context:component-scan base-package="com.vanguard.corp.ics.sdt.webservice" />
	
</beans>

cucumber.xml

<beans xmlns:context="http://www.springframework.org/schema/context"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns="http://www.springframework.org/schema/beans"
		xsi:schemaLocation="
				http://www.springframework.org/schema/beans
				http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
				http://www.springframework.org/schema/context
				http://www.springframework.org/schema/context/spring-context-3.0.xsd
				"
		>

	<context:annotation-config/>
	<context:component-scan base-package="com.vanguard.corp.ics.sdt.webservice.cucumber.stepdefs.shared" />
</beans>


----------------------------------------
pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>com.vanguard</groupId>
		<artifactId>nextgen-parent</artifactId>
		<version>[2.1,3.0)</version>
	</parent>

	<groupId>com.vanguard.corp.ics</groupId>
	<artifactId>sma-data-transformer.webservice</artifactId>
	<version>1.0.0</version>
	<packaging>jar</packaging>

	<name>sma-data-transformer.webservice</name>
	<description>Sma Data Transformer webservice project created from the NGA Spring Boot JAX-RS archetype</description>

	<scm>
		<connection>scm:git:http://stash.vanguard.com:7990/scm/icssdt/sma-data-transformer.webservice.git</connection>
		<developerConnection>scm:git:http://stash.vanguard.com:7990/scm/icssdt/sma-data-transformer.webservice.git</developerConnection>
	</scm>

	<!-- Fill in either the list of developers or the mailing list or both -->

	<developers>
		<developer>
			<id>uwja</id>
			<name>Jason Warner</name>
			<roles>
				<role>Developer</role>
			</roles>
		</developer>

		<developer>
			<id>uqrc</id>
			<name>Kyle Brower</name>
			<roles>
				<role>Developer</role>
			</roles>
		</developer>

		<developer>
			<id>ubug</id>
			<name>Alex Fischbein</name>
			<roles>
				<role>Developer</role>
			</roles>
		</developer>
	</developers>

	<properties>
		<deployment.type>internal</deployment.type>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<!-- http://crewhub.vanguard.com/it/cop1/cloudapp/MATS%20Docs/Module%20Categories.aspx -->
		<mats.module.type>business-service-impl</mats.module.type>
		<!-- http://crewhub.vanguard.com/it/cop1/cloudapp/MATS%20Docs/Business%20Capabilities.aspx -->
		<mats.business.capability>spring-boot-jaxrs-demo</mats.business.capability>
		<spring.boot.version>1.2.2.RELEASE</spring.boot.version>
		<spring.version>4.1.6.RELEASE</spring.version>
		<gemfire.version>8.2.5</gemfire.version>
		
		<!-- test coverage minimums, reinstated ABOVE parent minimums per TSOS meeting 2017-10-03 -->
		<!-- these should only increase over time, never decrease -->
		<project.differential.coverage.threshold>100</project.differential.coverage.threshold>
		<project.differential.line.coverage.threshold>100</project.differential.line.coverage.threshold>
		<project.differential.branches.coverage.threshold>100</project.differential.branches.coverage.threshold>
		<project.line.coverage.threshold>95</project.line.coverage.threshold>
		<project.branch.coverage.threshold>81.6</project.branch.coverage.threshold>
	</properties>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-framework-bom</artifactId>
				<version>${spring.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
			<!-- Hystrix overrides -->
			<dependency>
				<groupId>com.netflix.archaius</groupId>
				<artifactId>archaius-core</artifactId>
				<version>0.7.3</version>
			</dependency>
			<dependency>
				<groupId>com.fasterxml.jackson.core</groupId>
				<artifactId>jackson-core</artifactId>
				<version>2.6.5</version>
			</dependency>
			<dependency>
				<groupId>com.fasterxml.jackson.core</groupId>
				<artifactId>jackson-databind</artifactId>
				<version>2.6.5</version>
			</dependency>
			<dependency>
				<groupId>com.fasterxml.jackson.core</groupId>
				<artifactId>jackson-annotations</artifactId>
				<version>2.6.5</version>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<dependencies>
		<!-- Common VG Spring Boot module -->
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>spring-boot-common</artifactId>
			<version>1.1.0.COMMON-SBCOMMON-23</version>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>vanguard-spring-core-spring-4</artifactId>
			<version>1.1-M20160505-01</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
			<version>${spring.boot.version}</version>
			<exclusions>
				<exclusion>
					<artifactId>logback-classic</artifactId>
					<groupId>ch.qos.logback</groupId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>vanguard-spring-boot-actuator</artifactId>
			<version>1.0.0.COMMON-VGSBACT-6</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<version>${spring.boot.version}</version>
		</dependency>
		<dependency>
			<groupId>com.vanguard.validation</groupId>
			<artifactId>vanguard-validator</artifactId>
			<version>1.1.0.COMMON-VANVAL-13</version>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>vgservlet</artifactId>
			<version>1.1-M20160328-01</version>
		</dependency>

		<!-- Hystrix dependencies -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-hystrix</artifactId>
			<version>1.0.3.RELEASE</version>
		</dependency>

		<!-- Logging dependencies -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>1.7.10</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-log4j2</artifactId>
			<version>${spring.boot.version}</version>
			<scope>runtime</scope>
			<exclusions>
				<exclusion>
					<groupId>org.apache.logging.log4j</groupId>
					<artifactId>log4j-slf4j-impl</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>logging-aspect-spring-4</artifactId>
			<version>1.0-M20151103-01</version>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>logging-impl-spring-4</artifactId>
			<version>1.1-M20161214-01</version>
			<scope>runtime</scope>
		</dependency>

		<!-- Gemfire dependencies -->
		<dependency>
			<groupId>com.gemstone.gemfire</groupId>
			<artifactId>gemfire</artifactId>
			<version>${gemfire.version}</version>
		</dependency>
		<dependency>
			<groupId>com.vanguard.ssg</groupId>
			<artifactId>gfs-client</artifactId>
			<version>1.3.0-M20161104-01</version>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>gemfire-aws-common</artifactId>
			<version>1.0.0.GEMF-GEMAWSCMN-4</version>
		</dependency>

		<!-- JPA dependencies -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
			<version>${spring.boot.version}</version>
			<exclusions>
				<exclusion>
					<artifactId>logback-classic</artifactId>
					<groupId>ch.qos.logback</groupId>
				</exclusion>
				<exclusion>
					<groupId>org.springframework</groupId>
					<artifactId>spring-aop</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.0.0.Final</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<version>1.4.193</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-jpa</artifactId>
			<version>1.8.1.RELEASE</version>
			<exclusions>
				<exclusion>
					<groupId>org.springframework</groupId>
					<artifactId>spring-orm</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.vanguard.corp.ics</groupId>
			<artifactId>targetdataaccess</artifactId>
			<version>1.0.0-SNAPSHOT</version>
		</dependency>

		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>12.1.0.2.0</version>
		</dependency>
		<!-- Jersey dependencies -->
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>jaxrs-api-dependencies</artifactId>
			<version>2.0.0-M20161007-01</version>
			<type>pom</type>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>jaxrs-runtime-dependencies</artifactId>
			<version>2.1.0-M20150723-01</version>
			<type>pom</type>
			<scope>runtime</scope>
			<exclusions>
				<exclusion>
					<artifactId>jersey-media-json-jackson</artifactId>
					<groupId>org.glassfish.jersey.media</groupId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.vanguard.jaxrs</groupId>
			<artifactId>jaxrs-common</artifactId>
			<version>2.1.0.COMMON-JAXRS-13</version>
		</dependency>

		<!-- DB2 Dependencies -->
		<dependency>
			<groupId>com.ibm.db2</groupId>
			<artifactId>db2jcc</artifactId>
			<version>9.1</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.db2</groupId>
			<artifactId>db2jcc_license_cisuz</artifactId>
			<version>9.1</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.db2</groupId>
			<artifactId>db2jcc_license_cu</artifactId>
			<version>9.1</version>
		</dependency>

		<!-- require for VGUser Logon POID -->
		<dependency>
			<groupId>com.vanguard.services</groupId>
			<artifactId>suds-lib-ehcache-spring-4-client</artifactId>
			<version>3.0.0-M20160429-01</version>
			<exclusions>
				<exclusion>
					<groupId>javax.servlet</groupId>
					<artifactId>servlet-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<!-- Test only dependencies -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<version>${spring.boot.version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>com.vanguard.test</groupId>
			<artifactId>vanguard-test</artifactId>
			<version>1.0.0-M20160504-01</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.mockito</groupId>
			<artifactId>mockito-core</artifactId>
			<version>2.7.22</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>jaxrs-testing-dependencies</artifactId>
			<version>2.1.0-M20160504-01</version>
			<type>pom</type>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>com.vanguard</groupId>
			<artifactId>cucumber-inner-source</artifactId>
			<version>1.1.1-M20170516-01</version>
			<scope>test</scope>
			<classifier>tests</classifier>
		</dependency>
		<dependency>
			<groupId>org.powermock</groupId>
			<artifactId>powermock-reflect</artifactId>
			<version>1.7.0</version>
			<scope>test</scope>
		</dependency>

		<!-- Provided dependencies -->
		<!-- Needed for command-line compilation -->
		<!-- spring-boot-maven-plugin:repackage includes provided scoped and optional 
			jars by design, exclude in plugin configuration below -->
		<!-- https://github.com/spring-projects/spring-boot/issues/413 -->
		<!-- http://docs.spring.io/autorepo/docs/spring-boot/1.1.6.RELEASE/maven-plugin/examples/exclude-dependency.html -->
		<!-- Using 3.1.0 to match Spring Boot 1.2 version, explicitly as we don't 
			have the newer versions in Nexus and whitelisted, and also to avoid an error 
			seen with servlet-api 3.0: java.lang.NoSuchMethodError: javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String; -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-integration</artifactId>
			<version>1.2.2.RELEASE</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<!-- Make the packaged artifact executable through java -jar -->
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<version>${spring.boot.version}</version>
				<executions>
					<execution>
						<goals>
							<goal>repackage</goal>
						</goals>
					</execution>
				</executions>
				<configuration>
					<excludes>
						<exclude>
							<groupId>javax.servlet</groupId>
							<artifactId>javax.servlet-api</artifactId>
						</exclude>
						<exclude>
							<groupId>javax.servlet</groupId>
							<artifactId>servlet-api</artifactId>
						</exclude>
					</excludes>
					<requiresUnpack>
						<!-- Jersey is unable to scan Spring Boot's nested jars: https://github.com/spring-projects/spring-boot/issues/1345 -->
						<dependency>
							<groupId>com.vanguard.jaxrs</groupId>
							<artifactId>jaxrs-common</artifactId>
						</dependency>
					</requiresUnpack>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>



